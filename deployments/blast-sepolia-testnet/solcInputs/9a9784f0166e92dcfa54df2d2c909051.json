{
  "language": "Solidity",
  "sources": {
    "contracts/access/AccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../vendor/@openzeppelin/contracts@4.8.2/access/AccessControl.sol\";\nimport \"../utils/SelfMulticall.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract that allows users to manage independent, tree-shaped access\n/// control tables\n/// @notice Multiple contracts can refer to this contract to check if their\n/// users have granted accounts specific roles. Therefore, it aims to keep all\n/// access control roles of its users in this single contract.\n/// @dev Each user is called a \"manager\", and is the only member of their root\n/// role. Starting from this root role, they can create an arbitrary tree of\n/// roles and grant these to accounts. Each role has a description, and roles\n/// adminned by the same role cannot have the same description.\ncontract AccessControlRegistry is\n    AccessControl,\n    SelfMulticall,\n    RoleDeriver,\n    IAccessControlRegistry\n{\n    /// @notice Initializes the manager by initializing its root role and\n    /// granting it to them\n    /// @dev Anyone can initialize a manager. An uninitialized manager\n    /// attempting to initialize a role will be initialized automatically.\n    /// Once a manager is initialized, subsequent initializations have no\n    /// effect.\n    /// @param manager Manager address to be initialized\n    function initializeManager(address manager) public override {\n        require(manager != address(0), \"Manager address zero\");\n        bytes32 rootRole = _deriveRootRole(manager);\n        if (!hasRole(rootRole, manager)) {\n            _grantRole(rootRole, manager);\n            emit InitializedManager(rootRole, manager, _msgSender());\n        }\n    }\n\n    /// @notice Called by the account to renounce the role\n    /// @dev Overriden to disallow managers from renouncing their root roles.\n    /// `role` and `account` are not validated because\n    /// `AccessControl.renounceRole` will revert if either of them is zero.\n    /// @param role Role to be renounced\n    /// @param account Account to renounce the role\n    function renounceRole(\n        bytes32 role,\n        address account\n    ) public override(AccessControl, IAccessControl) {\n        require(\n            role != _deriveRootRole(account),\n            \"role is root role of account\"\n        );\n        AccessControl.renounceRole(role, account);\n    }\n\n    /// @notice Initializes a role by setting its admin role and grants it to\n    /// the sender\n    /// @dev If the sender should not have the initialized role, they should\n    /// explicitly renounce it after initializing it.\n    /// Once a role is initialized, subsequent initializations have no effect\n    /// other than granting the role to the sender.\n    /// The sender must be a member of `adminRole`. `adminRole` value is not\n    /// validated because the sender cannot have the `bytes32(0)` role.\n    /// If the sender is an uninitialized manager that is initializing a role\n    /// directly under their root role, manager initialization will happen\n    /// automatically, which will grant the sender `adminRole` and allow them\n    /// to initialize the role.\n    /// @param adminRole Admin role to be assigned to the initialized role\n    /// @param description Human-readable description of the initialized role\n    /// @return role Initialized role\n    function initializeRoleAndGrantToSender(\n        bytes32 adminRole,\n        string calldata description\n    ) external override returns (bytes32 role) {\n        require(bytes(description).length > 0, \"Role description empty\");\n        role = _deriveRole(adminRole, description);\n        // AccessControl roles have `DEFAULT_ADMIN_ROLE` (i.e., `bytes32(0)`)\n        // as their `adminRole` by default. No account in AccessControlRegistry\n        // can possibly have that role, which means all initialized roles will\n        // have non-default admin roles, and vice versa.\n        if (getRoleAdmin(role) == DEFAULT_ADMIN_ROLE) {\n            if (adminRole == _deriveRootRole(_msgSender())) {\n                initializeManager(_msgSender());\n            }\n            _setRoleAdmin(role, adminRole);\n            emit InitializedRole(role, adminRole, description, _msgSender());\n        }\n        grantRole(role, _msgSender());\n    }\n}\n"
    },
    "contracts/access/AccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/SelfMulticall.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminned.sol\";\nimport \"./interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract to be inherited by contracts whose adminship functionality\n/// will be implemented using AccessControlRegistry\ncontract AccessControlRegistryAdminned is\n    SelfMulticall,\n    RoleDeriver,\n    IAccessControlRegistryAdminned\n{\n    /// @notice AccessControlRegistry contract address\n    address public immutable override accessControlRegistry;\n\n    /// @notice Admin role description\n    string public override adminRoleDescription;\n\n    bytes32 internal immutable adminRoleDescriptionHash;\n\n    /// @dev Contracts deployed with the same admin role descriptions will have\n    /// the same roles, meaning that granting an account a role will authorize\n    /// it in multiple contracts. Unless you want your deployed contract to\n    /// share the role configuration of another contract, use a unique admin\n    /// role description.\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    ) {\n        require(_accessControlRegistry != address(0), \"ACR address zero\");\n        require(\n            bytes(_adminRoleDescription).length > 0,\n            \"Admin role description empty\"\n        );\n        accessControlRegistry = _accessControlRegistry;\n        adminRoleDescription = _adminRoleDescription;\n        adminRoleDescriptionHash = keccak256(\n            abi.encodePacked(_adminRoleDescription)\n        );\n    }\n\n    /// @notice Derives the admin role for the specific manager address\n    /// @param manager Manager address\n    /// @return adminRole Admin role\n    function _deriveAdminRole(\n        address manager\n    ) internal view returns (bytes32 adminRole) {\n        adminRole = _deriveRole(\n            _deriveRootRole(manager),\n            adminRoleDescriptionHash\n        );\n    }\n}\n"
    },
    "contracts/access/AccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AccessControlRegistryAdminned.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\n/// @title Contract to be inherited by contracts with manager whose adminship\n/// functionality will be implemented using AccessControlRegistry\n/// @notice The manager address here is expected to belong to an\n/// AccessControlRegistry user that is a multisig/DAO\ncontract AccessControlRegistryAdminnedWithManager is\n    AccessControlRegistryAdminned,\n    IAccessControlRegistryAdminnedWithManager\n{\n    /// @notice Address of the manager that manages the related\n    /// AccessControlRegistry roles\n    /// @dev The mutability of the manager role can be implemented by\n    /// designating an OwnableCallForwarder contract as the manager. The\n    /// ownership of this contract can then be transferred, effectively\n    /// transferring managership.\n    address public immutable override manager;\n\n    /// @notice Admin role\n    /// @dev Since `manager` is immutable, so is `adminRole`\n    bytes32 public immutable override adminRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminned(\n            _accessControlRegistry,\n            _adminRoleDescription\n        )\n    {\n        require(_manager != address(0), \"Manager address zero\");\n        manager = _manager;\n        adminRole = _deriveAdminRole(_manager);\n    }\n}\n"
    },
    "contracts/access/HashRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../vendor/@openzeppelin/contracts@4.9.5/access/Ownable.sol\";\nimport \"./interfaces/IHashRegistry.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.9.5/utils/cryptography/ECDSA.sol\";\n\n/// @title A contract where a value for each hash type can be registered using\n/// the signatures of the respective signers that are set by the contract owner\n/// @notice Hashes are identified by a unique \"hash type\", which is a `bytes32`\n/// type that can be determined based on any arbitrary convention. The contract\n/// owner can set a list of signers for each hash type. For a hash value to be\n/// registered, its signers must be set by the contract owner, and valid\n/// signatures by each signer must be provided. The hash values are bundled\n/// with timestamps that act as nonces, meaning that each registration must\n/// be with a larger timestamp than the previous. The contract owner can\n/// override previously registered hashes.\n/// A signer can sign a delegation message that allows the delegate to sign\n/// hashes on their behalf across all instances of this contract until the\n/// specified time. This delegation is irrevocable by design (as revoking across\n/// all instances would be error-prone). To undo an unwanted delegation, the\n/// signer must be swapped out by the contract owner until the delegation runs\n/// out.\n/// @dev This contract can be used in standalone form to be referred to through\n/// external calls, or inherited by the contract that will access the\n/// registered hashes internally.\n/// HashRegistry is intended for use-cases where signatures and delegations\n/// need to apply universally across domains, which is why it is blind to the\n/// domain (unlike ERC-712). However, the inheriting contract can implement the\n/// type hashes to be domain-specific.\ncontract HashRegistry is Ownable, IHashRegistry {\n    struct Hash {\n        bytes32 value;\n        uint256 timestamp;\n    }\n\n    /// @notice Hash type to the last registered value and timestamp\n    mapping(bytes32 => Hash) public override hashes;\n\n    /// @notice Hash type to the hash of the array of signer addresses\n    mapping(bytes32 => bytes32) public override hashTypeToSignersHash;\n\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\n\n    // Length of abi.encode(uint256, bytes, bytes), where the bytes types are\n    // ECDSA signatures padded to the next largest multiple of 32 bytes, which\n    // is 96\n    uint256 private constant DELEGATED_SIGNATURE_LENGTH =\n        32 + 32 + 32 + (32 + 96) + (32 + 96);\n\n    /// @param owner_ Owner address\n    constructor(address owner_) {\n        require(owner_ != address(0), \"Owner address zero\");\n        _transferOwnership(owner_);\n    }\n\n    /// @notice Returns the owner address\n    /// @return Owner address\n    function owner()\n        public\n        view\n        virtual\n        override(Ownable, IOwnable)\n        returns (address)\n    {\n        return super.owner();\n    }\n\n    /// @notice Called by the owner to renounce the ownership of the contract\n    function renounceOwnership() public virtual override(Ownable, IOwnable) {\n        return super.renounceOwnership();\n    }\n\n    /// @notice Called by the owner to transfer the ownership of the contract\n    /// @param newOwner New owner address\n    function transferOwnership(\n        address newOwner\n    ) public virtual override(Ownable, IOwnable) {\n        return super.transferOwnership(newOwner);\n    }\n\n    /// @notice Called by the contract owner to set signers for a hash type.\n    /// The signer addresses must be in ascending order.\n    /// @param hashType Hash type\n    /// @param signers Signer addresses\n    function setSigners(\n        bytes32 hashType,\n        address[] calldata signers\n    ) external override onlyOwner {\n        require(hashType != bytes32(0), \"Hash type zero\");\n        uint256 signersCount = signers.length;\n        require(signersCount != 0, \"Signers empty\");\n        require(signers[0] != address(0), \"First signer address zero\");\n        for (uint256 ind = 1; ind < signersCount; ind++) {\n            require(\n                signers[ind] > signers[ind - 1],\n                \"Signers not in ascending order\"\n            );\n        }\n        hashTypeToSignersHash[hashType] = keccak256(abi.encodePacked(signers));\n        emit SetSigners(hashType, signers);\n    }\n\n    /// @notice Called by the owner to set a hash. Overrides previous\n    /// registrations and is allowed to set the value to `bytes32(0)`.\n    /// @param hashType Hash type\n    /// @param hashValue Hash value\n    function setHash(\n        bytes32 hashType,\n        bytes32 hashValue\n    ) external override onlyOwner {\n        hashes[hashType] = Hash({value: hashValue, timestamp: block.timestamp});\n        emit SetHash(hashType, hashValue, block.timestamp);\n    }\n\n    /// @notice Registers the hash value and timestamp for the respective type.\n    /// The hash value cannot be zero.\n    /// The timestamp must not exceed the block timestamp, yet be larger than\n    /// the timestamp of the previous registration.\n    /// The signers must have been set for the hash type, and the signatures\n    /// must be sorted for the respective signer addresses to be in ascending\n    /// order.\n    /// Each signature can either be a standalone signature by the respective\n    /// signer, or a signature by the signer's delegate, encoded along with\n    /// the delegation end timestamp and delegation signature.\n    /// @param hashType Hash type\n    /// @param hashValue Hash value\n    /// @param hashTimestamp Hash timestamp\n    /// @param signatures Signatures\n    function registerHash(\n        bytes32 hashType,\n        bytes32 hashValue,\n        uint256 hashTimestamp,\n        bytes[] calldata signatures\n    ) external override {\n        require(hashValue != bytes32(0), \"Hash value zero\");\n        require(hashTimestamp <= block.timestamp, \"Hash timestamp from future\");\n        require(\n            hashTimestamp > hashes[hashType].timestamp,\n            \"Hash timestamp not more recent\"\n        );\n        bytes32 signersHash = hashTypeToSignersHash[hashType];\n        require(signersHash != bytes32(0), \"Signers not set\");\n        uint256 signaturesCount = signatures.length;\n        address[] memory signers = new address[](signaturesCount);\n        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(hashType, hashValue, hashTimestamp))\n        );\n        for (uint256 ind = 0; ind < signaturesCount; ind++) {\n            uint256 signatureLength = signatures[ind].length;\n            if (signatureLength == ECDSA_SIGNATURE_LENGTH) {\n                signers[ind] = ECDSA.recover(\n                    ethSignedMessageHash,\n                    signatures[ind]\n                );\n            } else if (signatureLength == DELEGATED_SIGNATURE_LENGTH) {\n                (\n                    uint256 delegationEndTimestamp,\n                    bytes memory delegationSignature,\n                    bytes memory hashSignature\n                ) = abi.decode(signatures[ind], (uint256, bytes, bytes));\n                require(\n                    block.timestamp < delegationEndTimestamp,\n                    \"Delegation ended\"\n                );\n                signers[ind] = ECDSA.recover(\n                    ECDSA.toEthSignedMessageHash(\n                        keccak256(\n                            abi.encodePacked(\n                                signatureDelegationHashType(),\n                                ECDSA.recover(\n                                    ethSignedMessageHash,\n                                    hashSignature\n                                ),\n                                delegationEndTimestamp\n                            )\n                        )\n                    ),\n                    delegationSignature\n                );\n            } else {\n                revert(\"Invalid signature length\");\n            }\n        }\n        require(\n            signersHash == keccak256(abi.encodePacked(signers)),\n            \"Signature mismatch\"\n        );\n        hashes[hashType] = Hash({value: hashValue, timestamp: hashTimestamp});\n        emit RegisteredHash(hashType, hashValue, hashTimestamp);\n    }\n\n    /// @notice Returns the signature delegation hash type used in delegation\n    /// signatures\n    /// @dev Delegation signatures signed with a signature delegation hash type\n    /// will apply universally across all HashRegistry instances that use that\n    /// same signature delegation hash type. The inheriting contract can\n    /// specify a special signature delegation hash type by overriding this\n    /// function.\n    /// @return Signature delegation hash type\n    function signatureDelegationHashType()\n        public\n        view\n        virtual\n        override\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\"HashRegistry signature delegation\"));\n    }\n\n    /// @notice Returns get the hash value for the type\n    /// @param hashType Hash type\n    /// @return hashValue Hash value\n    function getHashValue(\n        bytes32 hashType\n    ) external view override returns (bytes32 hashValue) {\n        hashValue = hashes[hashType].value;\n    }\n}\n"
    },
    "contracts/access/interfaces/IAccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../vendor/@openzeppelin/contracts@4.8.2/access/IAccessControl.sol\";\nimport \"../../utils/interfaces/ISelfMulticall.sol\";\n\ninterface IAccessControlRegistry is IAccessControl, ISelfMulticall {\n    event InitializedManager(\n        bytes32 indexed rootRole,\n        address indexed manager,\n        address sender\n    );\n\n    event InitializedRole(\n        bytes32 indexed role,\n        bytes32 indexed adminRole,\n        string description,\n        address sender\n    );\n\n    function initializeManager(address manager) external;\n\n    function initializeRoleAndGrantToSender(\n        bytes32 adminRole,\n        string calldata description\n    ) external returns (bytes32 role);\n}\n"
    },
    "contracts/access/interfaces/IAccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../utils/interfaces/ISelfMulticall.sol\";\n\ninterface IAccessControlRegistryAdminned is ISelfMulticall {\n    function accessControlRegistry() external view returns (address);\n\n    function adminRoleDescription() external view returns (string memory);\n}\n"
    },
    "contracts/access/interfaces/IAccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryAdminned.sol\";\n\ninterface IAccessControlRegistryAdminnedWithManager is\n    IAccessControlRegistryAdminned\n{\n    function manager() external view returns (address);\n\n    function adminRole() external view returns (bytes32);\n}\n"
    },
    "contracts/access/interfaces/IHashRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IOwnable.sol\";\n\ninterface IHashRegistry is IOwnable {\n    event SetSigners(bytes32 indexed hashType, address[] signers);\n\n    event SetHash(\n        bytes32 indexed hashType,\n        bytes32 hashValue,\n        uint256 hashTimestamp\n    );\n\n    event RegisteredHash(\n        bytes32 indexed hashType,\n        bytes32 hashValue,\n        uint256 hashTimestamp\n    );\n\n    function setSigners(bytes32 hashType, address[] calldata signers) external;\n\n    function setHash(bytes32 hashType, bytes32 hashValue) external;\n\n    function registerHash(\n        bytes32 hashType,\n        bytes32 hashValue,\n        uint256 hashTimestamp,\n        bytes[] calldata signatures\n    ) external;\n\n    function signatureDelegationHashType() external view returns (bytes32);\n\n    function getHashValue(\n        bytes32 hashType\n    ) external view returns (bytes32 hashValue);\n\n    function hashes(\n        bytes32 hashType\n    ) external view returns (bytes32 hashValue, uint256 hashTimestamp);\n\n    function hashTypeToSignersHash(\n        bytes32 hashType\n    ) external view returns (bytes32 signersHash);\n}\n"
    },
    "contracts/access/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/access/interfaces/IOwnableCallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnableCallForwarder {\n    function forwardCall(\n        address forwardTarget,\n        bytes calldata forwardedCalldata\n    ) external payable returns (bytes memory returnedData);\n}\n"
    },
    "contracts/access/OwnableCallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../vendor/@openzeppelin/contracts@4.8.2/access/Ownable.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.8.2/utils/Address.sol\";\nimport \"./interfaces/IOwnableCallForwarder.sol\";\n\n/// @title Contract that forwards the calls that its owner sends\n/// @notice AccessControlRegistry users that want their access control tables\n/// to be transferrable (e.g., a DAO) will use this forwarder instead of\n/// interacting with it directly. There are cases where this transferrability\n/// is not desired, e.g., if the user is an Airnode and is immutably associated\n/// with a single address, in which case the manager will interact with\n/// AccessControlRegistry directly.\ncontract OwnableCallForwarder is Ownable, IOwnableCallForwarder {\n    /// @param _owner Owner address\n    constructor(address _owner) {\n        transferOwnership(_owner);\n    }\n\n    /// @notice Forwards the calldata and the value to the target address if\n    /// the sender is the owner and returns the data\n    /// @param forwardTarget Target address that the calldata will be forwarded\n    /// to\n    /// @param forwardedCalldata Calldata to be forwarded to the target address\n    /// @return returnedData Data returned by the forwarded call\n    function forwardCall(\n        address forwardTarget,\n        bytes calldata forwardedCalldata\n    ) external payable override onlyOwner returns (bytes memory returnedData) {\n        returnedData = Address.functionCallWithValue(\n            forwardTarget,\n            forwardedCalldata,\n            msg.value\n        );\n    }\n}\n"
    },
    "contracts/access/RoleDeriver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will derive\n/// AccessControlRegistry roles\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\n/// derive roles, it should inherit this contract instead of re-implementing\n/// the logic\ncontract RoleDeriver {\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function _deriveRootRole(\n        address manager\n    ) internal pure returns (bytes32 rootRole) {\n        rootRole = keccak256(abi.encodePacked(manager));\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Human-readable description of the role\n    /// @return role Role\n    function _deriveRole(\n        bytes32 adminRole,\n        string memory description\n    ) internal pure returns (bytes32 role) {\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\n    }\n\n    /// @notice Derives the role using its admin role and description hash\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param descriptionHash Hash of the human-readable description of the\n    /// role\n    /// @return role Role\n    function _deriveRole(\n        bytes32 adminRole,\n        bytes32 descriptionHash\n    ) internal pure returns (bytes32 role) {\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\n    }\n}\n"
    },
    "contracts/api3-server-v1/aggregation/Median.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Sort.sol\";\nimport \"./QuickSelect.sol\";\n\n/// @title Contract to be inherited by contracts that will calculate the median\n/// of an array\n/// @notice The operation will be in-place, i.e., the array provided as the\n/// argument will be modified.\ncontract Median is Sort, Quickselect {\n    /// @notice Returns the median of the array\n    /// @dev Uses an unrolled sorting implementation for shorter arrays and\n    /// quickselect for longer arrays for gas cost efficiency\n    /// @param array Array whose median is to be calculated\n    /// @return Median of the array\n    function median(int256[] memory array) internal pure returns (int256) {\n        uint256 arrayLength = array.length;\n        if (arrayLength <= MAX_SORT_LENGTH) {\n            sort(array);\n            if (arrayLength % 2 == 1) {\n                return array[arrayLength / 2];\n            } else {\n                assert(arrayLength != 0);\n                unchecked {\n                    return\n                        average(\n                            array[arrayLength / 2 - 1],\n                            array[arrayLength / 2]\n                        );\n                }\n            }\n        } else {\n            if (arrayLength % 2 == 1) {\n                return array[quickselectK(array, arrayLength / 2)];\n            } else {\n                uint256 mid1;\n                uint256 mid2;\n                unchecked {\n                    (mid1, mid2) = quickselectKPlusOne(\n                        array,\n                        arrayLength / 2 - 1\n                    );\n                }\n                return average(array[mid1], array[mid2]);\n            }\n        }\n    }\n\n    /// @notice Averages two signed integers without overflowing\n    /// @param x Integer x\n    /// @param y Integer y\n    /// @return Average of integers x and y\n    function average(int256 x, int256 y) private pure returns (int256) {\n        unchecked {\n            int256 averageRoundedDownToNegativeInfinity = (x >> 1) +\n                (y >> 1) +\n                (x & y & 1);\n            // If the average rounded down to negative infinity is negative\n            // (i.e., its 256th sign bit is set), and one of (x, y) is even and\n            // the other one is odd (i.e., the 1st bit of their xor is set),\n            // add 1 to round the average down to zero instead.\n            // We will typecast the signed integer to unsigned to logical-shift\n            // int256(uint256(signedInt)) >> 255 ~= signedInt >>> 255\n            return\n                averageRoundedDownToNegativeInfinity +\n                (int256(\n                    (uint256(averageRoundedDownToNegativeInfinity) >> 255)\n                ) & (x ^ y));\n        }\n    }\n}\n"
    },
    "contracts/api3-server-v1/aggregation/QuickSelect.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will calculate the index\n/// of the k-th and optionally (k+1)-th largest elements in the array\n/// @notice Uses quickselect, which operates in-place, i.e., the array provided\n/// as the argument will be modified.\ncontract Quickselect {\n    /// @notice Returns the index of the k-th largest element in the array\n    /// @param array Array in which k-th largest element will be searched\n    /// @param k K\n    /// @return indK Index of the k-th largest element\n    function quickselectK(\n        int256[] memory array,\n        uint256 k\n    ) internal pure returns (uint256 indK) {\n        uint256 arrayLength = array.length;\n        assert(arrayLength > 0);\n        unchecked {\n            (indK, ) = quickselect(array, 0, arrayLength - 1, k, false);\n        }\n    }\n\n    /// @notice Returns the index of the k-th and (k+1)-th largest elements in\n    /// the array\n    /// @param array Array in which k-th and (k+1)-th largest elements will be\n    /// searched\n    /// @param k K\n    /// @return indK Index of the k-th largest element\n    /// @return indKPlusOne Index of the (k+1)-th largest element\n    function quickselectKPlusOne(\n        int256[] memory array,\n        uint256 k\n    ) internal pure returns (uint256 indK, uint256 indKPlusOne) {\n        uint256 arrayLength = array.length;\n        assert(arrayLength > 1);\n        unchecked {\n            (indK, indKPlusOne) = quickselect(\n                array,\n                0,\n                arrayLength - 1,\n                k,\n                true\n            );\n        }\n    }\n\n    /// @notice Returns the index of the k-th largest element in the specified\n    /// section of the (potentially unsorted) array\n    /// @param array Array in which K will be searched for\n    /// @param lo Starting index of the section of the array that K will be\n    /// searched in\n    /// @param hi Last index of the section of the array that K will be\n    /// searched in\n    /// @param k K\n    /// @param selectKPlusOne If the index of the (k+1)-th largest element is\n    /// to be returned\n    /// @return indK Index of the k-th largest element\n    /// @return indKPlusOne Index of the (k+1)-th largest element (only set if\n    /// `selectKPlusOne` is `true`)\n    function quickselect(\n        int256[] memory array,\n        uint256 lo,\n        uint256 hi,\n        uint256 k,\n        bool selectKPlusOne\n    ) private pure returns (uint256 indK, uint256 indKPlusOne) {\n        if (lo == hi) {\n            return (k, 0);\n        }\n        uint256 indPivot = partition(array, lo, hi);\n        if (k < indPivot) {\n            unchecked {\n                (indK, ) = quickselect(array, lo, indPivot - 1, k, false);\n            }\n        } else if (k > indPivot) {\n            unchecked {\n                (indK, ) = quickselect(array, indPivot + 1, hi, k, false);\n            }\n        } else {\n            indK = indPivot;\n        }\n        // Since Quickselect ends in the array being partitioned around the\n        // k-th largest element, we can continue searching towards right for\n        // the (k+1)-th largest element, which is useful in calculating the\n        // median of an array with even length\n        if (selectKPlusOne) {\n            unchecked {\n                indKPlusOne = indK + 1;\n            }\n            uint256 i;\n            unchecked {\n                i = indKPlusOne + 1;\n            }\n            uint256 arrayLength = array.length;\n            for (; i < arrayLength; ) {\n                if (array[i] < array[indKPlusOne]) {\n                    indKPlusOne = i;\n                }\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n\n    /// @notice Partitions the array into two around a pivot\n    /// @param array Array that will be partitioned\n    /// @param lo Starting index of the section of the array that will be\n    /// partitioned\n    /// @param hi Last index of the section of the array that will be\n    /// partitioned\n    /// @return pivotInd Pivot index\n    function partition(\n        int256[] memory array,\n        uint256 lo,\n        uint256 hi\n    ) private pure returns (uint256 pivotInd) {\n        if (lo == hi) {\n            return lo;\n        }\n        int256 pivot = array[lo];\n        uint256 i = lo;\n        unchecked {\n            pivotInd = hi + 1;\n        }\n        while (true) {\n            do {\n                unchecked {\n                    i++;\n                }\n            } while (i < array.length && array[i] < pivot);\n            do {\n                unchecked {\n                    pivotInd--;\n                }\n            } while (array[pivotInd] > pivot);\n            if (i >= pivotInd) {\n                (array[lo], array[pivotInd]) = (array[pivotInd], array[lo]);\n                return pivotInd;\n            }\n            (array[i], array[pivotInd]) = (array[pivotInd], array[i]);\n        }\n    }\n}\n"
    },
    "contracts/api3-server-v1/aggregation/Sort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will sort an array using\n/// an unrolled implementation\n/// @notice The operation will be in-place, i.e., the array provided as the\n/// argument will be modified.\ncontract Sort {\n    uint256 internal constant MAX_SORT_LENGTH = 9;\n\n    /// @notice Sorts the array\n    /// @param array Array to be sorted\n    function sort(int256[] memory array) internal pure {\n        uint256 arrayLength = array.length;\n        require(arrayLength <= MAX_SORT_LENGTH, \"Array too long to sort\");\n        // Do a binary search\n        if (arrayLength < 6) {\n            // Possible lengths: 1, 2, 3, 4, 5\n            if (arrayLength < 4) {\n                // Possible lengths: 1, 2, 3\n                if (arrayLength == 3) {\n                    // Length: 3\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 0, 1);\n                } else if (arrayLength == 2) {\n                    // Length: 2\n                    swapIfFirstIsLarger(array, 0, 1);\n                }\n                // Do nothing for Length: 1\n            } else {\n                // Possible lengths: 4, 5\n                if (arrayLength == 5) {\n                    // Length: 5\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 1, 2);\n                } else {\n                    // Length: 4\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 1, 2);\n                }\n            }\n        } else {\n            // Possible lengths: 6, 7, 8, 9\n            if (arrayLength < 8) {\n                // Possible lengths: 6, 7\n                if (arrayLength == 7) {\n                    // Length: 7\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 4, 6);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 2, 6);\n                    swapIfFirstIsLarger(array, 1, 5);\n                    swapIfFirstIsLarger(array, 0, 4);\n                    swapIfFirstIsLarger(array, 2, 5);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                } else {\n                    // Length: 6\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 2, 3);\n                }\n            } else {\n                // Possible lengths: 8, 9\n                if (arrayLength == 9) {\n                    // Length: 9\n                    swapIfFirstIsLarger(array, 1, 8);\n                    swapIfFirstIsLarger(array, 2, 7);\n                    swapIfFirstIsLarger(array, 3, 6);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 1, 4);\n                    swapIfFirstIsLarger(array, 5, 8);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 2, 6);\n                    swapIfFirstIsLarger(array, 7, 8);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 5, 7);\n                    swapIfFirstIsLarger(array, 4, 6);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 7, 8);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                } else {\n                    // Length: 8\n                    swapIfFirstIsLarger(array, 0, 7);\n                    swapIfFirstIsLarger(array, 1, 6);\n                    swapIfFirstIsLarger(array, 2, 5);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 4, 7);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 3, 4);\n                }\n            }\n        }\n    }\n\n    /// @notice Swaps two elements of an array if the first element is greater\n    /// than the second\n    /// @param array Array whose elements are to be swapped\n    /// @param ind1 Index of the first element\n    /// @param ind2 Index of the second element\n    function swapIfFirstIsLarger(\n        int256[] memory array,\n        uint256 ind1,\n        uint256 ind2\n    ) private pure {\n        if (array[ind1] > array[ind2]) {\n            (array[ind1], array[ind2]) = (array[ind2], array[ind1]);\n        }\n    }\n}\n"
    },
    "contracts/api3-server-v1/AirseekerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../vendor/@openzeppelin/contracts@4.9.5/access/Ownable.sol\";\nimport \"../utils/ExtendedSelfMulticall.sol\";\nimport \"./interfaces/IAirseekerRegistry.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.9.5/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/IApi3ServerV1.sol\";\n\n/// @title A contract where active data feeds and their specs are registered by\n/// the contract owner for the Airseeker that serves them to refer to\n/// @notice Airseeker is an application that pushes API provider-signed data to\n/// chain when certain conditions are met so that the data feeds served on the\n/// Api3ServerV1 contract are updated according to the respective specs. In\n/// other words, this contract is an on-chain configuration file for an\n/// Airseeker (or multiple Airseekers in a setup with redundancy).\n/// The Airseeker must know which data feeds are active (and thus need to be\n/// updated), the constituting Airnode (the oracle node that API providers\n/// operate to sign data) addresses and request template IDs, what the\n/// respective on-chain data feed values are, what the update parameters are,\n/// and the URL of the signed APIs (from which Airseeker can fetch signed data)\n/// that are hosted by the respective API providers.\n/// The contract owner is responsible with leaving the state of this contract\n/// in a way that Airseeker expects. For example, if a dAPI name is activated\n/// without registering the respective data feed, the Airseeker will not have\n/// access to the data that it needs to execute updates.\ncontract AirseekerRegistry is\n    Ownable,\n    ExtendedSelfMulticall,\n    IAirseekerRegistry\n{\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// @notice Maximum number of Beacons in a Beacon set that can be\n    /// registered\n    /// @dev Api3ServerV1 introduces the concept of a Beacon, which is a\n    /// single-source data feed. Api3ServerV1 allows Beacons to be read\n    /// individually, or arbitrary combinations of them to be aggregated\n    /// on-chain to form multiple-source data feeds, which are called Beacon\n    /// sets. This contract does not support Beacon sets that consist of more\n    /// than `MAXIMUM_BEACON_COUNT_IN_SET` Beacons to be registered.\n    uint256 public constant override MAXIMUM_BEACON_COUNT_IN_SET = 21;\n\n    /// @notice Maximum encoded update parameters length\n    uint256 public constant override MAXIMUM_UPDATE_PARAMETERS_LENGTH = 1024;\n\n    /// @notice Maximum signed API URL length\n    uint256 public constant override MAXIMUM_SIGNED_API_URL_LENGTH = 256;\n\n    /// @notice Api3ServerV1 contract address\n    address public immutable override api3ServerV1;\n\n    /// @notice Airnode address to signed API URL\n    /// @dev An Airseeker can be configured to refer to additional signed APIs\n    /// than the ones whose URLs are stored in this contract for redundancy\n    mapping(address => string) public override airnodeToSignedApiUrl;\n\n    /// @notice Data feed ID to encoded details\n    mapping(bytes32 => bytes) public override dataFeedIdToDetails;\n\n    // Api3ServerV1 uses Beacon IDs (see the `deriveBeaconId()` implementation)\n    // and Beacon set IDs (see the `deriveBeaconSetId()` implementation) to\n    // address data feeds. We use data feed ID as a general term to refer to a\n    // Beacon ID/Beacon set ID.\n    // A data feed ID is immutable (i.e., it always points to the same Beacon\n    // or Beacon set). Api3ServerV1 allows a dAPI name to be pointed to a data\n    // feed ID by privileged accounts to implement a mutable data feed\n    // addressing scheme.\n    // If the data feed ID or dAPI name should be used to read a data feed\n    // depends on the use case. To support both schemes, AirseekerRegistry\n    // allows data feeds specs to be defined with either the data feed ID or\n    // the dAPI name.\n    EnumerableSet.Bytes32Set private activeDataFeedIds;\n\n    EnumerableSet.Bytes32Set private activeDapiNames;\n\n    // Considering that the update parameters are typically reused between data\n    // feeds, a hash map is used to avoid storing the same update parameters\n    // redundantly\n    mapping(bytes32 => bytes32) private dataFeedIdToUpdateParametersHash;\n\n    mapping(bytes32 => bytes32) private dapiNameToUpdateParametersHash;\n\n    mapping(bytes32 => bytes) private updateParametersHashToValue;\n\n    // Length of abi.encode(address, bytes32)\n    uint256 private constant DATA_FEED_DETAILS_LENGTH_FOR_SINGLE_BEACON =\n        32 + 32;\n\n    // Length of abi.encode(address[2], bytes32[2])\n    uint256\n        private constant DATA_FEED_DETAILS_LENGTH_FOR_BEACON_SET_WITH_TWO_BEACONS =\n        32 + 32 + (32 + 2 * 32) + (32 + 2 * 32);\n\n    // Length of\n    // abi.encode(address[MAXIMUM_BEACON_COUNT_IN_SET], bytes32[MAXIMUM_BEACON_COUNT_IN_SET])\n    uint256 private constant MAXIMUM_DATA_FEED_DETAILS_LENGTH =\n        32 +\n            32 +\n            (32 + MAXIMUM_BEACON_COUNT_IN_SET * 32) +\n            (32 + MAXIMUM_BEACON_COUNT_IN_SET * 32);\n\n    /// @dev Reverts if the data feed ID is zero\n    /// @param dataFeedId Data feed ID\n    modifier onlyNonZeroDataFeedId(bytes32 dataFeedId) {\n        require(dataFeedId != bytes32(0), \"Data feed ID zero\");\n        _;\n    }\n\n    /// @dev Reverts if the dAPI name is zero\n    /// @param dapiName dAPI name\n    modifier onlyNonZeroDapiName(bytes32 dapiName) {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        _;\n    }\n\n    /// @dev Reverts if the update parameters are too long\n    /// @param updateParameters Update parameters\n    modifier onlyValidUpdateParameters(bytes calldata updateParameters) {\n        require(\n            updateParameters.length <= MAXIMUM_UPDATE_PARAMETERS_LENGTH,\n            \"Update parameters too long\"\n        );\n        _;\n    }\n\n    /// @param owner_ Owner address\n    /// @param api3ServerV1_ Api3ServerV1 contract address\n    constructor(address owner_, address api3ServerV1_) {\n        require(owner_ != address(0), \"Owner address zero\");\n        require(api3ServerV1_ != address(0), \"Api3ServerV1 address zero\");\n        _transferOwnership(owner_);\n        api3ServerV1 = api3ServerV1_;\n    }\n\n    /// @notice Returns the owner address\n    /// @return Owner address\n    function owner() public view override(Ownable, IOwnable) returns (address) {\n        return super.owner();\n    }\n\n    /// @notice Overriden to be disabled\n    function renounceOwnership() public pure override(Ownable, IOwnable) {\n        revert(\"Ownership cannot be renounced\");\n    }\n\n    /// @notice Overriden to be disabled\n    function transferOwnership(\n        address\n    ) public pure override(Ownable, IOwnable) {\n        revert(\"Ownership cannot be transferred\");\n    }\n\n    /// @notice Called by the owner to set the data feed ID to be activated\n    /// @param dataFeedId Data feed ID\n    function setDataFeedIdToBeActivated(\n        bytes32 dataFeedId\n    ) external override onlyOwner onlyNonZeroDataFeedId(dataFeedId) {\n        if (activeDataFeedIds.add(dataFeedId)) {\n            emit ActivatedDataFeedId(dataFeedId);\n        }\n    }\n\n    /// @notice Called by the owner to set the dAPI name to be activated\n    /// @param dapiName dAPI name\n    function setDapiNameToBeActivated(\n        bytes32 dapiName\n    ) external override onlyOwner onlyNonZeroDapiName(dapiName) {\n        if (activeDapiNames.add(dapiName)) {\n            emit ActivatedDapiName(dapiName);\n        }\n    }\n\n    /// @notice Called by the owner to set the data feed ID to be deactivated\n    /// @param dataFeedId Data feed ID\n    function setDataFeedIdToBeDeactivated(\n        bytes32 dataFeedId\n    ) external override onlyOwner onlyNonZeroDataFeedId(dataFeedId) {\n        if (activeDataFeedIds.remove(dataFeedId)) {\n            emit DeactivatedDataFeedId(dataFeedId);\n        }\n    }\n\n    /// @notice Called by the owner to set the dAPI name to be deactivated\n    /// @param dapiName dAPI name\n    function setDapiNameToBeDeactivated(\n        bytes32 dapiName\n    ) external override onlyOwner onlyNonZeroDapiName(dapiName) {\n        if (activeDapiNames.remove(dapiName)) {\n            emit DeactivatedDapiName(dapiName);\n        }\n    }\n\n    /// @notice Called by the owner to set the data feed ID update parameters.\n    /// The update parameters must be encoded in a format that Airseeker\n    /// expects.\n    /// @param dataFeedId Data feed ID\n    /// @param updateParameters Update parameters\n    function setDataFeedIdUpdateParameters(\n        bytes32 dataFeedId,\n        bytes calldata updateParameters\n    )\n        external\n        override\n        onlyOwner\n        onlyNonZeroDataFeedId(dataFeedId)\n        onlyValidUpdateParameters(updateParameters)\n    {\n        bytes32 updateParametersHash = keccak256(updateParameters);\n        if (\n            dataFeedIdToUpdateParametersHash[dataFeedId] != updateParametersHash\n        ) {\n            dataFeedIdToUpdateParametersHash[dataFeedId] = updateParametersHash;\n            if (\n                updateParametersHashToValue[updateParametersHash].length !=\n                updateParameters.length\n            ) {\n                updateParametersHashToValue[\n                    updateParametersHash\n                ] = updateParameters;\n            }\n            emit UpdatedDataFeedIdUpdateParameters(\n                dataFeedId,\n                updateParameters\n            );\n        }\n    }\n\n    /// @notice Called by the owner to set the dAPI name update parameters.\n    /// The update parameters must be encoded in a format that Airseeker\n    /// expects.\n    /// @param dapiName dAPI name\n    /// @param updateParameters Update parameters\n    function setDapiNameUpdateParameters(\n        bytes32 dapiName,\n        bytes calldata updateParameters\n    )\n        external\n        override\n        onlyOwner\n        onlyNonZeroDapiName(dapiName)\n        onlyValidUpdateParameters(updateParameters)\n    {\n        bytes32 updateParametersHash = keccak256(updateParameters);\n        if (dapiNameToUpdateParametersHash[dapiName] != updateParametersHash) {\n            dapiNameToUpdateParametersHash[dapiName] = updateParametersHash;\n            if (\n                updateParametersHashToValue[updateParametersHash].length !=\n                updateParameters.length\n            ) {\n                updateParametersHashToValue[\n                    updateParametersHash\n                ] = updateParameters;\n            }\n            emit UpdatedDapiNameUpdateParameters(dapiName, updateParameters);\n        }\n    }\n\n    /// @notice Called by the owner to set the signed API URL for the Airnode.\n    /// The signed API must implement the specific interface that Airseeker\n    /// expects.\n    /// @param airnode Airnode address\n    /// @param signedApiUrl Signed API URL\n    function setSignedApiUrl(\n        address airnode,\n        string calldata signedApiUrl\n    ) external override onlyOwner {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(\n            abi.encodePacked(signedApiUrl).length <=\n                MAXIMUM_SIGNED_API_URL_LENGTH,\n            \"Signed API URL too long\"\n        );\n        if (\n            keccak256(abi.encodePacked(airnodeToSignedApiUrl[airnode])) !=\n            keccak256(abi.encodePacked(signedApiUrl))\n        ) {\n            airnodeToSignedApiUrl[airnode] = signedApiUrl;\n            emit UpdatedSignedApiUrl(airnode, signedApiUrl);\n        }\n    }\n\n    /// @notice Registers the data feed. In the case that the data feed is a\n    /// Beacon, the details should be the ABI-encoded Airnode address and\n    /// template ID. In the case that the data feed is a Beacon set, the\n    /// details should be the ABI-encoded Airnode addresses array and template\n    /// IDs array.\n    /// @param dataFeedDetails Data feed details\n    /// @return dataFeedId Data feed ID\n    function registerDataFeed(\n        bytes calldata dataFeedDetails\n    ) external override returns (bytes32 dataFeedId) {\n        uint256 dataFeedDetailsLength = dataFeedDetails.length;\n        if (\n            dataFeedDetailsLength == DATA_FEED_DETAILS_LENGTH_FOR_SINGLE_BEACON\n        ) {\n            // dataFeedId maps to a Beacon\n            (address airnode, bytes32 templateId) = abi.decode(\n                dataFeedDetails,\n                (address, bytes32)\n            );\n            require(airnode != address(0), \"Airnode address zero\");\n            dataFeedId = deriveBeaconId(airnode, templateId);\n        } else if (\n            dataFeedDetailsLength >=\n            DATA_FEED_DETAILS_LENGTH_FOR_BEACON_SET_WITH_TWO_BEACONS\n        ) {\n            require(\n                dataFeedDetailsLength <= MAXIMUM_DATA_FEED_DETAILS_LENGTH,\n                \"Data feed details too long\"\n            );\n            (address[] memory airnodes, bytes32[] memory templateIds) = abi\n                .decode(dataFeedDetails, (address[], bytes32[]));\n            require(\n                abi.encode(airnodes, templateIds).length ==\n                    dataFeedDetailsLength,\n                \"Data feed details trail\"\n            );\n            uint256 beaconCount = airnodes.length;\n            require(\n                beaconCount == templateIds.length,\n                \"Parameter length mismatch\"\n            );\n            bytes32[] memory beaconIds = new bytes32[](beaconCount);\n            for (uint256 ind = 0; ind < beaconCount; ind++) {\n                require(airnodes[ind] != address(0), \"Airnode address zero\");\n                beaconIds[ind] = deriveBeaconId(\n                    airnodes[ind],\n                    templateIds[ind]\n                );\n            }\n            dataFeedId = deriveBeaconSetId(beaconIds);\n        } else {\n            revert(\"Data feed details too short\");\n        }\n        if (dataFeedIdToDetails[dataFeedId].length != dataFeedDetailsLength) {\n            dataFeedIdToDetails[dataFeedId] = dataFeedDetails;\n            emit RegisteredDataFeed(dataFeedId, dataFeedDetails);\n        }\n    }\n\n    /// @notice In an imaginary array consisting of the the active data feed\n    /// IDs and active dAPI names, picks the index-th identifier, and returns\n    /// all data about the respective data feed that is available. Whenever\n    /// data is not available (including the case where index does not\n    /// correspond to an active data feed), returns empty values.\n    /// @dev Airseeker uses this function to get all the data it needs about an\n    /// active data feed with a single RPC call\n    /// @param index Index\n    /// @return dataFeedId Data feed ID\n    /// @return dapiName dAPI name (`bytes32(0)` if the active data feed is\n    /// identified by a data feed ID)\n    /// @return dataFeedDetails Data feed details\n    /// @return dataFeedValue Data feed value read from Api3ServerV1\n    /// @return dataFeedTimestamp Data feed timestamp read from Api3ServerV1\n    /// @return beaconValues Beacon values read from Api3ServerV1\n    /// @return beaconTimestamps Beacon timestamps read from Api3ServerV1\n    /// @return updateParameters Update parameters\n    /// @return signedApiUrls Signed API URLs of the Beacon Airnodes\n    function activeDataFeed(\n        uint256 index\n    )\n        external\n        view\n        override\n        returns (\n            bytes32 dataFeedId,\n            bytes32 dapiName,\n            bytes memory dataFeedDetails,\n            int224 dataFeedValue,\n            uint32 dataFeedTimestamp,\n            int224[] memory beaconValues,\n            uint32[] memory beaconTimestamps,\n            bytes memory updateParameters,\n            string[] memory signedApiUrls\n        )\n    {\n        uint256 activeDataFeedIdsLength = activeDataFeedIdCount();\n        if (index < activeDataFeedIdsLength) {\n            dataFeedId = activeDataFeedIds.at(index);\n            updateParameters = dataFeedIdToUpdateParameters(dataFeedId);\n        } else if (index < activeDataFeedIdsLength + activeDapiNames.length()) {\n            dapiName = activeDapiNames.at(index - activeDataFeedIdsLength);\n            dataFeedId = IApi3ServerV1(api3ServerV1).dapiNameHashToDataFeedId(\n                keccak256(abi.encodePacked(dapiName))\n            );\n            updateParameters = dapiNameToUpdateParameters(dapiName);\n        }\n        if (dataFeedId != bytes32(0)) {\n            dataFeedDetails = dataFeedIdToDetails[dataFeedId];\n            (dataFeedValue, dataFeedTimestamp) = IApi3ServerV1(api3ServerV1)\n                .dataFeeds(dataFeedId);\n        }\n        if (dataFeedDetails.length != 0) {\n            if (\n                dataFeedDetails.length ==\n                DATA_FEED_DETAILS_LENGTH_FOR_SINGLE_BEACON\n            ) {\n                beaconValues = new int224[](1);\n                beaconTimestamps = new uint32[](1);\n                signedApiUrls = new string[](1);\n                (address airnode, bytes32 templateId) = abi.decode(\n                    dataFeedDetails,\n                    (address, bytes32)\n                );\n                (beaconValues[0], beaconTimestamps[0]) = IApi3ServerV1(\n                    api3ServerV1\n                ).dataFeeds(deriveBeaconId(airnode, templateId));\n                signedApiUrls[0] = airnodeToSignedApiUrl[airnode];\n            } else {\n                (address[] memory airnodes, bytes32[] memory templateIds) = abi\n                    .decode(dataFeedDetails, (address[], bytes32[]));\n                uint256 beaconCount = airnodes.length;\n                beaconValues = new int224[](beaconCount);\n                beaconTimestamps = new uint32[](beaconCount);\n                signedApiUrls = new string[](beaconCount);\n                for (uint256 ind = 0; ind < beaconCount; ind++) {\n                    (beaconValues[ind], beaconTimestamps[ind]) = IApi3ServerV1(\n                        api3ServerV1\n                    ).dataFeeds(\n                            deriveBeaconId(airnodes[ind], templateIds[ind])\n                        );\n                    signedApiUrls[ind] = airnodeToSignedApiUrl[airnodes[ind]];\n                }\n            }\n        }\n    }\n\n    /// @notice Returns the number of active data feeds identified by a data\n    /// feed ID or dAPI name\n    /// @return Active data feed count\n    function activeDataFeedCount() external view override returns (uint256) {\n        return activeDataFeedIdCount() + activeDapiNameCount();\n    }\n\n    /// @notice Returns the number of active data feeds identified by a data\n    /// feed ID\n    /// @return Active data feed ID count\n    function activeDataFeedIdCount() public view override returns (uint256) {\n        return activeDataFeedIds.length();\n    }\n\n    /// @notice Returns the number of active data feeds identified by a dAPI\n    /// name\n    /// @return Active dAPI name count\n    function activeDapiNameCount() public view override returns (uint256) {\n        return activeDapiNames.length();\n    }\n\n    /// @notice Data feed ID to update parameters\n    /// @param dataFeedId Data feed ID\n    /// @return updateParameters Update parameters\n    function dataFeedIdToUpdateParameters(\n        bytes32 dataFeedId\n    ) public view override returns (bytes memory updateParameters) {\n        updateParameters = updateParametersHashToValue[\n            dataFeedIdToUpdateParametersHash[dataFeedId]\n        ];\n    }\n\n    /// @notice dAPI name to update parameters\n    /// @param dapiName dAPI name\n    /// @return updateParameters Update parameters\n    function dapiNameToUpdateParameters(\n        bytes32 dapiName\n    ) public view override returns (bytes memory updateParameters) {\n        updateParameters = updateParametersHashToValue[\n            dapiNameToUpdateParametersHash[dapiName]\n        ];\n    }\n\n    /// @notice Returns if the data feed with ID is registered\n    /// @param dataFeedId Data feed ID\n    /// @return If the data feed with ID is registered\n    function dataFeedIsRegistered(\n        bytes32 dataFeedId\n    ) external view override returns (bool) {\n        return dataFeedIdToDetails[dataFeedId].length != 0;\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(\n        address airnode,\n        bytes32 templateId\n    ) private pure returns (bytes32 beaconId) {\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n\n    /// @notice Derives the Beacon set ID from the Beacon IDs\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function deriveBeaconSetId(\n        bytes32[] memory beaconIds\n    ) private pure returns (bytes32 beaconSetId) {\n        beaconSetId = keccak256(abi.encode(beaconIds));\n    }\n}\n"
    },
    "contracts/api3-server-v1/Api3Market.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../access/HashRegistry.sol\";\nimport \"../utils/ExtendedSelfMulticall.sol\";\nimport \"./interfaces/IApi3Market.sol\";\nimport \"./AirseekerRegistry.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.9.5/utils/math/SafeCast.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.9.5/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/IApi3ServerV1.sol\";\nimport \"./proxies/interfaces/IProxyFactory.sol\";\n\n/// @title The contract that API3 users interact with using the API3 Market\n/// frontend to purchase data feed subscriptions\n/// @notice API3 aims to streamline and protocolize its integration processes\n/// through the API3 Market (https://market.api3.org), which is a data feed\n/// subscription marketplace. The Api3Market contract is the on-chain portion\n/// of this system.\n/// Api3Market enables API3 to predetermine the decisions related to its data\n/// feed services (such as the curation of data feed sources or subscription\n/// prices) and publish them on-chain. This streamlines the intergation flow,\n/// as it allows the users to initiate subscriptions immediately, without\n/// requiring any two-way communication with API3. Furthermore, this removes\n/// the need for API3 to have agents operating in the meatspace gathering order\n/// details, quoting prices and reviewing payments, and allows all such\n/// operations to be cryptographically secured with a multi-party scheme in an\n/// end-to-end manner.\n/// @dev The user is strongly recommended to use the API3 Market frontend while\n/// interacting with this contract, mostly because doing so successfully\n/// requires some amount of knowledge of other API3 contracts. Specifically,\n/// Api3Market requires the data feed for which the subscription is being\n/// purchased to be \"readied\", the correct Merkle proofs to be provided, and\n/// enough payment to be made. The API3 Market frontend will fetch the\n/// appropriate Merkle proofs, create a multicall transaction that will ready\n/// the data feed before making the call to buy the subscription, and compute\n/// the amount to be sent that will barely allow the subscription to be\n/// purchased. For most users, building such a transaction themselves would be\n/// too impractical.\ncontract Api3Market is HashRegistry, ExtendedSelfMulticall, IApi3Market {\n    enum UpdateParametersComparisonResult {\n        EqualToQueued,\n        BetterThanQueued,\n        WorseThanQueued\n    }\n\n    // The update parameters for each subscription is kept in a hash map rather\n    // than in full form as an optimization. Refer to AirseekerRegistry for a\n    // similar scheme.\n    // The subscription queues are kept as linked lists, for which each\n    // subscription has a next subscription ID field.\n    struct Subscription {\n        bytes32 updateParametersHash;\n        uint32 endTimestamp;\n        uint224 dailyPrice;\n        bytes32 nextSubscriptionId;\n    }\n\n    /// @notice Maximum subscription queue length for a dAPI\n    /// @dev Some functionality in this contract requires to iterate through\n    /// the entire subscription queue for a dAPI, and the queue length is\n    /// limited to prevent this process from being bloated. Considering that\n    /// each item in the subscription queue has unique update parameters, the\n    /// length of the subscription queue is also limited by the number of\n    /// unique update parameters offered in the dAPI pricing Merkle tree. For\n    /// reference, at the time this contract is implemented, the API3 Market\n    /// offers 4 update parameter options, and this number is not expected to\n    /// be increased (i.e., we do not expect this queue length limit to be hit\n    /// in practice).\n    uint256 public constant override MAXIMUM_SUBSCRIPTION_QUEUE_LENGTH = 5;\n\n    /// @notice dAPI management Merkle root hash type\n    /// @dev \"Hash type\" is what HashRegistry uses to address hashes used for\n    /// different purposes\n    bytes32 public constant override DAPI_MANAGEMENT_MERKLE_ROOT_HASH_TYPE =\n        keccak256(abi.encodePacked(\"dAPI management Merkle root\"));\n\n    /// @notice dAPI pricing Merkle root hash type\n    bytes32 public constant override DAPI_PRICING_MERKLE_ROOT_HASH_TYPE =\n        keccak256(abi.encodePacked(\"dAPI pricing Merkle root\"));\n\n    /// @notice Signed API URL Merkle root hash type\n    bytes32 public constant override SIGNED_API_URL_MERKLE_ROOT_HASH_TYPE =\n        keccak256(abi.encodePacked(\"Signed API URL Merkle root\"));\n\n    /// @notice Maximum dAPI update age. This contract cannot be used to set a\n    /// dAPI name to a data feed that has not been updated in the last\n    /// `MAXIMUM_DAPI_UPDATE_AGE`.\n    uint256 public constant override MAXIMUM_DAPI_UPDATE_AGE = 1 days;\n\n    /// @notice Api3ServerV1 contract address\n    address public immutable override api3ServerV1;\n\n    /// @notice ProxyFactory contract address\n    address public immutable override proxyFactory;\n\n    /// @notice AirseekerRegistry contract address\n    address public immutable override airseekerRegistry;\n\n    /// @notice Subscriptions indexed by their IDs\n    mapping(bytes32 => Subscription) public override subscriptions;\n\n    /// @notice dAPI name to current subscription ID, which denotes the start\n    /// of the subscription queue for the dAPI\n    mapping(bytes32 => bytes32) public override dapiNameToCurrentSubscriptionId;\n\n    // Update parameters hash map\n    mapping(bytes32 => bytes) private updateParametersHashToValue;\n\n    // Length of abi.encode(address, bytes32)\n    uint256 private constant DATA_FEED_DETAILS_LENGTH_FOR_SINGLE_BEACON =\n        32 + 32;\n\n    // Length of abi.encode(uint256, int224, uint256)\n    uint256 private constant UPDATE_PARAMETERS_LENGTH = 32 + 32 + 32;\n\n    /// @dev Api3Market deploys its own AirseekerRegistry deterministically.\n    /// This implies that Api3Market-specific Airseekers should be operated by\n    /// pointing at this contract.\n    /// @param owner_ Owner address\n    /// @param proxyFactory_ ProxyFactory contract address\n    constructor(address owner_, address proxyFactory_) HashRegistry(owner_) {\n        proxyFactory = proxyFactory_;\n        address api3ServerV1_ = IProxyFactory(proxyFactory_).api3ServerV1();\n        api3ServerV1 = api3ServerV1_;\n        airseekerRegistry = address(\n            new AirseekerRegistry{salt: bytes32(0)}(\n                address(this),\n                api3ServerV1_\n            )\n        );\n    }\n\n    /// @notice Returns the owner address\n    /// @return Owner address\n    function owner()\n        public\n        view\n        override(HashRegistry, IOwnable)\n        returns (address)\n    {\n        return super.owner();\n    }\n\n    /// @notice Overriden to be disabled\n    function renounceOwnership() public pure override(HashRegistry, IOwnable) {\n        revert(\"Ownership cannot be renounced\");\n    }\n\n    /// @notice Overriden to be disabled\n    function transferOwnership(\n        address\n    ) public pure override(HashRegistry, IOwnable) {\n        revert(\"Ownership cannot be transferred\");\n    }\n\n    /// @notice Buys subscription and updates the current subscription ID if\n    /// necessary. The user is recommended to interact with this contract only\n    /// over the API3 Market frontend due to its complexity.\n    /// @dev The data feed that the dAPI name will be set to after this\n    /// function is called must be readied (see `validateDataFeedReadiness()`)\n    /// before calling this function.\n    /// Enough funds must be sent to put the sponsor wallet balance over its\n    /// expected amount after the subscription is bought. Since sponsor wallets\n    /// send data feed update transactions, it is not possible to estimate what\n    /// their balance will be at the time sent transactions are confirmed. To\n    /// avoid transactions being reverted as a result of this, consider sending\n    /// some extra.\n    /// @param dapiName dAPI name\n    /// @param dataFeedId Data feed ID\n    /// @param sponsorWallet Sponsor wallet address\n    /// @param dapiManagementMerkleData ABI-encoded dAPI management Merkle root\n    /// and proof\n    /// @param updateParameters Update parameters\n    /// @param duration Subscription duration\n    /// @param price Subscription price\n    /// @param dapiPricingMerkleData ABI-encoded dAPI pricing Merkle root and\n    /// proof\n    /// @return subscriptionId Subscription ID\n    function buySubscription(\n        bytes32 dapiName,\n        bytes32 dataFeedId,\n        address payable sponsorWallet,\n        bytes calldata dapiManagementMerkleData,\n        bytes calldata updateParameters,\n        uint256 duration,\n        uint256 price,\n        bytes calldata dapiPricingMerkleData\n    ) external payable override returns (bytes32 subscriptionId) {\n        require(dataFeedId != bytes32(0), \"Data feed ID zero\");\n        require(sponsorWallet != address(0), \"Sponsor wallet address zero\");\n        verifyDapiManagementMerkleProof(\n            dapiName,\n            dataFeedId,\n            sponsorWallet,\n            dapiManagementMerkleData\n        );\n        verifyDapiPricingMerkleProof(\n            dapiName,\n            updateParameters,\n            duration,\n            price,\n            dapiPricingMerkleData\n        );\n        subscriptionId = addSubscriptionToQueue(\n            dapiName,\n            dataFeedId,\n            updateParameters,\n            duration,\n            price\n        );\n        require(\n            sponsorWallet.balance + msg.value >=\n                computeExpectedSponsorWalletBalance(dapiName),\n            \"Insufficient payment\"\n        );\n        emit BoughtSubscription(\n            dapiName,\n            subscriptionId,\n            dataFeedId,\n            sponsorWallet,\n            updateParameters,\n            duration,\n            price,\n            msg.value\n        );\n        if (msg.value > 0) {\n            (bool success, ) = sponsorWallet.call{value: msg.value}(\"\");\n            require(success, \"Transfer unsuccessful\");\n        }\n    }\n\n    /// @notice If the current subscription has ended, updates it with the one\n    /// that will end next\n    /// @dev The fact that there is a current subscription that has ended would\n    /// mean that API3 is providing a service that was not paid for. Therefore,\n    /// API3 should poll this function for all active dAPI names and call it\n    /// whenever it is not going to revert to downgrade the specs.\n    /// @param dapiName dAPI name\n    function updateCurrentSubscriptionId(bytes32 dapiName) public override {\n        bytes32 currentSubscriptionId = dapiNameToCurrentSubscriptionId[\n            dapiName\n        ];\n        require(\n            currentSubscriptionId != bytes32(0),\n            \"Subscription queue empty\"\n        );\n        require(\n            subscriptions[currentSubscriptionId].endTimestamp <=\n                block.timestamp,\n            \"Current subscription not ended\"\n        );\n        updateEndedCurrentSubscriptionId(dapiName, currentSubscriptionId);\n    }\n\n    /// @notice Updates the dAPI name to match the respective Merkle leaf\n    /// @dev Buying a dAPI subscription always updates the dAPI name if\n    /// necessary. However, API3 may also publish new Merkle roots between\n    /// subscription purchases, in which case API3 should call this function to\n    /// bring the chain state up to date. Therefore, API3 should poll this\n    /// function for all active dAPI names and call it whenever it will not\n    /// revert.\n    /// Similar to `buySubscription()`, this function requires the data feed\n    /// that the dAPI will be pointed to to be readied.\n    /// This function is allowed to be called even when the respective dAPI is\n    /// not active, which means that a dAPI name being set does not imply that\n    /// the respective data feed is in service. Users should only use dAPIs for\n    /// which there is an active subscription with the update parameters that\n    /// satisfy their needs.\n    /// @param dapiName dAPI name\n    /// @param dataFeedId Data feed ID\n    /// @param sponsorWallet Sponsor wallet address\n    /// @param dapiManagementMerkleData ABI-encoded dAPI management Merkle root\n    /// and proof\n    function updateDapiName(\n        bytes32 dapiName,\n        bytes32 dataFeedId,\n        address sponsorWallet,\n        bytes calldata dapiManagementMerkleData\n    ) external override {\n        if (dataFeedId != bytes32(0)) {\n            require(sponsorWallet != address(0), \"Sponsor wallet address zero\");\n        } else {\n            require(\n                sponsorWallet == address(0),\n                \"Sponsor wallet address not zero\"\n            );\n        }\n        verifyDapiManagementMerkleProof(\n            dapiName,\n            dataFeedId,\n            sponsorWallet,\n            dapiManagementMerkleData\n        );\n        bytes32 currentDataFeedId = IApi3ServerV1(api3ServerV1)\n            .dapiNameHashToDataFeedId(keccak256(abi.encodePacked(dapiName)));\n        require(currentDataFeedId != dataFeedId, \"Does not update dAPI name\");\n        if (dataFeedId != bytes32(0)) {\n            validateDataFeedReadiness(dataFeedId);\n        }\n        IApi3ServerV1(api3ServerV1).setDapiName(dapiName, dataFeedId);\n    }\n\n    /// @notice Updates the signed API URL of the Airnode to match the\n    /// respective Merkle leaf\n    /// @dev Unlike the dAPI management and pricing Merkle leaves, the signed\n    /// API URL Merkle leaves are not registered by the users as a part of\n    /// subscription purchase transactions. API3 should poll this function for\n    /// all Airnodes that are used in active dAPIs and call it whenever it will\n    /// not revert.\n    /// @param airnode Airnode address\n    /// @param signedApiUrl Signed API URL\n    /// @param signedApiUrlMerkleData ABI-encoded signed API URL Merkle root\n    /// and proof\n    function updateSignedApiUrl(\n        address airnode,\n        string calldata signedApiUrl,\n        bytes calldata signedApiUrlMerkleData\n    ) external override {\n        verifySignedApiUrlMerkleProof(\n            airnode,\n            signedApiUrl,\n            signedApiUrlMerkleData\n        );\n        require(\n            keccak256(abi.encodePacked(signedApiUrl)) !=\n                keccak256(\n                    abi.encodePacked(\n                        AirseekerRegistry(airseekerRegistry)\n                            .airnodeToSignedApiUrl(airnode)\n                    )\n                ),\n            \"Does not update signed API URL\"\n        );\n        AirseekerRegistry(airseekerRegistry).setSignedApiUrl(\n            airnode,\n            signedApiUrl\n        );\n    }\n\n    /// @notice Calls Api3ServerV1 to update the Beacon using data signed by\n    /// the Airnode\n    /// @dev The user is intended to make a multicall transaction through the\n    /// API3 Market frontend to satisfy the required conditions to be able to\n    /// buy a subscription and buy the subscription in a single transaction.\n    /// The functions to which external calls must be made to to satisfy said\n    /// conditions (such as this one) are added to this contract so that they\n    /// can be multi-called by the user.\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param timestamp Signature timestamp\n    /// @param data Update data (an `int256` encoded in contract ABI)\n    /// @param signature Template ID, timestamp and the update data signed by\n    /// the Airnode\n    /// @return beaconId Updated Beacon ID\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 templateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override returns (bytes32 beaconId) {\n        return\n            IApi3ServerV1(api3ServerV1).updateBeaconWithSignedData(\n                airnode,\n                templateId,\n                timestamp,\n                data,\n                signature\n            );\n    }\n\n    /// @notice Calls Api3ServerV1 to update the Beacon set using the current\n    /// values of its Beacons\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Updated Beacon set ID\n    function updateBeaconSetWithBeacons(\n        bytes32[] calldata beaconIds\n    ) external override returns (bytes32 beaconSetId) {\n        return\n            IApi3ServerV1(api3ServerV1).updateBeaconSetWithBeacons(beaconIds);\n    }\n\n    /// @notice Calls ProxyFactory to deterministically deploy the dAPI proxy\n    /// @dev It is recommended for the users to read data feeds through proxies\n    /// deployed by ProxyFactory, rather than calling Api3ServerV1 directly.\n    /// Even though proxy deployment is not a condition for purchasing\n    /// subscriptions, the interface is implemented here to allow the user to\n    /// purchase a dAPI subscription and deploy the respective proxy in the\n    /// same transaction with a multicall.\n    /// @param dapiName dAPI name\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function deployDapiProxy(\n        bytes32 dapiName,\n        bytes calldata metadata\n    ) external override returns (address proxyAddress) {\n        proxyAddress = IProxyFactory(proxyFactory).deployDapiProxy(\n            dapiName,\n            metadata\n        );\n    }\n\n    /// @notice Calls ProxyFactory to deterministically deploy the dAPI proxy\n    /// with OEV support\n    /// @param dapiName dAPI name\n    /// @param oevBeneficiary OEV beneficiary\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function deployDapiProxyWithOev(\n        bytes32 dapiName,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external override returns (address proxyAddress) {\n        proxyAddress = IProxyFactory(proxyFactory).deployDapiProxyWithOev(\n            dapiName,\n            oevBeneficiary,\n            metadata\n        );\n    }\n\n    /// @notice Calls AirseekerRegistry to register the data feed\n    /// @param dataFeedDetails Data feed details\n    /// @return dataFeedId Data feed ID\n    function registerDataFeed(\n        bytes calldata dataFeedDetails\n    ) external override returns (bytes32 dataFeedId) {\n        dataFeedId = AirseekerRegistry(airseekerRegistry).registerDataFeed(\n            dataFeedDetails\n        );\n    }\n\n    /// @notice Computes the expected sponsor wallet balance based on the\n    /// current subscription queue\n    /// @dev API3 estimates the transaction fee cost of subscriptions, and\n    /// prices them accordingly. The subscription fees paid for a dAPI are sent\n    /// to the respective sponsor wallet, which will send the update\n    /// transactions. In the case that a subscription is overpriced, the extra\n    /// funds are automatically rolled over as a discount to the next\n    /// subscription bought for the same dAPI. In the case that a subscription\n    /// is underpriced, there is a risk of the sponsor wallet running out of\n    /// funds, resulting in the subscription specs to not be met. To avoid\n    /// this, API3 should poll this function for all active dAPI names, check\n    /// the respective sponsor wallet balances, and top up the sponsor wallets\n    /// as necessary. The conditions that result in the underpricing will most\n    /// likely require an updated dAPI pricing Merkle root to be published.\n    /// @param dapiName dAPI name\n    /// @return expectedSponsorWalletBalance Expected sponsor wallet balance\n    function computeExpectedSponsorWalletBalance(\n        bytes32 dapiName\n    ) public view override returns (uint256 expectedSponsorWalletBalance) {\n        uint32 startTimestamp = SafeCast.toUint32(block.timestamp);\n        Subscription storage queuedSubscription;\n        for (\n            bytes32 queuedSubscriptionId = dapiNameToCurrentSubscriptionId[\n                dapiName\n            ];\n            queuedSubscriptionId != bytes32(0);\n            queuedSubscriptionId = queuedSubscription.nextSubscriptionId\n        ) {\n            queuedSubscription = subscriptions[queuedSubscriptionId];\n            uint32 endTimestamp = queuedSubscription.endTimestamp;\n            if (endTimestamp > block.timestamp) {\n                expectedSponsorWalletBalance +=\n                    ((endTimestamp - startTimestamp) *\n                        queuedSubscription.dailyPrice) /\n                    1 days;\n                startTimestamp = endTimestamp;\n            }\n        }\n    }\n\n    /// @notice Computes the expected sponsor wallet balance after the\n    /// respective subscription is added to the queue\n    /// @dev This function is intended to be used by the API3 Market frontend\n    /// to calculate how much the user should pay to purchase a specific\n    /// subscription. As mentioned in the `buySubscription()` docstring, the\n    /// user should aim for the sponsor wallet balance to be slightly more than\n    /// the required amount in case it sends a transaction in the meantime,\n    /// whose gas cost may decrease the sponsor wallet balance unexpectedly.\n    /// Unit prices of the queued subscriptions are recorded on a daily basis\n    /// and the expected balance is computed from these, which introduces a\n    /// rounding error in the order of Weis. This also applies in practice (in\n    /// that one can buy a subscription whose price is 1 ETH at 0.999... ETH).\n    /// This behavior is accepted due to being trivial in effect.\n    /// @param dapiName dAPI name\n    /// @param updateParameters Update parameters\n    /// @param duration Subscription duration\n    /// @param price Subscription price\n    /// @return expectedSponsorWalletBalance Expected sponsor wallet balance\n    function computeExpectedSponsorWalletBalanceAfterSubscriptionIsAdded(\n        bytes32 dapiName,\n        bytes calldata updateParameters,\n        uint256 duration,\n        uint256 price\n    ) external view override returns (uint256 expectedSponsorWalletBalance) {\n        require(\n            updateParameters.length == UPDATE_PARAMETERS_LENGTH,\n            \"Update parameters length invalid\"\n        );\n        (\n            bytes32 subscriptionId,\n            uint32 endTimestamp,\n            bytes32 previousSubscriptionId,\n            bytes32 nextSubscriptionId\n        ) = prospectSubscriptionPositionInQueue(\n                dapiName,\n                updateParameters,\n                duration\n            );\n        uint256 dailyPrice = (price * 1 days) / duration;\n        uint32 startTimestamp = SafeCast.toUint32(block.timestamp);\n        bytes32 queuedSubscriptionId = previousSubscriptionId == bytes32(0)\n            ? subscriptionId\n            : dapiNameToCurrentSubscriptionId[dapiName];\n        for (; queuedSubscriptionId != bytes32(0); ) {\n            if (queuedSubscriptionId == subscriptionId) {\n                expectedSponsorWalletBalance +=\n                    ((endTimestamp - startTimestamp) * dailyPrice) /\n                    1 days;\n                startTimestamp = endTimestamp;\n                queuedSubscriptionId = nextSubscriptionId;\n            } else {\n                Subscription storage queuedSubscription = subscriptions[\n                    queuedSubscriptionId\n                ];\n                uint32 queuedSubscriptionEndTimestamp = queuedSubscription\n                    .endTimestamp;\n                if (queuedSubscriptionEndTimestamp > block.timestamp) {\n                    expectedSponsorWalletBalance +=\n                        ((queuedSubscriptionEndTimestamp - startTimestamp) *\n                            queuedSubscription.dailyPrice) /\n                        1 days;\n                    startTimestamp = queuedSubscriptionEndTimestamp;\n                }\n                if (previousSubscriptionId == queuedSubscriptionId) {\n                    queuedSubscriptionId = subscriptionId;\n                } else {\n                    queuedSubscriptionId = queuedSubscription\n                        .nextSubscriptionId;\n                }\n            }\n        }\n    }\n\n    /// @notice Gets all data about the dAPI that is available\n    /// @dev This function is intended to be used by the API3 Market frontend\n    /// to get all data related to a specific dAPI. It returns the entire\n    /// subscription queue, including the items whose end timestamps are in the\n    /// past.\n    /// @param dapiName dAPI name\n    /// @return dataFeedDetails Data feed details\n    /// @return dapiValue dAPI value read from Api3ServerV1\n    /// @return dapiTimestamp dAPI timestamp read from Api3ServerV1\n    /// @return beaconValues Beacon values read from Api3ServerV1\n    /// @return beaconTimestamps Beacon timestamps read from Api3ServerV1\n    /// @return updateParameters Update parameters of the subscriptions in the\n    /// queue\n    /// @return endTimestamps End timestamps of the subscriptions in the queue\n    /// @return dailyPrices Daily prices of the subscriptions in the queue\n    function getDapiData(\n        bytes32 dapiName\n    )\n        external\n        view\n        override\n        returns (\n            bytes memory dataFeedDetails,\n            int224 dapiValue,\n            uint32 dapiTimestamp,\n            int224[] memory beaconValues,\n            uint32[] memory beaconTimestamps,\n            bytes[] memory updateParameters,\n            uint32[] memory endTimestamps,\n            uint224[] memory dailyPrices\n        )\n    {\n        bytes32 currentDataFeedId = IApi3ServerV1(api3ServerV1)\n            .dapiNameHashToDataFeedId(keccak256(abi.encodePacked(dapiName)));\n        (\n            dataFeedDetails,\n            dapiValue,\n            dapiTimestamp,\n            beaconValues,\n            beaconTimestamps\n        ) = getDataFeedData(currentDataFeedId);\n        uint256 queueLength = 0;\n        for (\n            bytes32 queuedSubscriptionId = dapiNameToCurrentSubscriptionId[\n                dapiName\n            ];\n            queuedSubscriptionId != bytes32(0);\n            queuedSubscriptionId = subscriptions[queuedSubscriptionId]\n                .nextSubscriptionId\n        ) {\n            queueLength++;\n        }\n        updateParameters = new bytes[](queueLength);\n        endTimestamps = new uint32[](queueLength);\n        dailyPrices = new uint224[](queueLength);\n        Subscription storage queuedSubscription = subscriptions[\n            dapiNameToCurrentSubscriptionId[dapiName]\n        ];\n        for (uint256 ind = 0; ind < queueLength; ind++) {\n            updateParameters[ind] = updateParametersHashToValue[\n                queuedSubscription.updateParametersHash\n            ];\n            endTimestamps[ind] = queuedSubscription.endTimestamp;\n            dailyPrices[ind] = queuedSubscription.dailyPrice;\n            queuedSubscription = subscriptions[\n                queuedSubscription.nextSubscriptionId\n            ];\n        }\n    }\n\n    /// @notice Gets all data about the data feed that is available\n    /// @dev This function is intended to be used by the API3 Market frontend\n    /// to determine what needs to be done to ready the data feed to purchase\n    /// the respective subscription.\n    /// @param dataFeedId Data feed ID\n    /// @return dataFeedDetails Data feed details\n    /// @return dataFeedValue Data feed value read from Api3ServerV1\n    /// @return dataFeedTimestamp Data feed timestamp read from Api3ServerV1\n    /// @return beaconValues Beacon values read from Api3ServerV1\n    /// @return beaconTimestamps Beacon timestamps read from Api3ServerV1\n    function getDataFeedData(\n        bytes32 dataFeedId\n    )\n        public\n        view\n        returns (\n            bytes memory dataFeedDetails,\n            int224 dataFeedValue,\n            uint32 dataFeedTimestamp,\n            int224[] memory beaconValues,\n            uint32[] memory beaconTimestamps\n        )\n    {\n        dataFeedDetails = AirseekerRegistry(airseekerRegistry)\n            .dataFeedIdToDetails(dataFeedId);\n        (dataFeedValue, dataFeedTimestamp) = IApi3ServerV1(api3ServerV1)\n            .dataFeeds(dataFeedId);\n        if (\n            dataFeedDetails.length == DATA_FEED_DETAILS_LENGTH_FOR_SINGLE_BEACON\n        ) {\n            beaconValues = new int224[](1);\n            beaconTimestamps = new uint32[](1);\n            (address airnode, bytes32 templateId) = abi.decode(\n                dataFeedDetails,\n                (address, bytes32)\n            );\n            (beaconValues[0], beaconTimestamps[0]) = IApi3ServerV1(api3ServerV1)\n                .dataFeeds(deriveBeaconId(airnode, templateId));\n        } else {\n            (address[] memory airnodes, bytes32[] memory templateIds) = abi\n                .decode(dataFeedDetails, (address[], bytes32[]));\n            uint256 beaconCount = airnodes.length;\n            beaconValues = new int224[](beaconCount);\n            beaconTimestamps = new uint32[](beaconCount);\n            for (uint256 ind = 0; ind < beaconCount; ind++) {\n                (beaconValues[ind], beaconTimestamps[ind]) = IApi3ServerV1(\n                    api3ServerV1\n                ).dataFeeds(deriveBeaconId(airnodes[ind], templateIds[ind]));\n            }\n        }\n    }\n\n    /// @notice Subscription ID to update parameters\n    /// @param subscriptionId Subscription ID\n    /// @return updateParameters Update parameters\n    function subscriptionIdToUpdateParameters(\n        bytes32 subscriptionId\n    ) public view override returns (bytes memory updateParameters) {\n        updateParameters = updateParametersHashToValue[\n            subscriptions[subscriptionId].updateParametersHash\n        ];\n    }\n\n    /// @notice Returns the signature delegation hash type used in delegation\n    /// signatures\n    /// @return Signature delegation hash type\n    function signatureDelegationHashType()\n        public\n        view\n        virtual\n        override(HashRegistry, IHashRegistry)\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\"Api3Market signature delegation\"));\n    }\n\n    /// @notice Adds the subscription to the queue if applicable\n    /// @param dapiName dAPI name\n    /// @param dataFeedId Data feed ID\n    /// @param updateParameters Update parameters\n    /// @param duration Subscription duration\n    /// @param price Subscription price\n    function addSubscriptionToQueue(\n        bytes32 dapiName,\n        bytes32 dataFeedId,\n        bytes calldata updateParameters,\n        uint256 duration,\n        uint256 price\n    ) private returns (bytes32 subscriptionId) {\n        uint32 endTimestamp;\n        bytes32 previousSubscriptionId;\n        bytes32 nextSubscriptionId;\n        (\n            subscriptionId,\n            endTimestamp,\n            previousSubscriptionId,\n            nextSubscriptionId\n        ) = prospectSubscriptionPositionInQueue(\n            dapiName,\n            updateParameters,\n            duration\n        );\n        bytes32 updateParametersHash = keccak256(updateParameters);\n        if (updateParametersHashToValue[updateParametersHash].length == 0) {\n            updateParametersHashToValue[\n                updateParametersHash\n            ] = updateParameters;\n        }\n        subscriptions[subscriptionId] = Subscription({\n            updateParametersHash: updateParametersHash,\n            endTimestamp: endTimestamp,\n            dailyPrice: SafeCast.toUint224((price * 1 days) / duration),\n            nextSubscriptionId: nextSubscriptionId\n        });\n        if (previousSubscriptionId == bytes32(0)) {\n            if (subscriptionId != dapiNameToCurrentSubscriptionId[dapiName]) {\n                emit UpdatedCurrentSubscriptionId(dapiName, subscriptionId);\n                dapiNameToCurrentSubscriptionId[dapiName] = subscriptionId;\n            }\n            AirseekerRegistry(airseekerRegistry).setDapiNameUpdateParameters(\n                dapiName,\n                updateParameters\n            );\n            AirseekerRegistry(airseekerRegistry).setDapiNameToBeActivated(\n                dapiName\n            );\n        } else {\n            subscriptions[previousSubscriptionId]\n                .nextSubscriptionId = subscriptionId;\n            bytes32 currentSubscriptionId = dapiNameToCurrentSubscriptionId[\n                dapiName\n            ];\n            if (\n                subscriptions[currentSubscriptionId].endTimestamp <=\n                block.timestamp\n            ) {\n                updateEndedCurrentSubscriptionId(\n                    dapiName,\n                    currentSubscriptionId\n                );\n            }\n        }\n        validateDataFeedReadiness(dataFeedId);\n        if (\n            IApi3ServerV1(api3ServerV1).dapiNameHashToDataFeedId(\n                keccak256(abi.encodePacked(dapiName))\n            ) != dataFeedId\n        ) {\n            IApi3ServerV1(api3ServerV1).setDapiName(dapiName, dataFeedId);\n        }\n    }\n\n    /// @notice Updates the current subscription that has ended with the one\n    /// that will end next\n    /// @param dapiName dAPI name\n    /// @param currentSubscriptionId Current subscription ID\n    function updateEndedCurrentSubscriptionId(\n        bytes32 dapiName,\n        bytes32 currentSubscriptionId\n    ) private {\n        do {\n            currentSubscriptionId = subscriptions[currentSubscriptionId]\n                .nextSubscriptionId;\n        } while (\n            currentSubscriptionId != bytes32(0) &&\n                subscriptions[currentSubscriptionId].endTimestamp <=\n                block.timestamp\n        );\n        emit UpdatedCurrentSubscriptionId(dapiName, currentSubscriptionId);\n        dapiNameToCurrentSubscriptionId[dapiName] = currentSubscriptionId;\n        if (currentSubscriptionId == bytes32(0)) {\n            AirseekerRegistry(airseekerRegistry).setDapiNameToBeDeactivated(\n                dapiName\n            );\n        } else {\n            AirseekerRegistry(airseekerRegistry).setDapiNameUpdateParameters(\n                dapiName,\n                subscriptionIdToUpdateParameters(currentSubscriptionId)\n            );\n        }\n    }\n\n    /// @notice Prospects the subscription position in the queue. It iterates\n    /// through the entire subscription queue, which is implemented as a linked\n    /// list, and returns the previous and next nodes of the subscription to be\n    /// added.\n    /// It reverts if no suitable position can be found, which would be because\n    /// the addition of the subscription to the queue does not upgrade its\n    /// specs unambiguously or addition of it results in the maximum queue\n    /// length to be exceeded.\n    /// @param dapiName dAPI name\n    /// @param updateParameters Update parameters\n    /// @param duration Subscription duration\n    /// @return subscriptionId Subscription ID\n    /// @return endTimestamp End timestamp\n    /// @return previousSubscriptionId Previous subscription ID\n    /// @return nextSubscriptionId Next subscription ID\n    function prospectSubscriptionPositionInQueue(\n        bytes32 dapiName,\n        bytes calldata updateParameters,\n        uint256 duration\n    )\n        private\n        view\n        returns (\n            bytes32 subscriptionId,\n            uint32 endTimestamp,\n            bytes32 previousSubscriptionId,\n            bytes32 nextSubscriptionId\n        )\n    {\n        subscriptionId = keccak256(\n            abi.encodePacked(dapiName, keccak256(updateParameters))\n        );\n        endTimestamp = SafeCast.toUint32(block.timestamp + duration);\n        (\n            uint256 deviationThresholdInPercentage,\n            int224 deviationReference,\n            uint256 heartbeatInterval\n        ) = abi.decode(updateParameters, (uint256, int224, uint256));\n        uint256 newQueueLength = 0;\n        Subscription storage queuedSubscription;\n        for (\n            bytes32 queuedSubscriptionId = dapiNameToCurrentSubscriptionId[\n                dapiName\n            ];\n            queuedSubscriptionId != bytes32(0);\n            queuedSubscriptionId = queuedSubscription.nextSubscriptionId\n        ) {\n            queuedSubscription = subscriptions[queuedSubscriptionId];\n            UpdateParametersComparisonResult updateParametersComparisonResult = compareUpdateParametersWithQueued(\n                    deviationThresholdInPercentage,\n                    deviationReference,\n                    heartbeatInterval,\n                    queuedSubscription.updateParametersHash\n                );\n            uint32 queuedSubscriptionEndTimestamp = queuedSubscription\n                .endTimestamp;\n            require(\n                updateParametersComparisonResult ==\n                    UpdateParametersComparisonResult.BetterThanQueued ||\n                    endTimestamp > queuedSubscriptionEndTimestamp,\n                \"Subscription does not upgrade\"\n            );\n            if (\n                updateParametersComparisonResult ==\n                UpdateParametersComparisonResult.WorseThanQueued &&\n                queuedSubscriptionEndTimestamp > block.timestamp\n            ) {\n                previousSubscriptionId = queuedSubscriptionId;\n                newQueueLength++;\n            }\n            if (\n                updateParametersComparisonResult ==\n                UpdateParametersComparisonResult.BetterThanQueued &&\n                endTimestamp < queuedSubscriptionEndTimestamp\n            ) {\n                nextSubscriptionId = queuedSubscriptionId;\n                for (\n                    ;\n                    queuedSubscriptionId != bytes32(0);\n                    queuedSubscriptionId = subscriptions[queuedSubscriptionId]\n                        .nextSubscriptionId\n                ) {\n                    newQueueLength++;\n                }\n                break;\n            }\n        }\n        require(\n            newQueueLength < MAXIMUM_SUBSCRIPTION_QUEUE_LENGTH,\n            \"Subscription queue full\"\n        );\n    }\n\n    /// @notice Compares the update parameters with the ones that belong to a\n    /// queued subscription\n    /// @param deviationThresholdInPercentage Deviation threshold in percentage\n    /// @param deviationReference Deviation reference\n    /// @param heartbeatInterval Heartbeat interval\n    /// @param queuedUpdateParametersHash Queued update parameters hash\n    /// @return Update parameters comparison result\n    function compareUpdateParametersWithQueued(\n        uint256 deviationThresholdInPercentage,\n        int224 deviationReference,\n        uint256 heartbeatInterval,\n        bytes32 queuedUpdateParametersHash\n    ) private view returns (UpdateParametersComparisonResult) {\n        // The update parameters that belong to a queued subscription are\n        // guaranteed to have been stored in the hash map\n        (\n            uint256 queuedDeviationThresholdInPercentage,\n            int224 queuedDeviationReference,\n            uint256 queuedHeartbeatInterval\n        ) = abi.decode(\n                updateParametersHashToValue[queuedUpdateParametersHash],\n                (uint256, int224, uint256)\n            );\n        require(\n            deviationReference == queuedDeviationReference,\n            \"Deviation references not equal\"\n        );\n        if (\n            (deviationThresholdInPercentage ==\n                queuedDeviationThresholdInPercentage) &&\n            (heartbeatInterval == queuedHeartbeatInterval)\n        ) {\n            return UpdateParametersComparisonResult.EqualToQueued;\n        } else if (\n            (deviationThresholdInPercentage <=\n                queuedDeviationThresholdInPercentage) &&\n            (heartbeatInterval <= queuedHeartbeatInterval)\n        ) {\n            return UpdateParametersComparisonResult.BetterThanQueued;\n        } else if (\n            (deviationThresholdInPercentage >=\n                queuedDeviationThresholdInPercentage) &&\n            (heartbeatInterval >= queuedHeartbeatInterval)\n        ) {\n            return UpdateParametersComparisonResult.WorseThanQueued;\n        } else {\n            // This is hit when the set of parameters are superior to each\n            // other in different aspects, in which case they should not be\n            // allowed to be in the same queue\n            revert(\"Update parameters incomparable\");\n        }\n    }\n\n    /// @notice Validates the readiness of the data feed. The data feed must\n    /// have been updated on Api3ServerV1 in the last `MAXIMUM_DAPI_UPDATE_AGE`\n    /// and registered on AirseekerRegistry.\n    /// @param dataFeedId Data feed ID\n    function validateDataFeedReadiness(bytes32 dataFeedId) private view {\n        (, uint32 timestamp) = IApi3ServerV1(api3ServerV1).dataFeeds(\n            dataFeedId\n        );\n        require(\n            block.timestamp <= timestamp + MAXIMUM_DAPI_UPDATE_AGE,\n            \"Data feed value stale\"\n        );\n        require(\n            AirseekerRegistry(airseekerRegistry).dataFeedIsRegistered(\n                dataFeedId\n            ),\n            \"Data feed not registered\"\n        );\n    }\n\n    /// @notice Verifies the dAPI management Merkle proof\n    /// @param dapiName dAPI name\n    /// @param dataFeedId Data feed ID\n    /// @param sponsorWallet Sponsor wallet address\n    /// @param dapiManagementMerkleData ABI-encoded dAPI management Merkle root\n    /// and proof\n    function verifyDapiManagementMerkleProof(\n        bytes32 dapiName,\n        bytes32 dataFeedId,\n        address sponsorWallet,\n        bytes calldata dapiManagementMerkleData\n    ) private view {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        (\n            bytes32 dapiManagementMerkleRoot,\n            bytes32[] memory dapiManagementMerkleProof\n        ) = abi.decode(dapiManagementMerkleData, (bytes32, bytes32[]));\n        require(\n            hashes[DAPI_MANAGEMENT_MERKLE_ROOT_HASH_TYPE].value ==\n                dapiManagementMerkleRoot,\n            \"Invalid root\"\n        );\n        require(\n            MerkleProof.verify(\n                dapiManagementMerkleProof,\n                dapiManagementMerkleRoot,\n                keccak256(\n                    bytes.concat(\n                        keccak256(\n                            abi.encode(dapiName, dataFeedId, sponsorWallet)\n                        )\n                    )\n                )\n            ),\n            \"Invalid proof\"\n        );\n    }\n\n    /// @notice Verifies the dAPI pricing Merkle proof\n    /// @param dapiName dAPI name\n    /// @param updateParameters Update parameters\n    /// @param duration Subscription duration\n    /// @param price Subscription price\n    /// @param dapiPricingMerkleData ABI-encoded dAPI pricing Merkle root and\n    /// proof\n    function verifyDapiPricingMerkleProof(\n        bytes32 dapiName,\n        bytes calldata updateParameters,\n        uint256 duration,\n        uint256 price,\n        bytes calldata dapiPricingMerkleData\n    ) private view {\n        require(\n            updateParameters.length == UPDATE_PARAMETERS_LENGTH,\n            \"Update parameters length invalid\"\n        );\n        require(duration != 0, \"Duration zero\");\n        require(price != 0, \"Price zero\");\n        (\n            bytes32 dapiPricingMerkleRoot,\n            bytes32[] memory dapiPricingMerkleProof\n        ) = abi.decode(dapiPricingMerkleData, (bytes32, bytes32[]));\n        require(\n            hashes[DAPI_PRICING_MERKLE_ROOT_HASH_TYPE].value ==\n                dapiPricingMerkleRoot,\n            \"Invalid root\"\n        );\n        require(\n            MerkleProof.verify(\n                dapiPricingMerkleProof,\n                dapiPricingMerkleRoot,\n                keccak256(\n                    bytes.concat(\n                        keccak256(\n                            abi.encode(\n                                dapiName,\n                                block.chainid,\n                                updateParameters,\n                                duration,\n                                price\n                            )\n                        )\n                    )\n                )\n            ),\n            \"Invalid proof\"\n        );\n    }\n\n    /// @notice Verifies the signed API URL Merkle proof\n    /// @param airnode Airnode address\n    /// @param signedApiUrl Signed API URL\n    /// @param signedApiUrlMerkleData ABI-encoded signed API URL Merkle root\n    /// and proof\n    function verifySignedApiUrlMerkleProof(\n        address airnode,\n        string calldata signedApiUrl,\n        bytes calldata signedApiUrlMerkleData\n    ) private view {\n        (\n            bytes32 signedApiUrlMerkleRoot,\n            bytes32[] memory signedApiUrlMerkleProof\n        ) = abi.decode(signedApiUrlMerkleData, (bytes32, bytes32[]));\n        require(\n            hashes[SIGNED_API_URL_MERKLE_ROOT_HASH_TYPE].value ==\n                signedApiUrlMerkleRoot,\n            \"Invalid root\"\n        );\n        require(\n            MerkleProof.verify(\n                signedApiUrlMerkleProof,\n                signedApiUrlMerkleRoot,\n                keccak256(\n                    bytes.concat(keccak256(abi.encode(airnode, signedApiUrl)))\n                )\n            ),\n            \"Invalid proof\"\n        );\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(\n        address airnode,\n        bytes32 templateId\n    ) private pure returns (bytes32 beaconId) {\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n}\n"
    },
    "contracts/api3-server-v1/Api3ServerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./OevDapiServer.sol\";\nimport \"./BeaconUpdatesWithSignedData.sol\";\nimport \"./interfaces/IApi3ServerV1.sol\";\n\n/// @title First version of the contract that API3 uses to serve data feeds\n/// @notice Api3ServerV1 serves data feeds in the form of Beacons, Beacon sets,\n/// dAPIs, with optional OEV support for all of these.\n/// The base Beacons are only updateable using signed data, and the Beacon sets\n/// are updateable based on the Beacons, optionally using PSP. OEV proxy\n/// Beacons and Beacon sets are updateable using OEV-signed data.\n/// Api3ServerV1 does not support Beacons to be updated using RRP or PSP.\ncontract Api3ServerV1 is\n    OevDapiServer,\n    BeaconUpdatesWithSignedData,\n    IApi3ServerV1\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    ) OevDapiServer(_accessControlRegistry, _adminRoleDescription, _manager) {}\n\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithId(\n        bytes32 dataFeedId\n    ) external view override returns (int224 value, uint32 timestamp) {\n        return _readDataFeedWithId(dataFeedId);\n    }\n\n    /// @notice Reads the data feed with dAPI name hash\n    /// @param dapiNameHash dAPI name hash\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithDapiNameHash(\n        bytes32 dapiNameHash\n    ) external view override returns (int224 value, uint32 timestamp) {\n        return _readDataFeedWithDapiNameHash(dapiNameHash);\n    }\n\n    /// @notice Reads the data feed as the OEV proxy with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithIdAsOevProxy(\n        bytes32 dataFeedId\n    ) external view override returns (int224 value, uint32 timestamp) {\n        return _readDataFeedWithIdAsOevProxy(dataFeedId);\n    }\n\n    /// @notice Reads the data feed as the OEV proxy with dAPI name hash\n    /// @param dapiNameHash dAPI name hash\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithDapiNameHashAsOevProxy(\n        bytes32 dapiNameHash\n    ) external view override returns (int224 value, uint32 timestamp) {\n        return _readDataFeedWithDapiNameHashAsOevProxy(dapiNameHash);\n    }\n\n    function dataFeeds(\n        bytes32 dataFeedId\n    ) external view override returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n    }\n\n    function oevProxyToIdToDataFeed(\n        address proxy,\n        bytes32 dataFeedId\n    ) external view override returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _oevProxyToIdToDataFeed[proxy][dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n    }\n}\n"
    },
    "contracts/api3-server-v1/BeaconUpdatesWithSignedData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./DataFeedServer.sol\";\nimport \"./interfaces/IBeaconUpdatesWithSignedData.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.8.2/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that updates Beacons using signed data\ncontract BeaconUpdatesWithSignedData is\n    DataFeedServer,\n    IBeaconUpdatesWithSignedData\n{\n    using ECDSA for bytes32;\n\n    /// @notice Updates a Beacon using data signed by the Airnode\n    /// @dev The signed data here is intentionally very general for practical\n    /// reasons. It is less demanding on the signer to have data signed once\n    /// and use that everywhere.\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param timestamp Signature timestamp\n    /// @param data Update data (an `int256` encoded in contract ABI)\n    /// @param signature Template ID, timestamp and the update data signed by\n    /// the Airnode\n    /// @return beaconId Updated Beacon ID\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 templateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override returns (bytes32 beaconId) {\n        require(\n            (\n                keccak256(abi.encodePacked(templateId, timestamp, data))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Signature mismatch\"\n        );\n        beaconId = deriveBeaconId(airnode, templateId);\n        int224 updatedValue = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithSignedData(\n            beaconId,\n            updatedValue,\n            uint32(timestamp)\n        );\n    }\n}\n"
    },
    "contracts/api3-server-v1/DapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../access/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"./DataFeedServer.sol\";\nimport \"./interfaces/IDapiServer.sol\";\n\n/// @title Contract that serves dAPIs mapped to Beacons and Beacon sets\n/// @notice Beacons and Beacon sets are addressed by immutable IDs. Although\n/// this is trust-minimized, it requires users to manage the ID of the data\n/// feed they are using. For when the user does not want to do this, dAPIs can\n/// be used as an abstraction layer. By using a dAPI, the user delegates this\n/// responsibility to dAPI management. It is important for dAPI management to\n/// be restricted by consensus rules (by using a multisig or a DAO) and similar\n/// trustless security mechanisms.\ncontract DapiServer is\n    AccessControlRegistryAdminnedWithManager,\n    DataFeedServer,\n    IDapiServer\n{\n    /// @notice dAPI name setter role description\n    string public constant override DAPI_NAME_SETTER_ROLE_DESCRIPTION =\n        \"dAPI name setter\";\n\n    /// @notice dAPI name setter role\n    bytes32 public immutable override dapiNameSetterRole;\n\n    /// @notice dAPI name hash mapped to the data feed ID\n    mapping(bytes32 => bytes32) public override dapiNameHashToDataFeedId;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {\n        dapiNameSetterRole = _deriveRole(\n            _deriveAdminRole(manager),\n            DAPI_NAME_SETTER_ROLE_DESCRIPTION\n        );\n    }\n\n    /// @notice Sets the data feed ID the dAPI name points to\n    /// @dev While a data feed ID refers to a specific Beacon or Beacon set,\n    /// dAPI names provide a more abstract interface for convenience. This\n    /// means a dAPI name that was pointing to a Beacon can be pointed to a\n    /// Beacon set, then another Beacon set, etc.\n    /// @param dapiName Human-readable dAPI name\n    /// @param dataFeedId Data feed ID the dAPI name will point to\n    function setDapiName(\n        bytes32 dapiName,\n        bytes32 dataFeedId\n    ) external override {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        require(\n            msg.sender == manager ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    dapiNameSetterRole,\n                    msg.sender\n                ),\n            \"Sender cannot set dAPI name\"\n        );\n        dapiNameHashToDataFeedId[\n            keccak256(abi.encodePacked(dapiName))\n        ] = dataFeedId;\n        emit SetDapiName(dataFeedId, dapiName, msg.sender);\n    }\n\n    /// @notice Returns the data feed ID the dAPI name is set to\n    /// @param dapiName dAPI name\n    /// @return Data feed ID\n    function dapiNameToDataFeedId(\n        bytes32 dapiName\n    ) external view override returns (bytes32) {\n        return dapiNameHashToDataFeedId[keccak256(abi.encodePacked(dapiName))];\n    }\n\n    /// @notice Reads the data feed with dAPI name hash\n    /// @param dapiNameHash dAPI name hash\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithDapiNameHash(\n        bytes32 dapiNameHash\n    ) internal view returns (int224 value, uint32 timestamp) {\n        bytes32 dataFeedId = dapiNameHashToDataFeedId[dapiNameHash];\n        require(dataFeedId != bytes32(0), \"dAPI name not set\");\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n}\n"
    },
    "contracts/api3-server-v1/DataFeedServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../utils/ExtendedSelfMulticall.sol\";\nimport \"./aggregation/Median.sol\";\nimport \"./interfaces/IDataFeedServer.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.8.2/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that serves Beacons and Beacon sets\n/// @notice A Beacon is a live data feed addressed by an ID, which is derived\n/// from an Airnode address and a template ID. This is suitable where the more\n/// recent data point is always more favorable, e.g., in the context of an\n/// asset price data feed. Beacons can also be seen as one-Airnode data feeds\n/// that can be used individually or combined to build Beacon sets.\ncontract DataFeedServer is ExtendedSelfMulticall, Median, IDataFeedServer {\n    using ECDSA for bytes32;\n\n    // Airnodes serve their fulfillment data along with timestamps. This\n    // contract casts the reported data to `int224` and the timestamp to\n    // `uint32`, which works until year 2106.\n    struct DataFeed {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice Data feed with ID\n    mapping(bytes32 => DataFeed) internal _dataFeeds;\n\n    /// @dev Reverts if the timestamp is from more than 1 hour in the future\n    modifier onlyValidTimestamp(uint256 timestamp) virtual {\n        unchecked {\n            require(\n                timestamp < block.timestamp + 1 hours,\n                \"Timestamp not valid\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Updates the Beacon set using the current values of its Beacons\n    /// @dev As an oddity, this function still works if some of the IDs in\n    /// `beaconIds` belong to Beacon sets rather than Beacons. This can be used\n    /// to implement hierarchical Beacon sets.\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithBeacons(\n        bytes32[] memory beaconIds\n    ) public override returns (bytes32 beaconSetId) {\n        (int224 updatedValue, uint32 updatedTimestamp) = aggregateBeacons(\n            beaconIds\n        );\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        DataFeed storage beaconSet = _dataFeeds[beaconSetId];\n        if (beaconSet.timestamp == updatedTimestamp) {\n            require(\n                beaconSet.value != updatedValue,\n                \"Does not update Beacon set\"\n            );\n        }\n        _dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithBeacons(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithId(\n        bytes32 dataFeedId\n    ) internal view returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(\n        address airnode,\n        bytes32 templateId\n    ) internal pure returns (bytes32 beaconId) {\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n\n    /// @notice Derives the Beacon set ID from the Beacon IDs\n    /// @dev Notice that `abi.encode()` is used over `abi.encodePacked()`\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function deriveBeaconSetId(\n        bytes32[] memory beaconIds\n    ) internal pure returns (bytes32 beaconSetId) {\n        beaconSetId = keccak256(abi.encode(beaconIds));\n    }\n\n    /// @notice Called privately to process the Beacon update\n    /// @param beaconId Beacon ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return updatedBeaconValue Updated Beacon value\n    function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    )\n        internal\n        onlyValidTimestamp(timestamp)\n        returns (int224 updatedBeaconValue)\n    {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > _dataFeeds[beaconId].timestamp,\n            \"Does not update timestamp\"\n        );\n        _dataFeeds[beaconId] = DataFeed({\n            value: updatedBeaconValue,\n            timestamp: uint32(timestamp)\n        });\n    }\n\n    /// @notice Called privately to decode the fulfillment data\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return decodedData Decoded fulfillment data\n    function decodeFulfillmentData(\n        bytes memory data\n    ) internal pure returns (int224) {\n        require(data.length == 32, \"Data length not correct\");\n        int256 decodedData = abi.decode(data, (int256));\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        return int224(decodedData);\n    }\n\n    /// @notice Called privately to aggregate the Beacons and return the result\n    /// @param beaconIds Beacon IDs\n    /// @return value Aggregation value\n    /// @return timestamp Aggregation timestamp\n    function aggregateBeacons(\n        bytes32[] memory beaconIds\n    ) internal view returns (int224 value, uint32 timestamp) {\n        uint256 beaconCount = beaconIds.length;\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        int256[] memory values = new int256[](beaconCount);\n        int256[] memory timestamps = new int256[](beaconCount);\n        for (uint256 ind = 0; ind < beaconCount; ) {\n            DataFeed storage dataFeed = _dataFeeds[beaconIds[ind]];\n            values[ind] = dataFeed.value;\n            timestamps[ind] = int256(uint256(dataFeed.timestamp));\n            unchecked {\n                ind++;\n            }\n        }\n        value = int224(median(values));\n        timestamp = uint32(uint256(median(timestamps)));\n    }\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IAirseekerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../access/interfaces/IOwnable.sol\";\nimport \"../../utils/interfaces/IExtendedSelfMulticall.sol\";\n\ninterface IAirseekerRegistry is IOwnable, IExtendedSelfMulticall {\n    event ActivatedDataFeedId(bytes32 indexed dataFeedId);\n\n    event ActivatedDapiName(bytes32 indexed dapiName);\n\n    event DeactivatedDataFeedId(bytes32 indexed dataFeedId);\n\n    event DeactivatedDapiName(bytes32 indexed dapiName);\n\n    event UpdatedDataFeedIdUpdateParameters(\n        bytes32 indexed dataFeedId,\n        bytes updateParameters\n    );\n\n    event UpdatedDapiNameUpdateParameters(\n        bytes32 indexed dapiName,\n        bytes updateParameters\n    );\n\n    event UpdatedSignedApiUrl(address indexed airnode, string signedApiUrl);\n\n    event RegisteredDataFeed(bytes32 indexed dataFeedId, bytes dataFeedDetails);\n\n    function setDataFeedIdToBeActivated(bytes32 dataFeedId) external;\n\n    function setDapiNameToBeActivated(bytes32 dapiName) external;\n\n    function setDataFeedIdToBeDeactivated(bytes32 dataFeedId) external;\n\n    function setDapiNameToBeDeactivated(bytes32 dapiName) external;\n\n    function setDataFeedIdUpdateParameters(\n        bytes32 dataFeedId,\n        bytes calldata updateParameters\n    ) external;\n\n    function setDapiNameUpdateParameters(\n        bytes32 dapiName,\n        bytes calldata updateParameters\n    ) external;\n\n    function setSignedApiUrl(\n        address airnode,\n        string calldata signedApiUrl\n    ) external;\n\n    function registerDataFeed(\n        bytes calldata dataFeedDetails\n    ) external returns (bytes32 dataFeedId);\n\n    function activeDataFeed(\n        uint256 index\n    )\n        external\n        view\n        returns (\n            bytes32 dataFeedId,\n            bytes32 dapiName,\n            bytes memory dataFeedDetails,\n            int224 dataFeedValue,\n            uint32 dataFeedTimestamp,\n            int224[] memory beaconValues,\n            uint32[] memory beaconTimestamps,\n            bytes memory updateParameters,\n            string[] memory signedApiUrls\n        );\n\n    function activeDataFeedCount() external view returns (uint256);\n\n    function activeDataFeedIdCount() external view returns (uint256);\n\n    function activeDapiNameCount() external view returns (uint256);\n\n    function dataFeedIdToUpdateParameters(\n        bytes32 dataFeedId\n    ) external view returns (bytes memory updateParameters);\n\n    function dapiNameToUpdateParameters(\n        bytes32 dapiName\n    ) external view returns (bytes memory updateParameters);\n\n    function dataFeedIsRegistered(\n        bytes32 dataFeedId\n    ) external view returns (bool);\n\n    function MAXIMUM_BEACON_COUNT_IN_SET() external view returns (uint256);\n\n    function MAXIMUM_UPDATE_PARAMETERS_LENGTH() external view returns (uint256);\n\n    function MAXIMUM_SIGNED_API_URL_LENGTH() external view returns (uint256);\n\n    function api3ServerV1() external view returns (address);\n\n    function airnodeToSignedApiUrl(\n        address airnode\n    ) external view returns (string memory signedApiUrl);\n\n    function dataFeedIdToDetails(\n        bytes32 dataFeedId\n    ) external view returns (bytes memory dataFeedDetails);\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IApi3Market.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../access/interfaces/IHashRegistry.sol\";\nimport \"../../utils/interfaces/IExtendedSelfMulticall.sol\";\n\ninterface IApi3Market is IHashRegistry, IExtendedSelfMulticall {\n    event BoughtSubscription(\n        bytes32 indexed dapiName,\n        bytes32 indexed subscriptionId,\n        bytes32 dataFeedId,\n        address sponsorWallet,\n        bytes updateParameters,\n        uint256 duration,\n        uint256 price,\n        uint256 paymentAmount\n    );\n\n    event UpdatedCurrentSubscriptionId(\n        bytes32 indexed dapiName,\n        bytes32 indexed subscriptionId\n    );\n\n    function buySubscription(\n        bytes32 dapiName,\n        bytes32 dataFeedId,\n        address payable sponsorWallet,\n        bytes calldata dapiManagementMerkleData,\n        bytes calldata updateParameters,\n        uint256 duration,\n        uint256 price,\n        bytes calldata dapiPricingMerkleData\n    ) external payable returns (bytes32 subscriptionId);\n\n    function updateCurrentSubscriptionId(bytes32 dapiName) external;\n\n    function updateDapiName(\n        bytes32 dapiName,\n        bytes32 dataFeedId,\n        address sponsorWallet,\n        bytes calldata dapiManagementMerkleData\n    ) external;\n\n    function updateSignedApiUrl(\n        address airnode,\n        string calldata signedApiUrl,\n        bytes calldata signedApiUrlMerkleData\n    ) external;\n\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 templateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bytes32 beaconId);\n\n    function updateBeaconSetWithBeacons(\n        bytes32[] calldata beaconIds\n    ) external returns (bytes32 beaconSetId);\n\n    function deployDapiProxy(\n        bytes32 dapiName,\n        bytes calldata metadata\n    ) external returns (address proxyAddress);\n\n    function deployDapiProxyWithOev(\n        bytes32 dapiName,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external returns (address proxyAddress);\n\n    function registerDataFeed(\n        bytes calldata dataFeedDetails\n    ) external returns (bytes32 dataFeedId);\n\n    function computeExpectedSponsorWalletBalance(\n        bytes32 dapiName\n    ) external view returns (uint256 expectedSponsorWalletBalance);\n\n    function computeExpectedSponsorWalletBalanceAfterSubscriptionIsAdded(\n        bytes32 dapiName,\n        bytes calldata updateParameters,\n        uint256 duration,\n        uint256 price\n    ) external view returns (uint256 expectedSponsorWalletBalance);\n\n    function getDapiData(\n        bytes32 dapiName\n    )\n        external\n        view\n        returns (\n            bytes memory dataFeedDetails,\n            int224 dapiValue,\n            uint32 dapiTimestamp,\n            int224[] memory beaconValues,\n            uint32[] memory beaconTimestamps,\n            bytes[] memory updateParameters,\n            uint32[] memory endTimestamps,\n            uint224[] memory dailyPrices\n        );\n\n    function getDataFeedData(\n        bytes32 dataFeedId\n    )\n        external\n        view\n        returns (\n            bytes memory dataFeedDetails,\n            int224 dataFeedValue,\n            uint32 dataFeedTimestamp,\n            int224[] memory beaconValues,\n            uint32[] memory beaconTimestamps\n        );\n\n    function subscriptionIdToUpdateParameters(\n        bytes32 subscriptionId\n    ) external view returns (bytes memory updateParameters);\n\n    function MAXIMUM_SUBSCRIPTION_QUEUE_LENGTH()\n        external\n        view\n        returns (uint256);\n\n    function DAPI_MANAGEMENT_MERKLE_ROOT_HASH_TYPE()\n        external\n        view\n        returns (bytes32);\n\n    function DAPI_PRICING_MERKLE_ROOT_HASH_TYPE()\n        external\n        view\n        returns (bytes32);\n\n    function SIGNED_API_URL_MERKLE_ROOT_HASH_TYPE()\n        external\n        view\n        returns (bytes32);\n\n    function MAXIMUM_DAPI_UPDATE_AGE() external view returns (uint256);\n\n    function api3ServerV1() external view returns (address);\n\n    function proxyFactory() external view returns (address);\n\n    function airseekerRegistry() external view returns (address);\n\n    function subscriptions(\n        bytes32 subscriptionId\n    )\n        external\n        view\n        returns (\n            bytes32 updateParametersHash,\n            uint32 endTimestamp,\n            uint224 dailyPrice,\n            bytes32 nextSubscriptionId\n        );\n\n    function dapiNameToCurrentSubscriptionId(\n        bytes32 dapiName\n    ) external view returns (bytes32 currentSubscriptionId);\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IApi3ServerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IOevDapiServer.sol\";\nimport \"./IBeaconUpdatesWithSignedData.sol\";\n\ninterface IApi3ServerV1 is IOevDapiServer, IBeaconUpdatesWithSignedData {\n    function readDataFeedWithId(\n        bytes32 dataFeedId\n    ) external view returns (int224 value, uint32 timestamp);\n\n    function readDataFeedWithDapiNameHash(\n        bytes32 dapiNameHash\n    ) external view returns (int224 value, uint32 timestamp);\n\n    function readDataFeedWithIdAsOevProxy(\n        bytes32 dataFeedId\n    ) external view returns (int224 value, uint32 timestamp);\n\n    function readDataFeedWithDapiNameHashAsOevProxy(\n        bytes32 dapiNameHash\n    ) external view returns (int224 value, uint32 timestamp);\n\n    function dataFeeds(\n        bytes32 dataFeedId\n    ) external view returns (int224 value, uint32 timestamp);\n\n    function oevProxyToIdToDataFeed(\n        address proxy,\n        bytes32 dataFeedId\n    ) external view returns (int224 value, uint32 timestamp);\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IBeaconUpdatesWithSignedData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IDataFeedServer.sol\";\n\ninterface IBeaconUpdatesWithSignedData is IDataFeedServer {\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 templateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bytes32 beaconId);\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IDapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../access/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\nimport \"./IDataFeedServer.sol\";\n\ninterface IDapiServer is\n    IAccessControlRegistryAdminnedWithManager,\n    IDataFeedServer\n{\n    event SetDapiName(\n        bytes32 indexed dataFeedId,\n        bytes32 indexed dapiName,\n        address sender\n    );\n\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId) external;\n\n    function dapiNameToDataFeedId(\n        bytes32 dapiName\n    ) external view returns (bytes32);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DAPI_NAME_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    function dapiNameSetterRole() external view returns (bytes32);\n\n    function dapiNameHashToDataFeedId(\n        bytes32 dapiNameHash\n    ) external view returns (bytes32 dataFeedId);\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IDataFeedServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../utils/interfaces/IExtendedSelfMulticall.sol\";\n\ninterface IDataFeedServer is IExtendedSelfMulticall {\n    event UpdatedBeaconWithSignedData(\n        bytes32 indexed beaconId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedBeaconSetWithBeacons(\n        bytes32 indexed beaconSetId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    function updateBeaconSetWithBeacons(\n        bytes32[] memory beaconIds\n    ) external returns (bytes32 beaconSetId);\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IOevAuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../access/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\ninterface IOevAuctionHouse is IAccessControlRegistryAdminnedWithManager {\n    enum BidStatus {\n        None,\n        Placed,\n        Awarded,\n        FulfillmentReported,\n        FulfillmentConfirmed,\n        FulfillmentContradicted\n    }\n\n    event SetCollateralInBasisPoints(uint256 collateralInBasisPoints);\n\n    event SetProtocolFeeInBasisPoints(uint256 protocolFeeInBasisPoints);\n\n    event SetCollateralRateProxy(address collateralRateProxy);\n\n    event SetChainNativeCurrencyRateProxy(\n        uint256 indexed chainId,\n        address nativeCurrencyRateProxy\n    );\n\n    event WithdrewAccumulatedSlashedCollateral(\n        address recipient,\n        uint256 amount\n    );\n\n    event WithdrewAccumulatedProtocolFees(address recipient, uint256 amount);\n\n    event Deposited(\n        address indexed bidder,\n        uint256 amount,\n        uint256 bidderBalance,\n        address sender\n    );\n\n    event InitiatedWithdrawal(\n        address indexed bidder,\n        uint256 earliestWithdrawalTimestamp\n    );\n\n    event Withdrew(address indexed bidder, address recipient, uint256 amount);\n\n    event CanceledWithdrawal(address indexed bidder);\n\n    event PlacedBid(\n        address indexed bidder,\n        bytes32 indexed bidTopic,\n        bytes32 indexed bidId,\n        uint256 chainId,\n        uint256 bidAmount,\n        bytes bidDetails,\n        uint32 expirationTimestamp,\n        uint104 collateralAmount,\n        uint104 protocolFeeAmount\n    );\n\n    event ExpeditedBidExpiration(\n        address indexed bidder,\n        bytes32 indexed bidTopic,\n        bytes32 indexed bidId,\n        uint32 expirationTimestamp\n    );\n\n    event AwardedBid(\n        address indexed bidder,\n        bytes32 indexed bidTopic,\n        bytes32 indexed bidId,\n        bytes awardDetails,\n        uint256 bidderBalance\n    );\n\n    event ReportedFulfillment(\n        address indexed bidder,\n        bytes32 indexed bidTopic,\n        bytes32 indexed bidId,\n        bytes fulfillmentDetails\n    );\n\n    event ConfirmedFulfillment(\n        address indexed bidder,\n        bytes32 indexed bidTopic,\n        bytes32 indexed bidId,\n        uint256 bidderBalance,\n        uint256 accumulatedProtocolFees\n    );\n\n    event ContradictedFulfillment(\n        address indexed bidder,\n        bytes32 indexed bidTopic,\n        bytes32 indexed bidId,\n        uint256 bidderBalance,\n        uint256 accumulatedSlashedCollateral\n    );\n\n    error SenderIsNotTheManager();\n\n    error SenderIsNotAProxySetterOrTheManager();\n\n    error SenderIsNotAWithdrawerOrTheManager();\n\n    error SenderIsNotAnAuctioneer();\n\n    error ProxyAddressIsZero();\n\n    error ChainIdIsZero();\n\n    error RecipientAddressIsZero();\n\n    error WithdrawalAmountIsZero();\n\n    error InsufficientBalance();\n\n    error BidderAddressIsZero();\n\n    error DepositAmountIsZero();\n\n    error BidderHasAlreadyInitiatedWithdrawal();\n\n    error SenderHasNotInitiatedWithdrawal();\n\n    error BidderCannotWithdrawYet();\n\n    error BidAmountIsZero();\n\n    error BidDetailsAreEmpty();\n\n    error MaximumBidderDataLengthIsExceeded();\n\n    error BidLifetimeIsLongerThanMaximum();\n\n    error BidLifetimeIsShorterThanMinimum();\n\n    error BidIsAlreadyPlaced();\n\n    error MaxCollateralAmountIsExceeded();\n\n    error MaxProtocolFeeAmountIsExceeded();\n\n    error BidIsNotAwaitingAward();\n\n    error BidHasExpired();\n\n    error TimestampDoesNotExpediteExpiration();\n\n    error MaximumAuctioneerDataLengthIsExceeded();\n\n    error AwardDetailsAreEmpty();\n\n    error AwardHasExpired();\n\n    error BidderBalanceIsLowerThanTheLockedAmount();\n\n    error FulfillmentDetailsAreEmpty();\n\n    error BidIsNotAwaitingFulfillmentReport();\n\n    error BidFulfillmentCannotBeConfirmed();\n\n    error BidFulfillmentCannotBeContradicted();\n\n    error CollateralRateIsNotPositive();\n\n    error CollateralRateIsStale();\n\n    error NativeCurrencyRateIsNotPositive();\n\n    error NativeCurrencyRateIsStale();\n\n    function setProtocolFeeInBasisPoints(\n        uint256 protocolFeeInBasisPoints_\n    ) external;\n\n    function setCollateralInBasisPoints(\n        uint256 collateralInBasisPoints_\n    ) external;\n\n    function setCollateralRateProxy(address collateralRateProxy_) external;\n\n    function setChainNativeCurrencyRateProxy(\n        uint256 chainId,\n        address nativeCurrencyRateProxy\n    ) external;\n\n    function withdrawAccumulatedSlashedCollateral(\n        address payable recipient,\n        uint256 amount\n    ) external;\n\n    function withdrawAccumulatedProtocolFees(\n        address payable recipient,\n        uint256 amount\n    ) external;\n\n    function depositForBidder(\n        address bidder\n    ) external payable returns (uint256 bidderBalance);\n\n    function deposit() external payable returns (uint256 bidderBalance);\n\n    function initiateWithdrawal()\n        external\n        returns (uint256 earliestWithdrawalTimestamp);\n\n    function withdraw(address payable recipient, uint256 amount) external;\n\n    function cancelWithdrawal() external;\n\n    function placeBidWithExpiration(\n        bytes32 bidTopic,\n        uint256 chainId,\n        uint256 bidAmount,\n        bytes calldata bidDetails,\n        uint256 maxCollateralAmount,\n        uint256 maxProtocolFeeAmount,\n        uint32 expirationTimestamp\n    ) external returns (uint104 collateralAmount, uint104 protocolFeeAmount);\n\n    function placeBid(\n        bytes32 bidTopic,\n        uint256 chainId,\n        uint256 bidAmount,\n        bytes calldata bidDetails,\n        uint256 maxCollateralAmount,\n        uint256 maxProtocolFeeAmount\n    )\n        external\n        returns (\n            uint32 expirationTimestamp,\n            uint104 collateralAmount,\n            uint104 protocolFeeAmount\n        );\n\n    function expediteBidExpiration(\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash,\n        uint32 expirationTimestamp\n    ) external;\n\n    function expediteBidExpirationMaximally(\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash\n    ) external returns (uint32 expirationTimestamp);\n\n    function awardBid(\n        address bidder,\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash,\n        bytes calldata awardDetails,\n        uint256 awardExpirationTimestamp\n    ) external returns (uint256 bidderBalance);\n\n    function reportFulfillment(\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash,\n        bytes calldata fulfillmentDetails\n    ) external;\n\n    function confirmFulfillment(\n        address bidder,\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash\n    )\n        external\n        returns (uint256 bidderBalance, uint256 accumulatedProtocolFees_);\n\n    function contradictFulfillment(\n        address bidder,\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash\n    )\n        external\n        returns (uint256 bidderBalance, uint256 accumulatedSlashedCollateral_);\n\n    function getCurrentCollateralAndProtocolFeeAmounts(\n        uint256 chainId,\n        uint256 bidAmount\n    )\n        external\n        view\n        returns (uint104 collateralAmount, uint104 protocolFeeAmount);\n\n    function PROXY_SETTER_ROLE_DESCRIPTION() external returns (string memory);\n\n    function WITHDRAWER_ROLE_DESCRIPTION() external returns (string memory);\n\n    function AUCTIONEER_ROLE_DESCRIPTION() external returns (string memory);\n\n    function WITHDRAWAL_WAITING_PERIOD() external returns (uint256);\n\n    function MAXIMUM_BID_LIFETIME() external returns (uint256);\n\n    function MINIMUM_BID_LIFETIME() external returns (uint256);\n\n    function FULFILLMENT_REPORTING_PERIOD() external returns (uint256);\n\n    function MAXIMUM_BIDDER_DATA_LENGTH() external returns (uint256);\n\n    function MAXIMUM_AUCTIONEER_DATA_LENGTH() external returns (uint256);\n\n    function proxySetterRole() external returns (bytes32);\n\n    function withdrawerRole() external returns (bytes32);\n\n    function auctioneerRole() external returns (bytes32);\n\n    function protocolFeeInBasisPoints() external returns (uint256);\n\n    function collateralInBasisPoints() external returns (uint256);\n\n    function collateralRateProxy() external returns (address);\n\n    function chainIdToNativeCurrencyRateProxy(\n        uint256 chainId\n    ) external returns (address nativeCurrencyRateProxy);\n\n    function accumulatedSlashedCollateral() external returns (uint256);\n\n    function accumulatedProtocolFees() external returns (uint256);\n\n    function bidderToBalance(address bidder) external returns (uint256 balance);\n\n    function bidderToEarliestWithdrawalTimestamp(\n        address bidder\n    ) external returns (uint256 earliestWithdrawalTimestamp);\n\n    function bids(\n        bytes32 bidId\n    )\n        external\n        returns (\n            BidStatus status,\n            uint32 expirationTimestamp,\n            uint104 collateralAmount,\n            uint104 protocolFeeAmount\n        );\n}\n"
    },
    "contracts/api3-server-v1/interfaces/IOevDapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IOevDataFeedServer.sol\";\nimport \"./IDapiServer.sol\";\n\ninterface IOevDapiServer is IOevDataFeedServer, IDapiServer {}\n"
    },
    "contracts/api3-server-v1/interfaces/IOevDataFeedServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IDataFeedServer.sol\";\n\ninterface IOevDataFeedServer is IDataFeedServer {\n    event UpdatedOevProxyBeaconWithSignedData(\n        bytes32 indexed beaconId,\n        address indexed proxy,\n        bytes32 indexed updateId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedOevProxyBeaconSetWithSignedData(\n        bytes32 indexed beaconSetId,\n        address indexed proxy,\n        bytes32 indexed updateId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event Withdrew(\n        address indexed oevProxy,\n        address oevBeneficiary,\n        uint256 amount\n    );\n\n    function updateOevProxyDataFeedWithSignedData(\n        address oevProxy,\n        bytes32 dataFeedId,\n        bytes32 updateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes[] calldata packedOevUpdateSignatures\n    ) external payable;\n\n    function withdraw(address oevProxy) external;\n\n    function oevProxyToBalance(\n        address oevProxy\n    ) external view returns (uint256 balance);\n}\n"
    },
    "contracts/api3-server-v1/OevAuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../access/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"./interfaces/IOevAuctionHouse.sol\";\nimport \"./proxies/interfaces/IProxy.sol\";\n\n/// @title OEV Auction House contract\n/// @notice OEV is a subset of MEV that oracles have exclusive priority of\n/// extraction. API3 holds OEV auctions for its data feed services and forwards\n/// the proceeds to the respective user dApps. OevAuctionHouse is the platform\n/// that OEV searchers can bid on data feed updates that satisfy specific\n/// conditions, and report that they have fulfilled the updates that they are\n/// awarded. Refer to Api3ServerV1.sol for how the awarded updates are to be\n/// fulfilled and how the beneficiaries can withdraw the auction proceeds.\n/// @dev OevAuctionHouse is intended to be deployed on a single chain, while\n/// Api3ServerV1 (the API3 data feed contract) is deployed on the chains that\n/// the respective user dApps are deployed on. An OEV searcher bids on an\n/// update at OevAuctionHouse, gets the larger of the collateral and protocol\n/// fee locked up at OevAuctionHouse when they are awarded the update, fulfill\n/// the update and pay their bid amount at Api3ServerV1, and report back to\n/// OevAuctionHouse to have their locked funds released and the protocol fee\n/// charged. This flow implies the need for a certain kind of a cross-chain\n/// oracle functionality (to check if the awarded update is fulfilled), which\n/// is provided by the auctioneer role in this contract. The same auctioneer\n/// role is also assigned to award the individual updates to the winning bids.\n/// This means that the trustlessness of the auctions is limited by the\n/// trustlessness of the auctioneer implementation. Although trustlessness of\n/// OEV auctions is ideal, the primary goal of OevAuctionHouse is to facilitate\n/// auctions in a transparent and accountable manner.\ncontract OevAuctionHouse is\n    AccessControlRegistryAdminnedWithManager,\n    IOevAuctionHouse\n{\n    // The collateral and protocol fee amounts are denominated in the native\n    // currency of the chain that OevAuctionHouse is deployed on. In the case\n    // that this currency is ETH, the variable sizes below for collateral and\n    // protocol fee are expected to be sufficient.\n    struct Bid {\n        BidStatus status;\n        uint32 expirationTimestamp;\n        uint104 collateralAmount;\n        uint104 protocolFeeAmount;\n    }\n\n    /// @notice Proxy setter role description\n    string public constant override PROXY_SETTER_ROLE_DESCRIPTION =\n        \"Proxy setter\";\n\n    /// @notice Withdrawer role description\n    string public constant override WITHDRAWER_ROLE_DESCRIPTION = \"Withdrawer\";\n\n    /// @notice Auctioneer role description\n    string public constant override AUCTIONEER_ROLE_DESCRIPTION = \"Auctioneer\";\n\n    /// @notice Amount of time that the bidders are required to wait after\n    /// initiating a withdrawal to execute it\n    /// @dev This is enforced to prevent the bidders from frontrunning bid\n    /// awarding transactions with withdrawals to deny service\n    uint256 public constant override WITHDRAWAL_WAITING_PERIOD = 15 seconds;\n\n    /// @notice Longest period during which a bid can be awarded after it has\n    /// been placed\n    /// @dev Considering each bid for each auction incurs a (computational,\n    /// network, etc.) cost to the auctioneer, the bids need to automatically\n    /// fall out of scope over time or they will eventually accumulate to an\n    /// unmanageable amount\n    uint256 public constant override MAXIMUM_BID_LIFETIME = 1 days;\n\n    /// @notice Minimum lifetime that a bid can be specified to have\n    /// @dev This is enforced to prevent bidders from frontrunning bid awarding\n    /// transactions with bid expiration expedition transactions to deny\n    /// service\n    uint256 public constant override MINIMUM_BID_LIFETIME = 15 seconds;\n\n    /// @notice Period during which a bidder is allowed to report the\n    /// fulfillment after the bid award\n    /// @dev The bidder should execute the won update in a matter of seconds,\n    /// and the fulfillment report can follow right after. However, the\n    /// fulfillment reporting period is kept long enough to accomodate for a\n    /// more relaxed workflow, e.g., the bidder multi-calls their fulfillment\n    /// reports every hour.\n    uint256 public constant override FULFILLMENT_REPORTING_PERIOD = 1 days;\n\n    /// @notice Maximum data length that a bidder can submit while placing a\n    /// bid or reporting a fulfillment\n    uint256 public constant override MAXIMUM_BIDDER_DATA_LENGTH = 1024;\n\n    /// @notice Maximum data length that an auctioneer can submit while\n    /// awarding a bid\n    uint256 public constant override MAXIMUM_AUCTIONEER_DATA_LENGTH = 8192;\n\n    /// @notice Proxy setter role\n    bytes32 public immutable override proxySetterRole;\n\n    /// @notice Withdrawer role\n    bytes32 public immutable override withdrawerRole;\n\n    /// @notice Auctioneer role\n    bytes32 public immutable override auctioneerRole;\n\n    /// @notice Collateral requirement in relation to the bid amount in basis\n    /// points\n    /// @dev The collateral requirement can range from 0% to values larger than\n    /// 100%. This is because one can hypothesize cases where denying service\n    /// by being slashed by the full bid amount is still profitable, in which\n    /// case a collateral requirement that is larger than 100% would be\n    /// justifiable.\n    uint256 public override collateralInBasisPoints;\n\n    /// @notice Protocol fee in relation to the bid amount in basis points\n    /// @dev The protocol fee is not necessarily bounded by the bid amount,\n    /// which means that this value is not necessarily bounded by 100%\n    uint256 public override protocolFeeInBasisPoints;\n\n    /// @notice Data feed proxy address for the collateral rate\n    /// @dev The collateral is denominated in the native currency of the chain\n    /// that OevAuctionHouse is deployed on. Bid amounts are specified and paid\n    /// in the native currency of the chain that the dApp (from which OEV is\n    /// being extracted from) is deployed on. This means that a common base is\n    /// needed for the collateral rate and the native currency rates. For\n    /// example, if the collateral rate proxy provides the ETH/USD rate, the\n    /// native currency rate proxies should provide */USD rates.\n    address public override collateralRateProxy;\n\n    /// @notice Data feed proxy address for the native currency of the chain\n    /// with the ID\n    mapping(uint256 => address)\n        public\n        override chainIdToNativeCurrencyRateProxy;\n\n    /// @notice Accumulated collateral funds slashed by auctioneers by\n    /// contradicting fulfillments\n    uint256 public override accumulatedSlashedCollateral;\n\n    /// @notice Accumulated protocol fees charged by auctioneers by confirming\n    /// fulfillments\n    uint256 public override accumulatedProtocolFees;\n\n    /// @notice Deposited funds of the bidder, excluding the amount that is\n    /// currently locked up for awarded bids awaiting fulfillment confirmation\n    mapping(address => uint256) public override bidderToBalance;\n\n    /// @notice Earliest time that the bidder can execute the initiated\n    /// withdrawal. A timestamp of zero means that there is no ongoing\n    /// withdrawal.\n    mapping(address => uint256)\n        public\n        override bidderToEarliestWithdrawalTimestamp;\n\n    /// @notice Status, expiration timestamp, collateral amount and protocol\n    /// fee amount of the bid with ID\n    mapping(bytes32 => Bid) public override bids;\n\n    uint256 private constant HUNDRED_PERCENT_IN_BASIS_POINTS = 100 * 100;\n\n    uint256 private constant MAXIMUM_RATE_AGE = 1 days;\n\n    /// @dev Reverts if the sender is not the contract manager\n    modifier onlyManager() {\n        if (msg.sender != manager) revert SenderIsNotTheManager();\n        _;\n    }\n\n    /// @dev Reverts if the sender is not a proxy setter or the contract\n    /// manager\n    modifier onlyProxySetterOrManager() {\n        if (\n            !IAccessControlRegistry(accessControlRegistry).hasRole(\n                proxySetterRole,\n                msg.sender\n            ) && msg.sender != manager\n        ) revert SenderIsNotAProxySetterOrTheManager();\n        _;\n    }\n\n    /// @dev Reverts if the sender is not a withdrawer or the contract manager\n    modifier onlyWithdrawerOrManager() {\n        if (\n            !IAccessControlRegistry(accessControlRegistry).hasRole(\n                withdrawerRole,\n                msg.sender\n            ) && msg.sender != manager\n        ) revert SenderIsNotAWithdrawerOrTheManager();\n        _;\n    }\n\n    /// @dev Reverts if the sender is not an auctioneer\n    modifier onlyAuctioneer() {\n        if (\n            !IAccessControlRegistry(accessControlRegistry).hasRole(\n                auctioneerRole,\n                msg.sender\n            )\n        ) revert SenderIsNotAnAuctioneer();\n        _;\n    }\n\n    /// @dev Reverts if the withdrawal parameters are not valid\n    /// @param recipient Recipient address\n    /// @param amount Amount\n    modifier onlyValidWithdrawalParameters(\n        address payable recipient,\n        uint256 amount\n    ) {\n        if (recipient == address(0)) revert RecipientAddressIsZero();\n        if (amount == 0) revert WithdrawalAmountIsZero();\n        _;\n    }\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {\n        proxySetterRole = _deriveRole(\n            _deriveAdminRole(manager),\n            PROXY_SETTER_ROLE_DESCRIPTION\n        );\n        withdrawerRole = _deriveRole(\n            _deriveAdminRole(manager),\n            WITHDRAWER_ROLE_DESCRIPTION\n        );\n        auctioneerRole = _deriveRole(\n            _deriveAdminRole(manager),\n            AUCTIONEER_ROLE_DESCRIPTION\n        );\n    }\n\n    /// @notice Called by the manager to set the collateral requirement in\n    /// basis points\n    /// @dev The collateral requirement can range from 0% (0 in basis points)\n    /// to values larger than 100% (10000 in basis points).\n    /// The contract manager is recommended to tune this parameter to maximize\n    /// the extracted OEV. The optimal value will be defined by bidder behavior\n    /// and may change over time.\n    /// In the absence of additional incentives (e.g., a reputation system that\n    /// refers to confirmed fulfillments), a collateral requirement that is not\n    /// larger than the protocol fee may result in fulfillments going\n    /// unreported (as being slashed would not be more punitive than being\n    /// charged the protocol fee).\n    /// @param collateralInBasisPoints_ Collateral requirement in basis points\n    function setCollateralInBasisPoints(\n        uint256 collateralInBasisPoints_\n    ) external override onlyManager {\n        collateralInBasisPoints = collateralInBasisPoints_;\n        emit SetCollateralInBasisPoints(collateralInBasisPoints_);\n    }\n\n    /// @notice Called by the manager to set the protocol fee in basis points\n    /// @dev The protocol fee can range from 0% (0 in basis points) to values\n    /// larger than 100% (10000 in basis points)\n    /// @param protocolFeeInBasisPoints_ Protocol fee in basis points\n    function setProtocolFeeInBasisPoints(\n        uint256 protocolFeeInBasisPoints_\n    ) external override onlyManager {\n        protocolFeeInBasisPoints = protocolFeeInBasisPoints_;\n        emit SetProtocolFeeInBasisPoints(protocolFeeInBasisPoints_);\n    }\n\n    /// @notice Sets collateral rate proxy\n    /// @dev The data feed proxy contract is expected to implement the IProxy\n    /// interface and the respective data feed to be active with at most a\n    /// 1-day heartbeat interval. Only use trusted contracts (e.g., contracts\n    /// deployed by API3's ProxyFactory) to avoid reentrancy risks.\n    /// The collateral rate denomination must match the native curreny rate\n    /// denomination, e.g., if the collateral rate is in the form of ETH/USD,\n    /// the native currency rates should be in the form of */USD.\n    /// @param collateralRateProxy_ Collateral rate proxy address\n    function setCollateralRateProxy(\n        address collateralRateProxy_\n    ) external override onlyProxySetterOrManager {\n        if (collateralRateProxy_ == address(0)) revert ProxyAddressIsZero();\n        collateralRateProxy = collateralRateProxy_;\n        emit SetCollateralRateProxy(collateralRateProxy_);\n    }\n\n    /// @notice Sets native currency rate proxy for the chain with ID\n    /// @dev The data feed proxy contract is expected to implement the IProxy\n    /// interface and the respective data feed to be active with at most a\n    /// 1-day heartbeat interval. Only use trusted contracts (e.g., contracts\n    /// deployed by API3's ProxyFactory) to avoid reentrancy risks.\n    /// The collateral rate denomination must match the native curreny rate\n    /// denomination, e.g., if the collateral rate is in the form of ETH/USD,\n    /// the native currency rates should be in the form of */USD.\n    /// @param chainId Chain ID\n    /// @param nativeCurrencyRateProxy Native currency rate proxy address\n    function setChainNativeCurrencyRateProxy(\n        uint256 chainId,\n        address nativeCurrencyRateProxy\n    ) external override onlyProxySetterOrManager {\n        if (chainId == 0) revert ChainIdIsZero();\n        if (nativeCurrencyRateProxy == address(0)) revert ProxyAddressIsZero();\n        chainIdToNativeCurrencyRateProxy[chainId] = nativeCurrencyRateProxy;\n        emit SetChainNativeCurrencyRateProxy(chainId, nativeCurrencyRateProxy);\n    }\n\n    /// @notice Called by the contract manager to withdraw the accumulated\n    /// collateral slashed by auctioneers by contradicting fulfillments\n    /// @param recipient Recipient address\n    /// @param amount Amount\n    function withdrawAccumulatedSlashedCollateral(\n        address payable recipient,\n        uint256 amount\n    )\n        external\n        override\n        onlyWithdrawerOrManager\n        onlyValidWithdrawalParameters(recipient, amount)\n    {\n        if (amount > accumulatedSlashedCollateral) revert InsufficientBalance();\n        accumulatedSlashedCollateral -= amount;\n        emit WithdrewAccumulatedSlashedCollateral(recipient, amount);\n        sendValue(recipient, amount);\n    }\n\n    /// @notice Called by the contract manager to withdraw the accumulated\n    /// protocol fees charged by auctioneers by confirming fulfillments\n    /// @param recipient Recipient address\n    /// @param amount Amount\n    function withdrawAccumulatedProtocolFees(\n        address payable recipient,\n        uint256 amount\n    )\n        external\n        override\n        onlyWithdrawerOrManager\n        onlyValidWithdrawalParameters(recipient, amount)\n    {\n        if (amount > accumulatedProtocolFees) revert InsufficientBalance();\n        accumulatedProtocolFees -= amount;\n        emit WithdrewAccumulatedProtocolFees(recipient, amount);\n        sendValue(recipient, amount);\n    }\n\n    /// @notice Called to deposit funds for a bidder\n    /// @param bidder Bidder address\n    /// @return bidderBalance Bidder balance after the deposit\n    function depositForBidder(\n        address bidder\n    ) public payable override returns (uint256 bidderBalance) {\n        if (bidder == address(0)) revert BidderAddressIsZero();\n        if (msg.value == 0) revert DepositAmountIsZero();\n        bidderBalance = bidderToBalance[bidder] + msg.value;\n        bidderToBalance[bidder] = bidderBalance;\n        emit Deposited(bidder, msg.value, bidderBalance, msg.sender);\n    }\n\n    /// @notice Called by the bidder to deposit funds\n    /// @return bidderBalance Bidder balance after the deposit\n    function deposit()\n        external\n        payable\n        override\n        returns (uint256 bidderBalance)\n    {\n        bidderBalance = depositForBidder(msg.sender);\n    }\n\n    /// @notice Called by the bidder to initiate a withdrawal of their funds\n    /// @dev A two-step withdrawal process is implemented to prevent the\n    /// bidders from frontrunning bid awarding transactions with withdrawals to\n    /// deny service\n    /// @return earliestWithdrawalTimestamp Earliest time that the bidder can\n    /// execute the initiated withdrawal\n    function initiateWithdrawal()\n        external\n        override\n        returns (uint256 earliestWithdrawalTimestamp)\n    {\n        if (bidderToEarliestWithdrawalTimestamp[msg.sender] != 0)\n            revert BidderHasAlreadyInitiatedWithdrawal();\n        earliestWithdrawalTimestamp =\n            block.timestamp +\n            WITHDRAWAL_WAITING_PERIOD;\n        bidderToEarliestWithdrawalTimestamp[\n            msg.sender\n        ] = earliestWithdrawalTimestamp;\n        emit InitiatedWithdrawal(msg.sender, earliestWithdrawalTimestamp);\n    }\n\n    /// @notice Called by the bidder to execute a withdrawal that they have\n    /// initiated\n    /// @param recipient Recipient address\n    /// @param amount Amount\n    function withdraw(\n        address payable recipient,\n        uint256 amount\n    ) external override onlyValidWithdrawalParameters(recipient, amount) {\n        uint256 balance = bidderToBalance[msg.sender];\n        if (amount > balance) revert InsufficientBalance();\n        uint256 earliestWithdrawalTimestamp = bidderToEarliestWithdrawalTimestamp[\n                msg.sender\n            ];\n        if (earliestWithdrawalTimestamp == 0)\n            revert SenderHasNotInitiatedWithdrawal();\n        if (block.timestamp < earliestWithdrawalTimestamp)\n            revert BidderCannotWithdrawYet();\n        bidderToBalance[msg.sender] = balance - amount;\n        bidderToEarliestWithdrawalTimestamp[msg.sender] = 0;\n        emit Withdrew(msg.sender, recipient, amount);\n        sendValue(recipient, amount);\n    }\n\n    /// @notice Called by the bidder to cancel a withdrawal that they have\n    /// initiated\n    function cancelWithdrawal() external override {\n        if (bidderToEarliestWithdrawalTimestamp[msg.sender] == 0)\n            revert SenderHasNotInitiatedWithdrawal();\n        bidderToEarliestWithdrawalTimestamp[msg.sender] = 0;\n        emit CanceledWithdrawal(msg.sender);\n    }\n\n    /// @notice Called to place a bid with an expiration timestamp. Searchers\n    /// should use this over `placeBid()` if they expect the OEV opportunity to\n    /// disappear at a specific time before the maximum bid lifetime.\n    /// The searcher should determine maximum collateral and protocol fees that\n    /// they will tolerate, and specify them in the arguments.\n    /// Upon the awarding of the bid, the larger of the collateral amount and\n    /// protocol fee amount will be locked. Upon confirmation or contradiction\n    /// of the respective fulfillment, the locked amount will be released, and\n    /// the protocol fee will be charged or the collateral amount will be\n    /// slashed, respectively.\n    /// @dev `bidTopic` is an arbitrary identifier of the bid type.\n    /// `bidDetails` is an arbitrary description of the bid details. Refer to\n    /// the documentation that the auctioneer provides for the bidders for how\n    /// these parameters should be set.\n    /// @param bidTopic Bid topic\n    /// @param chainId Chain ID\n    /// @param bidAmount Bid amount in the native currency of the chain with ID\n    /// @param bidDetails Bid details\n    /// @param maxCollateralAmount Maximum collateral amount in the currency of\n    /// the chain that OevAuctionHouse is deployed on\n    /// @param maxProtocolFeeAmount Maximum protocol fee amount in the currency\n    /// of the chain that OevAuctionHouse is deployed on\n    /// @param expirationTimestamp Expiration timestamp after which the bid\n    /// cannot be awarded\n    /// @return collateralAmount Collateral amount in the currency of the chain\n    /// that OevAuctionHouse is deployed on\n    /// @return protocolFeeAmount Protocol fee amount in the currency of the\n    /// chain that OevAuctionHouse is deployed on\n    function placeBidWithExpiration(\n        bytes32 bidTopic,\n        uint256 chainId,\n        uint256 bidAmount,\n        bytes calldata bidDetails,\n        uint256 maxCollateralAmount,\n        uint256 maxProtocolFeeAmount,\n        uint32 expirationTimestamp\n    )\n        public\n        override\n        returns (uint104 collateralAmount, uint104 protocolFeeAmount)\n    {\n        if (chainId == 0) revert ChainIdIsZero();\n        if (bidAmount == 0) revert BidAmountIsZero();\n        uint256 bidDetailsLength = bidDetails.length;\n        if (bidDetailsLength > MAXIMUM_BIDDER_DATA_LENGTH)\n            revert MaximumBidderDataLengthIsExceeded();\n        if (bidDetailsLength == 0) revert BidDetailsAreEmpty();\n        if (block.timestamp + MAXIMUM_BID_LIFETIME < expirationTimestamp)\n            revert BidLifetimeIsLongerThanMaximum();\n        if (block.timestamp + MINIMUM_BID_LIFETIME > expirationTimestamp)\n            revert BidLifetimeIsShorterThanMinimum();\n        // The bid details should be specified to include a salt field to allow\n        // bids that otherwise would have identical IDs\n        bytes32 bidId = keccak256(\n            abi.encodePacked(msg.sender, bidTopic, keccak256(bidDetails))\n        );\n        if (bids[bidId].status != BidStatus.None) revert BidIsAlreadyPlaced();\n        (\n            collateralAmount,\n            protocolFeeAmount\n        ) = getCurrentCollateralAndProtocolFeeAmounts(chainId, bidAmount);\n        if (collateralAmount > maxCollateralAmount)\n            revert MaxCollateralAmountIsExceeded();\n        if (protocolFeeAmount > maxProtocolFeeAmount)\n            revert MaxProtocolFeeAmountIsExceeded();\n        bids[bidId] = Bid({\n            status: BidStatus.Placed,\n            expirationTimestamp: expirationTimestamp,\n            collateralAmount: collateralAmount,\n            protocolFeeAmount: protocolFeeAmount\n        });\n        emit PlacedBid(\n            msg.sender,\n            bidTopic,\n            bidId,\n            chainId,\n            bidAmount,\n            bidDetails,\n            expirationTimestamp,\n            collateralAmount,\n            protocolFeeAmount\n        );\n    }\n\n    /// @notice Called to place a bid with the longest possible lifetime.\n    /// The searcher should determine maximum collateral and protocol fees that\n    /// they will tolerate, and specify them in the arguments.\n    /// Upon the awarding of the bid, the larger of the collateral amount and\n    /// protocol fee amount will be locked. Upon confirmation or contradiction\n    /// of the respective fulfillment, the locked amount will be released, and\n    /// the protocol fee will be charged or the collateral amount will be\n    /// slashed, respectively.\n    /// @param bidTopic Bid topic\n    /// @param chainId Chain ID\n    /// @param bidAmount Bid amount in the native currency of the chain with ID\n    /// @param bidDetails Bid details\n    /// @param maxCollateralAmount Maximum collateral amount in the currency of\n    /// the chain that OevAuctionHouse is deployed on\n    /// @param maxProtocolFeeAmount Maximum protocol fee amount in the currency\n    /// of the chain that OevAuctionHouse is deployed on\n    /// @return expirationTimestamp Expiration timestamp after which the bid\n    /// cannot be awarded\n    /// @return collateralAmount Collateral amount in the currency of the chain\n    /// that OevAuctionHouse is deployed on\n    /// @return protocolFeeAmount Protocol fee amount in the currency of the\n    /// chain that OevAuctionHouse is deployed on\n    function placeBid(\n        bytes32 bidTopic,\n        uint256 chainId,\n        uint256 bidAmount,\n        bytes calldata bidDetails,\n        uint256 maxCollateralAmount,\n        uint256 maxProtocolFeeAmount\n    )\n        external\n        override\n        returns (\n            uint32 expirationTimestamp,\n            uint104 collateralAmount,\n            uint104 protocolFeeAmount\n        )\n    {\n        expirationTimestamp = uint32(block.timestamp + MAXIMUM_BID_LIFETIME);\n        (collateralAmount, protocolFeeAmount) = placeBidWithExpiration(\n            bidTopic,\n            chainId,\n            bidAmount,\n            bidDetails,\n            maxCollateralAmount,\n            maxProtocolFeeAmount,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called to update the bid expiration timestamp to a specific\n    /// value to expedite its expiration\n    /// @param bidTopic Bid topic\n    /// @param bidDetailsHash Bid details hash\n    /// @param expirationTimestamp Expiration timestamp after which the bid\n    /// cannot be awarded\n    function expediteBidExpiration(\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash,\n        uint32 expirationTimestamp\n    ) public override {\n        bytes32 bidId = keccak256(\n            abi.encodePacked(msg.sender, bidTopic, bidDetailsHash)\n        );\n        Bid storage bid = bids[bidId];\n        if (bid.status != BidStatus.Placed) revert BidIsNotAwaitingAward();\n        uint32 bidExpirationTimestamp = bid.expirationTimestamp;\n        if (block.timestamp >= bidExpirationTimestamp) revert BidHasExpired();\n        if (expirationTimestamp >= bidExpirationTimestamp)\n            revert TimestampDoesNotExpediteExpiration();\n        if (block.timestamp + MINIMUM_BID_LIFETIME > expirationTimestamp)\n            revert BidLifetimeIsShorterThanMinimum();\n        bid.expirationTimestamp = expirationTimestamp;\n        emit ExpeditedBidExpiration(\n            msg.sender,\n            bidTopic,\n            bidId,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called to decrease the bid expiration timestamp as much as\n    /// possible to maximally expedite its expiration\n    /// @param bidTopic Bid topic\n    /// @param bidDetailsHash Bid details hash\n    /// @return expirationTimestamp Expiration timestamp after which the bid\n    /// cannot be awarded\n    function expediteBidExpirationMaximally(\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash\n    ) external override returns (uint32 expirationTimestamp) {\n        expirationTimestamp = uint32(block.timestamp + MINIMUM_BID_LIFETIME);\n        expediteBidExpiration(bidTopic, bidDetailsHash, expirationTimestamp);\n    }\n\n    /// @notice Called by an auctioneer to award the bid\n    /// @dev `awardDetails` is an arbitrary description of how to claim the\n    /// award. Refer to the documentation that the auctioneer provides for the\n    /// bidders for how to use it.\n    /// The bidder receiving `awardDetails` is typically time-critical.\n    /// However, the bid awarding transaction may not always be confirmed\n    /// immediately. To avoid unjust collateral lockups or slashings,\n    /// auctioneers should use an appropriate `awardExpirationTimestamp` that\n    /// will cause such transactions to revert.\n    /// @param bidder Bidder address\n    /// @param bidTopic Bid topic\n    /// @param bidDetailsHash Bid details hash\n    /// @param awardDetails Award details\n    /// @param awardExpirationTimestamp Award expiration timestamp\n    /// @return bidderBalance Bidder balance after the lockup\n    function awardBid(\n        address bidder,\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash,\n        bytes calldata awardDetails,\n        uint256 awardExpirationTimestamp\n    ) external override onlyAuctioneer returns (uint256 bidderBalance) {\n        uint256 awardDetailsLength = awardDetails.length;\n        if (awardDetailsLength > MAXIMUM_AUCTIONEER_DATA_LENGTH)\n            revert MaximumAuctioneerDataLengthIsExceeded();\n        if (awardDetailsLength == 0) revert AwardDetailsAreEmpty();\n        if (block.timestamp >= awardExpirationTimestamp)\n            revert AwardHasExpired();\n        bytes32 bidId = keccak256(\n            abi.encodePacked(bidder, bidTopic, bidDetailsHash)\n        );\n        Bid storage bid = bids[bidId];\n        if (bid.status != BidStatus.Placed) revert BidIsNotAwaitingAward();\n        if (block.timestamp >= bid.expirationTimestamp) revert BidHasExpired();\n        bid.status = BidStatus.Awarded;\n        // Refresh the expiration timestamp for the fulfillment report\n        bid.expirationTimestamp = uint32(\n            block.timestamp + FULFILLMENT_REPORTING_PERIOD\n        );\n        bidderBalance = bidderToBalance[bidder];\n        uint256 lockedAmount = bid.collateralAmount > bid.protocolFeeAmount\n            ? bid.collateralAmount\n            : bid.protocolFeeAmount;\n        if (bidderBalance < lockedAmount)\n            revert BidderBalanceIsLowerThanTheLockedAmount();\n        bidderBalance -= lockedAmount;\n        bidderToBalance[bidder] = bidderBalance;\n        emit AwardedBid(bidder, bidTopic, bidId, awardDetails, bidderBalance);\n    }\n\n    /// @notice Called by the owner of the awarded bid to report its\n    /// fulfillment\n    /// @dev `fulfillmentDetails` is an arbitrary description of how the\n    /// fulfillment is to be verified. Refer to the documentation that the\n    /// auctioneer provides for the bidders for how this parameter should be\n    /// set.\n    /// @param bidTopic Bid topic\n    /// @param bidDetailsHash Bid details hash\n    /// @param fulfillmentDetails Fulfillment details\n    function reportFulfillment(\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash,\n        bytes calldata fulfillmentDetails\n    ) external override {\n        uint256 fulfillmentDetailsLength = fulfillmentDetails.length;\n        if (fulfillmentDetailsLength > MAXIMUM_BIDDER_DATA_LENGTH)\n            revert MaximumBidderDataLengthIsExceeded();\n        if (fulfillmentDetailsLength == 0) revert FulfillmentDetailsAreEmpty();\n        bytes32 bidId = keccak256(\n            abi.encodePacked(msg.sender, bidTopic, bidDetailsHash)\n        );\n        Bid storage bid = bids[bidId];\n        if (bid.status != BidStatus.Awarded)\n            revert BidIsNotAwaitingFulfillmentReport();\n        if (block.timestamp >= bid.expirationTimestamp) revert BidHasExpired();\n        bid.status = BidStatus.FulfillmentReported;\n        emit ReportedFulfillment(\n            msg.sender,\n            bidTopic,\n            bidId,\n            fulfillmentDetails\n        );\n    }\n\n    /// @notice Called by an auctioneer to confirm a fulfillment, and release\n    /// the collateral and charge the protocol fee\n    /// @dev A fulfillment does not have to be reported to be confirmed. A bid\n    /// can be confirmed to be fulfilled even after it has expired.\n    /// @param bidder Bidder address\n    /// @param bidTopic Bid topic\n    /// @param bidDetailsHash Bid details hash\n    /// @return bidderBalance Bidder balance after the collateral release\n    /// @return accumulatedProtocolFees_ Accumulated protocol fees\n    function confirmFulfillment(\n        address bidder,\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash\n    )\n        external\n        override\n        onlyAuctioneer\n        returns (uint256 bidderBalance, uint256 accumulatedProtocolFees_)\n    {\n        bytes32 bidId = keccak256(\n            abi.encodePacked(bidder, bidTopic, bidDetailsHash)\n        );\n        Bid storage bid = bids[bidId];\n        if (\n            bid.status != BidStatus.FulfillmentReported &&\n            bid.status != BidStatus.Awarded\n        ) revert BidFulfillmentCannotBeConfirmed();\n        bid.status = BidStatus.FulfillmentConfirmed;\n        bidderBalance =\n            bidderToBalance[bidder] +\n            (\n                bid.collateralAmount > bid.protocolFeeAmount\n                    ? bid.collateralAmount\n                    : bid.protocolFeeAmount\n            ) -\n            bid.protocolFeeAmount;\n        bidderToBalance[bidder] = bidderBalance;\n        accumulatedProtocolFees_ =\n            accumulatedProtocolFees +\n            bid.protocolFeeAmount;\n        accumulatedProtocolFees = accumulatedProtocolFees_;\n        emit ConfirmedFulfillment(\n            bidder,\n            bidTopic,\n            bidId,\n            bidderBalance,\n            accumulatedProtocolFees_\n        );\n    }\n\n    /// @notice Called by an auctioneer to contradict a fulfillment, and slash\n    /// the collateral and release the protocol fee\n    /// @dev Fulfillments that have not been reported can only be contradicted\n    /// after the reporting period is over\n    /// @param bidder Bidder address\n    /// @param bidTopic Bid topic\n    /// @param bidDetailsHash Bid details hash\n    /// @return bidderBalance Bidder balance after the protocol fee release\n    /// @return accumulatedSlashedCollateral_ Accumulated slashed collateral\n    function contradictFulfillment(\n        address bidder,\n        bytes32 bidTopic,\n        bytes32 bidDetailsHash\n    )\n        external\n        override\n        onlyAuctioneer\n        returns (uint256 bidderBalance, uint256 accumulatedSlashedCollateral_)\n    {\n        bytes32 bidId = keccak256(\n            abi.encodePacked(bidder, bidTopic, bidDetailsHash)\n        );\n        Bid storage bid = bids[bidId];\n        BidStatus bidStatus = bid.status;\n        if (\n            bidStatus != BidStatus.FulfillmentReported &&\n            !(bidStatus == BidStatus.Awarded &&\n                block.timestamp >= bid.expirationTimestamp)\n        ) revert BidFulfillmentCannotBeContradicted();\n        bid.status = BidStatus.FulfillmentContradicted;\n        bidderBalance =\n            bidderToBalance[bidder] +\n            (\n                bid.collateralAmount > bid.protocolFeeAmount\n                    ? bid.collateralAmount\n                    : bid.protocolFeeAmount\n            ) -\n            bid.collateralAmount;\n        bidderToBalance[bidder] = bidderBalance;\n        accumulatedSlashedCollateral_ =\n            accumulatedSlashedCollateral +\n            bid.collateralAmount;\n        accumulatedSlashedCollateral = accumulatedSlashedCollateral_;\n        emit ContradictedFulfillment(\n            bidder,\n            bidTopic,\n            bidId,\n            bidderBalance,\n            accumulatedSlashedCollateral_\n        );\n    }\n\n    /// @notice Gets the collateral amount and the protocol fee amount for a\n    /// bid with the chain ID and amount parameters based on the current rates,\n    /// collateral requirement and protocol fee\n    /// @param chainId Chain ID\n    /// @param bidAmount Bid amount in the native currency of the chain with ID\n    /// @return collateralAmount Collateral amount in the currency of the chain\n    /// that OevAuctionHouse is deployed on\n    /// @return protocolFeeAmount Protocol fee amount in the currency of the\n    /// chain that OevAuctionHouse is deployed on\n    function getCurrentCollateralAndProtocolFeeAmounts(\n        uint256 chainId,\n        uint256 bidAmount\n    )\n        public\n        view\n        override\n        returns (uint104 collateralAmount, uint104 protocolFeeAmount)\n    {\n        (int224 collateralRateValue, uint32 collateralRateTimestamp) = IProxy(\n            collateralRateProxy\n        ).read();\n        if (collateralRateValue <= 0) revert CollateralRateIsNotPositive();\n        if (block.timestamp >= collateralRateTimestamp + MAXIMUM_RATE_AGE)\n            revert CollateralRateIsStale();\n        (\n            int224 nativeCurrencyRateValue,\n            uint32 nativeCurrencyRateTimestamp\n        ) = IProxy(chainIdToNativeCurrencyRateProxy[chainId]).read();\n        if (nativeCurrencyRateValue <= 0)\n            revert NativeCurrencyRateIsNotPositive();\n        if (block.timestamp >= nativeCurrencyRateTimestamp + MAXIMUM_RATE_AGE)\n            revert NativeCurrencyRateIsStale();\n        collateralAmount = safeCastToUint104(\n            (bidAmount *\n                uint256(int256(nativeCurrencyRateValue)) *\n                collateralInBasisPoints) /\n                uint256(int256(collateralRateValue)) /\n                HUNDRED_PERCENT_IN_BASIS_POINTS\n        );\n        protocolFeeAmount = safeCastToUint104(\n            (bidAmount *\n                uint256(int256(nativeCurrencyRateValue)) *\n                protocolFeeInBasisPoints) /\n                uint256(int256(collateralRateValue)) /\n                HUNDRED_PERCENT_IN_BASIS_POINTS\n        );\n    }\n\n    /// @notice Sends value to recipient\n    /// @dev In the contexts that this function is used, the balance will\n    /// always be sufficient and thus is not checked\n    /// @param recipient Recipient address\n    /// @param amount Amount to be sent\n    function sendValue(address payable recipient, uint256 amount) private {\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Transfer unsuccessful\");\n    }\n\n    /// @notice Safe-casts the value from uint256 to uint104\n    /// @param valueInUint256 Value in uint256\n    /// @return valueInUint104 Value safe-cast to uint256\n    function safeCastToUint104(\n        uint256 valueInUint256\n    ) private pure returns (uint104 valueInUint104) {\n        require(\n            valueInUint256 <= type(uint104).max,\n            \"Value does not fit in uint104\"\n        );\n        valueInUint104 = uint104(valueInUint256);\n    }\n}\n"
    },
    "contracts/api3-server-v1/OevDapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./OevDataFeedServer.sol\";\nimport \"./DapiServer.sol\";\nimport \"./interfaces/IOevDapiServer.sol\";\n\n/// @title Contract that serves OEV dAPIs\ncontract OevDapiServer is OevDataFeedServer, DapiServer, IOevDapiServer {\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    ) DapiServer(_accessControlRegistry, _adminRoleDescription, _manager) {}\n\n    /// @notice Reads the data feed as the OEV proxy with dAPI name hash\n    /// @param dapiNameHash dAPI name hash\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithDapiNameHashAsOevProxy(\n        bytes32 dapiNameHash\n    ) internal view returns (int224 value, uint32 timestamp) {\n        bytes32 dataFeedId = dapiNameHashToDataFeedId[dapiNameHash];\n        require(dataFeedId != bytes32(0), \"dAPI name not set\");\n        DataFeed storage oevDataFeed = _oevProxyToIdToDataFeed[msg.sender][\n            dataFeedId\n        ];\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        if (oevDataFeed.timestamp > dataFeed.timestamp) {\n            (value, timestamp) = (oevDataFeed.value, oevDataFeed.timestamp);\n        } else {\n            (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        }\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n}\n"
    },
    "contracts/api3-server-v1/OevDataFeedServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./DataFeedServer.sol\";\nimport \"./interfaces/IOevDataFeedServer.sol\";\nimport \"../vendor/@openzeppelin/contracts@4.8.2/utils/cryptography/ECDSA.sol\";\nimport \"./proxies/interfaces/IOevProxy.sol\";\n\n/// @title Contract that serves OEV Beacons and Beacon sets\n/// @notice OEV Beacons and Beacon sets can be updated by the winner of the\n/// respective OEV auctions. The beneficiary can withdraw the proceeds from\n/// this contract.\ncontract OevDataFeedServer is DataFeedServer, IOevDataFeedServer {\n    using ECDSA for bytes32;\n\n    /// @notice Data feed with ID specific to the OEV proxy\n    /// @dev This implies that an update as a result of an OEV auction only\n    /// affects contracts that read through the respective proxy that the\n    /// auction was being held for\n    mapping(address => mapping(bytes32 => DataFeed))\n        internal _oevProxyToIdToDataFeed;\n\n    /// @notice Accumulated OEV auction proceeds for the specific proxy\n    mapping(address => uint256) public override oevProxyToBalance;\n\n    /// @notice Updates a data feed that the OEV proxy reads using the\n    /// aggregation signed by the absolute majority of the respective Airnodes\n    /// for the specific bid\n    /// @dev For when the data feed being updated is a Beacon set, an absolute\n    /// majority of the Airnodes that power the respective Beacons must sign\n    /// the aggregated value and timestamp. While doing so, the Airnodes should\n    /// refer to data signed to update an absolute majority of the respective\n    /// Beacons. The Airnodes should require the data to be fresh enough (e.g.,\n    /// at most 2 minutes-old), and tightly distributed around the resulting\n    /// aggregation (e.g., within 1% deviation), and reject to provide an OEV\n    /// proxy data feed update signature if these are not satisfied.\n    /// @param oevProxy OEV proxy that reads the data feed\n    /// @param dataFeedId Data feed ID\n    /// @param updateId Update ID\n    /// @param timestamp Signature timestamp\n    /// @param data Update data (an `int256` encoded in contract ABI)\n    /// @param packedOevUpdateSignatures Packed OEV update signatures, which\n    /// include the Airnode address, template ID and these signed with the OEV\n    /// update hash\n    function updateOevProxyDataFeedWithSignedData(\n        address oevProxy,\n        bytes32 dataFeedId,\n        bytes32 updateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes[] calldata packedOevUpdateSignatures\n    ) external payable override onlyValidTimestamp(timestamp) {\n        require(\n            timestamp > _oevProxyToIdToDataFeed[oevProxy][dataFeedId].timestamp,\n            \"Does not update timestamp\"\n        );\n        bytes32 oevUpdateHash = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                oevProxy,\n                dataFeedId,\n                updateId,\n                timestamp,\n                data,\n                msg.sender,\n                msg.value\n            )\n        );\n        int224 updatedValue = decodeFulfillmentData(data);\n        uint32 updatedTimestamp = uint32(timestamp);\n        uint256 beaconCount = packedOevUpdateSignatures.length;\n        if (beaconCount > 1) {\n            bytes32[] memory beaconIds = new bytes32[](beaconCount);\n            uint256 validSignatureCount;\n            for (uint256 ind = 0; ind < beaconCount; ) {\n                bool signatureIsNotOmitted;\n                (\n                    signatureIsNotOmitted,\n                    beaconIds[ind]\n                ) = unpackAndValidateOevUpdateSignature(\n                    oevUpdateHash,\n                    packedOevUpdateSignatures[ind]\n                );\n                if (signatureIsNotOmitted) {\n                    unchecked {\n                        validSignatureCount++;\n                    }\n                }\n                unchecked {\n                    ind++;\n                }\n            }\n            // \"Greater than or equal to\" is not enough because full control\n            // of aggregation requires an absolute majority\n            require(\n                validSignatureCount > beaconCount / 2,\n                \"Not enough signatures\"\n            );\n            require(\n                dataFeedId == deriveBeaconSetId(beaconIds),\n                \"Beacon set ID mismatch\"\n            );\n            emit UpdatedOevProxyBeaconSetWithSignedData(\n                dataFeedId,\n                oevProxy,\n                updateId,\n                updatedValue,\n                updatedTimestamp\n            );\n        } else if (beaconCount == 1) {\n            {\n                (\n                    bool signatureIsNotOmitted,\n                    bytes32 beaconId\n                ) = unpackAndValidateOevUpdateSignature(\n                        oevUpdateHash,\n                        packedOevUpdateSignatures[0]\n                    );\n                require(signatureIsNotOmitted, \"Missing signature\");\n                require(dataFeedId == beaconId, \"Beacon ID mismatch\");\n            }\n            emit UpdatedOevProxyBeaconWithSignedData(\n                dataFeedId,\n                oevProxy,\n                updateId,\n                updatedValue,\n                updatedTimestamp\n            );\n        } else {\n            revert(\"Did not specify any Beacons\");\n        }\n        _oevProxyToIdToDataFeed[oevProxy][dataFeedId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        oevProxyToBalance[oevProxy] += msg.value;\n    }\n\n    /// @notice Withdraws the balance of the OEV proxy to the respective\n    /// beneficiary account\n    /// @dev This does not require the caller to be the beneficiary because we\n    /// expect that in most cases, the OEV beneficiary will be a contract that\n    /// will not be able to make arbitrary calls. Our choice can be worked\n    /// around by implementing a beneficiary proxy.\n    /// @param oevProxy OEV proxy\n    function withdraw(address oevProxy) external override {\n        address oevBeneficiary = IOevProxy(oevProxy).oevBeneficiary();\n        require(oevBeneficiary != address(0), \"Beneficiary address zero\");\n        uint256 balance = oevProxyToBalance[oevProxy];\n        require(balance != 0, \"OEV proxy balance zero\");\n        oevProxyToBalance[oevProxy] = 0;\n        emit Withdrew(oevProxy, oevBeneficiary, balance);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = oevBeneficiary.call{value: balance}(\"\");\n        require(success, \"Withdrawal reverted\");\n    }\n\n    /// @notice Reads the data feed as the OEV proxy with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithIdAsOevProxy(\n        bytes32 dataFeedId\n    ) internal view returns (int224 value, uint32 timestamp) {\n        DataFeed storage oevDataFeed = _oevProxyToIdToDataFeed[msg.sender][\n            dataFeedId\n        ];\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        if (oevDataFeed.timestamp > dataFeed.timestamp) {\n            (value, timestamp) = (oevDataFeed.value, oevDataFeed.timestamp);\n        } else {\n            (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        }\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n\n    /// @notice Called privately to unpack and validate the OEV update\n    /// signature\n    /// @param oevUpdateHash OEV update hash\n    /// @param packedOevUpdateSignature Packed OEV update signature, which\n    /// includes the Airnode address, template ID and these signed with the OEV\n    /// update hash\n    /// @return signatureIsNotOmitted If the signature is omitted in\n    /// `packedOevUpdateSignature`\n    /// @return beaconId Beacon ID\n    function unpackAndValidateOevUpdateSignature(\n        bytes32 oevUpdateHash,\n        bytes calldata packedOevUpdateSignature\n    ) private pure returns (bool signatureIsNotOmitted, bytes32 beaconId) {\n        (address airnode, bytes32 templateId, bytes memory signature) = abi\n            .decode(packedOevUpdateSignature, (address, bytes32, bytes));\n        beaconId = deriveBeaconId(airnode, templateId);\n        if (signature.length != 0) {\n            require(\n                (\n                    keccak256(abi.encodePacked(oevUpdateHash, templateId))\n                        .toEthSignedMessageHash()\n                ).recover(signature) == airnode,\n                \"Signature mismatch\"\n            );\n            signatureIsNotOmitted = true;\n        }\n    }\n}\n"
    },
    "contracts/api3-server-v1/proxies/DapiProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IDapiProxy.sol\";\nimport \"../interfaces/IApi3ServerV1.sol\";\n\n/// @title An immutable proxy contract that is used to read a specific dAPI of\n/// a specific Api3ServerV1 contract\n/// @notice In an effort to reduce the bytecode of this contract, its\n/// constructor arguments are validated by ProxyFactory, rather than\n/// internally. If you intend to deploy this contract without using\n/// ProxyFactory, you are recommended to implement an equivalent validation.\n/// @dev The proxy contracts are generalized to support most types of numerical\n/// data feeds. This means that the user of this proxy is expected to validate\n/// the read values according to the specific use-case. For example, `value` is\n/// a signed integer, yet it being negative may not make sense in the case that\n/// the data feed represents the spot price of an asset. In that case, the user\n/// is responsible with ensuring that `value` is not negative.\n/// In the case that the data feed is from a single source, `timestamp` is the\n/// system time of the Airnode when it signed the data. In the case that the\n/// data feed is from multiple sources, `timestamp` is the median of system\n/// times of the Airnodes when they signed the respective data. There are two\n/// points to consider while using `timestamp` in your contract logic: (1) It\n/// is based on the system time of the Airnodes, and not the block timestamp.\n/// This may be relevant when either of them drifts. (2) `timestamp` is an\n/// off-chain value that is being reported, similar to `value`. Both should\n/// only be trusted as much as the Airnode(s) that report them.\ncontract DapiProxy is IDapiProxy {\n    /// @notice Api3ServerV1 address\n    address public immutable override api3ServerV1;\n    /// @notice Hash of the dAPI name\n    bytes32 public immutable override dapiNameHash;\n\n    /// @param _api3ServerV1 Api3ServerV1 address\n    /// @param _dapiNameHash Hash of the dAPI name\n    constructor(address _api3ServerV1, bytes32 _dapiNameHash) {\n        api3ServerV1 = _api3ServerV1;\n        dapiNameHash = _dapiNameHash;\n    }\n\n    /// @notice Reads the dAPI that this proxy maps to\n    /// @return value dAPI value\n    /// @return timestamp dAPI timestamp\n    function read()\n        external\n        view\n        virtual\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        (value, timestamp) = IApi3ServerV1(api3ServerV1)\n            .readDataFeedWithDapiNameHash(dapiNameHash);\n    }\n}\n"
    },
    "contracts/api3-server-v1/proxies/DapiProxyWithOev.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./DapiProxy.sol\";\nimport \"./interfaces/IOevProxy.sol\";\n\n/// @title An immutable proxy contract that is used to read a specific dAPI of\n/// a specific Api3ServerV1 contract and inform Api3ServerV1 about the\n/// beneficiary of the respective OEV proceeds\n/// @notice In an effort to reduce the bytecode of this contract, its\n/// constructor arguments are validated by ProxyFactory, rather than\n/// internally. If you intend to deploy this contract without using\n/// ProxyFactory, you are recommended to implement an equivalent validation.\n/// @dev See DapiProxy.sol for comments about usage\ncontract DapiProxyWithOev is DapiProxy, IOevProxy {\n    /// @notice OEV beneficiary address\n    address public immutable override oevBeneficiary;\n\n    /// @param _api3ServerV1 Api3ServerV1 address\n    /// @param _dapiNameHash Hash of the dAPI name\n    /// @param _oevBeneficiary OEV beneficiary\n    constructor(\n        address _api3ServerV1,\n        bytes32 _dapiNameHash,\n        address _oevBeneficiary\n    ) DapiProxy(_api3ServerV1, _dapiNameHash) {\n        oevBeneficiary = _oevBeneficiary;\n    }\n\n    /// @notice Reads the dAPI that this proxy maps to\n    /// @return value dAPI value\n    /// @return timestamp dAPI timestamp\n    function read()\n        external\n        view\n        virtual\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        (value, timestamp) = IApi3ServerV1(api3ServerV1)\n            .readDataFeedWithDapiNameHashAsOevProxy(dapiNameHash);\n    }\n}\n"
    },
    "contracts/api3-server-v1/proxies/DataFeedProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IDataFeedProxy.sol\";\nimport \"../interfaces/IApi3ServerV1.sol\";\n\n/// @title An immutable proxy contract that is used to read a specific data\n/// feed (Beacon or Beacon set) of a specific Api3ServerV1 contract\n/// @notice In an effort to reduce the bytecode of this contract, its\n/// constructor arguments are validated by ProxyFactory, rather than\n/// internally. If you intend to deploy this contract without using\n/// ProxyFactory, you are recommended to implement an equivalent validation.\n/// @dev See DapiProxy.sol for comments about usage\ncontract DataFeedProxy is IDataFeedProxy {\n    /// @notice Api3ServerV1 address\n    address public immutable override api3ServerV1;\n    /// @notice Data feed ID\n    bytes32 public immutable override dataFeedId;\n\n    /// @param _api3ServerV1 Api3ServerV1 address\n    /// @param _dataFeedId Data feed (Beacon or Beacon set) ID\n    constructor(address _api3ServerV1, bytes32 _dataFeedId) {\n        api3ServerV1 = _api3ServerV1;\n        dataFeedId = _dataFeedId;\n    }\n\n    /// @notice Reads the data feed that this proxy maps to\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function read()\n        external\n        view\n        virtual\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        (value, timestamp) = IApi3ServerV1(api3ServerV1).readDataFeedWithId(\n            dataFeedId\n        );\n    }\n}\n"
    },
    "contracts/api3-server-v1/proxies/DataFeedProxyWithOev.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./DataFeedProxy.sol\";\nimport \"./interfaces/IOevProxy.sol\";\n\n/// @title An immutable proxy contract that is used to read a specific data\n/// feed (Beacon or Beacon set) of a specific Api3ServerV1 contract and inform\n/// Api3ServerV1 about the beneficiary of the respective OEV proceeds\n/// @notice In an effort to reduce the bytecode of this contract, its\n/// constructor arguments are validated by ProxyFactory, rather than\n/// internally. If you intend to deploy this contract without using\n/// ProxyFactory, you are recommended to implement an equivalent validation.\n/// @dev See DapiProxy.sol for comments about usage\ncontract DataFeedProxyWithOev is DataFeedProxy, IOevProxy {\n    /// @notice OEV beneficiary address\n    address public immutable override oevBeneficiary;\n\n    /// @param _api3ServerV1 Api3ServerV1 address\n    /// @param _dataFeedId Data feed (Beacon or Beacon set) ID\n    /// @param _oevBeneficiary OEV beneficiary\n    constructor(\n        address _api3ServerV1,\n        bytes32 _dataFeedId,\n        address _oevBeneficiary\n    ) DataFeedProxy(_api3ServerV1, _dataFeedId) {\n        oevBeneficiary = _oevBeneficiary;\n    }\n\n    /// @notice Reads the data feed that this proxy maps to\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function read()\n        external\n        view\n        virtual\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        (value, timestamp) = IApi3ServerV1(api3ServerV1)\n            .readDataFeedWithIdAsOevProxy(dataFeedId);\n    }\n}\n"
    },
    "contracts/api3-server-v1/proxies/interfaces/IDapiProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IProxy.sol\";\n\ninterface IDapiProxy is IProxy {\n    function dapiNameHash() external view returns (bytes32);\n}\n"
    },
    "contracts/api3-server-v1/proxies/interfaces/IDataFeedProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IProxy.sol\";\n\ninterface IDataFeedProxy is IProxy {\n    function dataFeedId() external view returns (bytes32);\n}\n"
    },
    "contracts/api3-server-v1/proxies/interfaces/IOevProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOevProxy {\n    function oevBeneficiary() external view returns (address);\n}\n"
    },
    "contracts/api3-server-v1/proxies/interfaces/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev See DapiProxy.sol for comments about usage\ninterface IProxy {\n    function read() external view returns (int224 value, uint32 timestamp);\n\n    function api3ServerV1() external view returns (address);\n}\n"
    },
    "contracts/api3-server-v1/proxies/interfaces/IProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IProxyFactory {\n    event DeployedDataFeedProxy(\n        address indexed proxyAddress,\n        bytes32 indexed dataFeedId,\n        bytes metadata\n    );\n\n    event DeployedDapiProxy(\n        address indexed proxyAddress,\n        bytes32 indexed dapiName,\n        bytes metadata\n    );\n\n    event DeployedDataFeedProxyWithOev(\n        address indexed proxyAddress,\n        bytes32 indexed dataFeedId,\n        address oevBeneficiary,\n        bytes metadata\n    );\n\n    event DeployedDapiProxyWithOev(\n        address indexed proxyAddress,\n        bytes32 indexed dapiName,\n        address oevBeneficiary,\n        bytes metadata\n    );\n\n    function deployDataFeedProxy(\n        bytes32 dataFeedId,\n        bytes calldata metadata\n    ) external returns (address proxyAddress);\n\n    function deployDapiProxy(\n        bytes32 dapiName,\n        bytes calldata metadata\n    ) external returns (address proxyAddress);\n\n    function deployDataFeedProxyWithOev(\n        bytes32 dataFeedId,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external returns (address proxyAddress);\n\n    function deployDapiProxyWithOev(\n        bytes32 dapiName,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external returns (address proxyAddress);\n\n    function computeDataFeedProxyAddress(\n        bytes32 dataFeedId,\n        bytes calldata metadata\n    ) external view returns (address proxyAddress);\n\n    function computeDapiProxyAddress(\n        bytes32 dapiName,\n        bytes calldata metadata\n    ) external view returns (address proxyAddress);\n\n    function computeDataFeedProxyWithOevAddress(\n        bytes32 dataFeedId,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external view returns (address proxyAddress);\n\n    function computeDapiProxyWithOevAddress(\n        bytes32 dapiName,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external view returns (address proxyAddress);\n\n    function api3ServerV1() external view returns (address);\n}\n"
    },
    "contracts/api3-server-v1/proxies/mock/MockProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IProxy.sol\";\n\n// This contract is provided for testing purposes. It can be extended to mock\n// the interface of specific proxy types such as DataFeedProxy and DapiProxy.\ncontract MockProxy is IProxy {\n    address public immutable override api3ServerV1;\n\n    int224 private _value;\n\n    uint32 private _timestamp;\n\n    constructor(address _api3ServerV1) {\n        api3ServerV1 = _api3ServerV1;\n    }\n\n    function read()\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        (value, timestamp) = (_value, _timestamp);\n    }\n\n    function mock(int224 value, uint32 timestamp) external {\n        (_value, _timestamp) = (value, timestamp);\n    }\n}\n"
    },
    "contracts/api3-server-v1/proxies/ProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./DataFeedProxy.sol\";\nimport \"./DapiProxy.sol\";\nimport \"./DataFeedProxyWithOev.sol\";\nimport \"./DapiProxyWithOev.sol\";\nimport \"./interfaces/IProxyFactory.sol\";\nimport \"../../vendor/@openzeppelin/contracts@4.8.2/utils/Create2.sol\";\n\n/// @title Contract factory that deterministically deploys proxies that read\n/// data feeds (Beacons or Beacon sets) or dAPIs, along with optional OEV\n/// support\n/// @dev The proxies are deployed normally and not cloned to minimize the gas\n/// cost overhead while using them to read data feed values\ncontract ProxyFactory is IProxyFactory {\n    /// @notice Api3ServerV1 address\n    address public immutable override api3ServerV1;\n\n    /// @param _api3ServerV1 Api3ServerV1 address\n    constructor(address _api3ServerV1) {\n        require(_api3ServerV1 != address(0), \"Api3ServerV1 address zero\");\n        api3ServerV1 = _api3ServerV1;\n    }\n\n    /// @notice Deterministically deploys a data feed proxy\n    /// @param dataFeedId Data feed ID\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function deployDataFeedProxy(\n        bytes32 dataFeedId,\n        bytes calldata metadata\n    ) external override returns (address proxyAddress) {\n        require(dataFeedId != bytes32(0), \"Data feed ID zero\");\n        proxyAddress = address(\n            new DataFeedProxy{salt: keccak256(metadata)}(\n                api3ServerV1,\n                dataFeedId\n            )\n        );\n        emit DeployedDataFeedProxy(proxyAddress, dataFeedId, metadata);\n    }\n\n    /// @notice Deterministically deploys a dAPI proxy\n    /// @param dapiName dAPI name\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function deployDapiProxy(\n        bytes32 dapiName,\n        bytes calldata metadata\n    ) external override returns (address proxyAddress) {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        proxyAddress = address(\n            new DapiProxy{salt: keccak256(metadata)}(\n                api3ServerV1,\n                keccak256(abi.encodePacked(dapiName))\n            )\n        );\n        emit DeployedDapiProxy(proxyAddress, dapiName, metadata);\n    }\n\n    /// @notice Deterministically deploys a data feed proxy with OEV support\n    /// @param dataFeedId Data feed ID\n    /// @param oevBeneficiary OEV beneficiary\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function deployDataFeedProxyWithOev(\n        bytes32 dataFeedId,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external override returns (address proxyAddress) {\n        require(dataFeedId != bytes32(0), \"Data feed ID zero\");\n        require(oevBeneficiary != address(0), \"OEV beneficiary zero\");\n        proxyAddress = address(\n            new DataFeedProxyWithOev{salt: keccak256(metadata)}(\n                api3ServerV1,\n                dataFeedId,\n                oevBeneficiary\n            )\n        );\n        emit DeployedDataFeedProxyWithOev(\n            proxyAddress,\n            dataFeedId,\n            oevBeneficiary,\n            metadata\n        );\n    }\n\n    /// @notice Deterministically deploys a dAPI proxy with OEV support\n    /// @param dapiName dAPI name\n    /// @param oevBeneficiary OEV beneficiary\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function deployDapiProxyWithOev(\n        bytes32 dapiName,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external override returns (address proxyAddress) {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        require(oevBeneficiary != address(0), \"OEV beneficiary zero\");\n        proxyAddress = address(\n            new DapiProxyWithOev{salt: keccak256(metadata)}(\n                api3ServerV1,\n                keccak256(abi.encodePacked(dapiName)),\n                oevBeneficiary\n            )\n        );\n        emit DeployedDapiProxyWithOev(\n            proxyAddress,\n            dapiName,\n            oevBeneficiary,\n            metadata\n        );\n    }\n\n    /// @notice Computes the address of the data feed proxy\n    /// @param dataFeedId Data feed ID\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function computeDataFeedProxyAddress(\n        bytes32 dataFeedId,\n        bytes calldata metadata\n    ) external view override returns (address proxyAddress) {\n        require(dataFeedId != bytes32(0), \"Data feed ID zero\");\n        proxyAddress = Create2.computeAddress(\n            keccak256(metadata),\n            keccak256(\n                abi.encodePacked(\n                    type(DataFeedProxy).creationCode,\n                    abi.encode(api3ServerV1, dataFeedId)\n                )\n            )\n        );\n    }\n\n    /// @notice Computes the address of the dAPI proxy\n    /// @param dapiName dAPI name\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function computeDapiProxyAddress(\n        bytes32 dapiName,\n        bytes calldata metadata\n    ) external view override returns (address proxyAddress) {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        proxyAddress = Create2.computeAddress(\n            keccak256(metadata),\n            keccak256(\n                abi.encodePacked(\n                    type(DapiProxy).creationCode,\n                    abi.encode(\n                        api3ServerV1,\n                        keccak256(abi.encodePacked(dapiName))\n                    )\n                )\n            )\n        );\n    }\n\n    /// @notice Computes the address of the data feed proxy with OEV support\n    /// @param dataFeedId Data feed ID\n    /// @param oevBeneficiary OEV beneficiary\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function computeDataFeedProxyWithOevAddress(\n        bytes32 dataFeedId,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external view override returns (address proxyAddress) {\n        require(dataFeedId != bytes32(0), \"Data feed ID zero\");\n        require(oevBeneficiary != address(0), \"OEV beneficiary zero\");\n        proxyAddress = Create2.computeAddress(\n            keccak256(metadata),\n            keccak256(\n                abi.encodePacked(\n                    type(DataFeedProxyWithOev).creationCode,\n                    abi.encode(api3ServerV1, dataFeedId, oevBeneficiary)\n                )\n            )\n        );\n    }\n\n    /// @notice Computes the address of the dAPI proxy with OEV support\n    /// @param dapiName dAPI name\n    /// @param oevBeneficiary OEV beneficiary\n    /// @param metadata Metadata associated with the proxy\n    /// @return proxyAddress Proxy address\n    function computeDapiProxyWithOevAddress(\n        bytes32 dapiName,\n        address oevBeneficiary,\n        bytes calldata metadata\n    ) external view override returns (address proxyAddress) {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        require(oevBeneficiary != address(0), \"OEV beneficiary zero\");\n        proxyAddress = Create2.computeAddress(\n            keccak256(metadata),\n            keccak256(\n                abi.encodePacked(\n                    type(DapiProxyWithOev).creationCode,\n                    abi.encode(\n                        api3ServerV1,\n                        keccak256(abi.encodePacked(dapiName)),\n                        oevBeneficiary\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/MockApi3ServerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../api3-server-v1/Api3ServerV1.sol\";\n\ncontract MockApi3ServerV1 is Api3ServerV1 {\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    ) Api3ServerV1(_accessControlRegistry, _adminRoleDescription, _manager) {}\n\n    function mockUpdate(\n        bytes32 dataFeedId,\n        int224 value,\n        uint32 timestamp\n    ) external {\n        _dataFeeds[dataFeedId] = DataFeed({value: value, timestamp: timestamp});\n    }\n}\n"
    },
    "contracts/test/MockCallForwarderTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MockCallForwarderTarget {\n    string public storage1;\n    uint256 public storage2;\n\n    function payableTargetFunction(\n        string calldata input1,\n        uint256 input2,\n        uint256 msgValue\n    ) external payable returns (bytes memory output1, bool output2) {\n        require(\n            keccak256(abi.encodePacked(input1)) ==\n                keccak256(abi.encodePacked(\"input1\")),\n            \"Incorrect input\"\n        );\n        require(input2 == 123, \"Incorrect input\");\n        require(msg.value == msgValue, \"Incorrect value\");\n        storage1 = input1;\n        storage2 = input2;\n        output1 = hex\"12345678\";\n        output2 = true;\n    }\n\n    function nonpayableTargetFunction(\n        string calldata input1,\n        uint256 input2\n    ) external returns (bytes memory output1, bool output2) {\n        require(\n            keccak256(abi.encodePacked(input1)) ==\n                keccak256(abi.encodePacked(\"input1\")),\n            \"Incorrect input\"\n        );\n        require(input2 == 123, \"Incorrect input\");\n        storage1 = input1;\n        storage2 = input2;\n        output1 = hex\"12345678\";\n        output2 = true;\n    }\n}\n"
    },
    "contracts/test/MockContractWithNoDefaultPayable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract MockContractWithNoDefaultPayable {\n    function customPayable() external payable {}\n}\n"
    },
    "contracts/test/MockMedian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../api3-server-v1/aggregation/Median.sol\";\n\ncontract MockMedian is Median {\n    function exposedMedian(\n        int256[] memory array\n    ) external pure returns (int256) {\n        return median(array);\n    }\n\n    function exposedAverage(int256 x, int256 y) external pure returns (int256) {\n        int256[] memory array = new int256[](2);\n        if (x < y) {\n            array[0] = x;\n            array[1] = y;\n        } else {\n            array[0] = y;\n            array[1] = x;\n        }\n        return median(array);\n    }\n}\n"
    },
    "contracts/test/MockMulticallTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract MockMulticallTarget {\n    error MyError(uint256 fieldAlways123, string fieldAlwaysFoo);\n\n    int256[] private _argumentHistory;\n\n    function alwaysRevertsWithString(\n        int256 argPositive,\n        int256 argNegative\n    ) external pure {\n        require(argPositive > 0 && argNegative < 0, \"Invalid argument\");\n        revert(\"Reverted with string\");\n    }\n\n    function alwaysRevertsWithCustomError(\n        int256 argPositive,\n        int256 argNegative\n    ) external pure {\n        require(argPositive > 0 && argNegative < 0, \"Invalid argument\");\n        revert MyError(123, \"Foo\");\n    }\n\n    function alwaysRevertsWithNoData(\n        int256 argPositive,\n        int256 argNegative\n    ) external pure {\n        require(argPositive > 0 && argNegative < 0, \"Invalid argument\");\n        revert(); // solhint-disable-line reason-string\n    }\n\n    function convertsPositiveArgumentToNegative(\n        int256 argPositive\n    ) external payable returns (int256) {\n        require(argPositive > 0, \"Argument not positive\");\n        _argumentHistory.push(argPositive);\n        return -argPositive;\n    }\n\n    function argumentHistory() external view returns (int256[] memory) {\n        int256[] memory argumentHistoryInMemory = new int256[](\n            _argumentHistory.length\n        );\n        for (uint256 ind = 0; ind < _argumentHistory.length; ind++) {\n            argumentHistoryInMemory[ind] = _argumentHistory[ind];\n        }\n        return argumentHistoryInMemory;\n    }\n}\n"
    },
    "contracts/test/MockSelfMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/SelfMulticall.sol\";\nimport \"./MockMulticallTarget.sol\";\n\ncontract MockSelfMulticall is SelfMulticall, MockMulticallTarget {}\n"
    },
    "contracts/test/MockSort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../api3-server-v1/aggregation/Median.sol\";\n\ncontract MockSort is Sort {\n    function exposedSort(\n        int256[] memory array\n    ) external pure returns (int256[] memory) {\n        sort(array);\n        return array;\n    }\n}\n"
    },
    "contracts/utils/ExtendedSelfMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./SelfMulticall.sol\";\nimport \"./interfaces/IExtendedSelfMulticall.sol\";\n\n/// @title Contract that extends SelfMulticall to fetch some of the global\n/// variables\n/// @notice Available global variables are limited to the ones that Airnode\n/// tends to need\ncontract ExtendedSelfMulticall is SelfMulticall, IExtendedSelfMulticall {\n    /// @notice Returns the chain ID\n    /// @return Chain ID\n    function getChainId() external view override returns (uint256) {\n        return block.chainid;\n    }\n\n    /// @notice Returns the account balance\n    /// @param account Account address\n    /// @return Account balance\n    function getBalance(\n        address account\n    ) external view override returns (uint256) {\n        return account.balance;\n    }\n\n    /// @notice Returns if the account contains bytecode\n    /// @dev An account not containing any bytecode does not indicate that it\n    /// is an EOA or it will not contain any bytecode in the future.\n    /// Contract construction and `SELFDESTRUCT` updates the bytecode at the\n    /// end of the transaction.\n    /// @return If the account contains bytecode\n    function containsBytecode(\n        address account\n    ) external view override returns (bool) {\n        return account.code.length > 0;\n    }\n\n    /// @notice Returns the current block number\n    /// @return Current block number\n    function getBlockNumber() external view override returns (uint256) {\n        return block.number;\n    }\n\n    /// @notice Returns the current block timestamp\n    /// @return Current block timestamp\n    function getBlockTimestamp() external view override returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @notice Returns the current block basefee\n    /// @return Current block basefee\n    function getBlockBasefee() external view override returns (uint256) {\n        return block.basefee;\n    }\n}\n"
    },
    "contracts/utils/interfaces/IExtendedSelfMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ISelfMulticall.sol\";\n\ninterface IExtendedSelfMulticall is ISelfMulticall {\n    function getChainId() external view returns (uint256);\n\n    function getBalance(address account) external view returns (uint256);\n\n    function containsBytecode(address account) external view returns (bool);\n\n    function getBlockNumber() external view returns (uint256);\n\n    function getBlockTimestamp() external view returns (uint256);\n\n    function getBlockBasefee() external view returns (uint256);\n}\n"
    },
    "contracts/utils/interfaces/ISelfMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISelfMulticall {\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory returndata);\n\n    function tryMulticall(\n        bytes[] calldata data\n    ) external returns (bool[] memory successes, bytes[] memory returndata);\n}\n"
    },
    "contracts/utils/SelfMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ISelfMulticall.sol\";\n\n/// @title Contract that enables calls to the inheriting contract to be batched\n/// @notice Implements two ways of batching, one requires none of the calls to\n/// revert and the other tolerates individual calls reverting\n/// @dev This implementation uses delegatecall for individual function calls.\n/// Since delegatecall is a message call, it can only be made to functions that\n/// are externally visible. This means that a contract cannot multicall its own\n/// functions that use internal/private visibility modifiers.\n/// Refer to OpenZeppelin's Multicall.sol for a similar implementation.\ncontract SelfMulticall is ISelfMulticall {\n    /// @notice Batches calls to the inheriting contract and reverts as soon as\n    /// one of the batched calls reverts\n    /// @param data Array of calldata of batched calls\n    /// @return returndata Array of returndata of batched calls\n    function multicall(\n        bytes[] calldata data\n    ) external override returns (bytes[] memory returndata) {\n        uint256 callCount = data.length;\n        returndata = new bytes[](callCount);\n        for (uint256 ind = 0; ind < callCount; ) {\n            bool success;\n            // solhint-disable-next-line avoid-low-level-calls\n            (success, returndata[ind]) = address(this).delegatecall(data[ind]);\n            if (!success) {\n                bytes memory returndataWithRevertData = returndata[ind];\n                if (returndataWithRevertData.length > 0) {\n                    // Adapted from OpenZeppelin's Address.sol\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        let returndata_size := mload(returndataWithRevertData)\n                        revert(\n                            add(32, returndataWithRevertData),\n                            returndata_size\n                        )\n                    }\n                } else {\n                    revert(\"Multicall: No revert string\");\n                }\n            }\n            unchecked {\n                ind++;\n            }\n        }\n    }\n\n    /// @notice Batches calls to the inheriting contract but does not revert if\n    /// any of the batched calls reverts\n    /// @param data Array of calldata of batched calls\n    /// @return successes Array of success conditions of batched calls\n    /// @return returndata Array of returndata of batched calls\n    function tryMulticall(\n        bytes[] calldata data\n    )\n        external\n        override\n        returns (bool[] memory successes, bytes[] memory returndata)\n    {\n        uint256 callCount = data.length;\n        successes = new bool[](callCount);\n        returndata = new bytes[](callCount);\n        for (uint256 ind = 0; ind < callCount; ) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (successes[ind], returndata[ind]) = address(this).delegatecall(\n                data[ind]\n            );\n            unchecked {\n                ind++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.8.2/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/vendor/@openzeppelin/contracts@4.9.5/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
