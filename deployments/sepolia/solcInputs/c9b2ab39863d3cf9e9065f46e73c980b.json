{
  "language": "Solidity",
  "sources": {
    "contracts/access-control-registry/AccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract that allows users to manage independent, tree-shaped access\n/// control tables\n/// @notice Multiple contracts can refer to this contract to check if their\n/// users have granted accounts specific roles. Therefore, it aims to keep all\n/// access control roles of its users in this single contract.\n/// @dev Each user is called a \"manager\", and is the only member of their root\n/// role. Starting from this root role, they can create an arbitrary tree of\n/// roles and grant these to accounts. Each role has a description, and roles\n/// adminned by the same role cannot have the same description.\ncontract AccessControlRegistry is\n    Multicall,\n    AccessControl,\n    RoleDeriver,\n    IAccessControlRegistry\n{\n    /// @notice Initializes the manager by initializing its root role and\n    /// granting it to them\n    /// @dev Anyone can initialize a manager. An uninitialized manager\n    /// attempting to initialize a role will be initialized automatically.\n    /// Once a manager is initialized, subsequent initializations have no\n    /// effect.\n    /// @param manager Manager address to be initialized\n    function initializeManager(address manager) public override {\n        require(manager != address(0), \"Manager address zero\");\n        bytes32 rootRole = deriveRootRole(manager);\n        if (!hasRole(rootRole, manager)) {\n            _grantRole(rootRole, manager);\n            emit InitializedManager(rootRole, manager);\n        }\n    }\n\n    /// @notice Called by the account to renounce the role\n    /// @dev Overriden to disallow managers to renounce their root roles.\n    /// `role` and `account` are not validated because\n    /// `AccessControl.renounceRole` will revert if either of them is zero.\n    /// @param role Role to be renounced\n    /// @param account Account to renounce the role\n    function renounceRole(bytes32 role, address account)\n        public\n        override(AccessControl, IAccessControl)\n    {\n        require(\n            role != deriveRootRole(account),\n            \"role is root role of account\"\n        );\n        AccessControl.renounceRole(role, account);\n    }\n\n    /// @notice Initializes a role by setting its admin role and grants it to\n    /// the sender\n    /// @dev If the sender should not have the initialized role, they should\n    /// explicitly renounce it after initializing it.\n    /// Once a role is initialized, subsequent initializations have no effect\n    /// other than granting the role to the sender.\n    /// The sender must be a member of `adminRole`. `adminRole` value is not\n    /// validated because the sender cannot have the `bytes32(0)` role.\n    /// If the sender is an uninitialized manager that is initializing a role\n    /// directly under their root role, manager initialization will happen\n    /// automatically, which will grant the sender `adminRole` and allow them\n    /// to initialize the role.\n    /// @param adminRole Admin role to be assigned to the initialized role\n    /// @param description Human-readable description of the initialized role\n    /// @return role Initialized role\n    function initializeRoleAndGrantToSender(\n        bytes32 adminRole,\n        string calldata description\n    ) external override returns (bytes32 role) {\n        require(bytes(description).length > 0, \"Role description empty\");\n        role = deriveRole(adminRole, description);\n        // AccessControl roles have `DEFAULT_ADMIN_ROLE` (i.e., `bytes32(0)`)\n        // as their `adminRole` by default. No account in AccessControlRegistry\n        // can possibly have that role, which means all initialized roles will\n        // have non-default admin roles, and vice versa.\n        if (getRoleAdmin(role) == DEFAULT_ADMIN_ROLE) {\n            if (adminRole == deriveRootRole(_msgSender())) {\n                initializeManager(_msgSender());\n            }\n            _setRoleAdmin(role, adminRole);\n            emit InitializedRole(role, adminRole, description, _msgSender());\n        }\n        grantRole(role, _msgSender());\n    }\n\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function deriveRootRole(address manager)\n        public\n        pure\n        override\n        returns (bytes32 rootRole)\n    {\n        rootRole = _deriveRootRole(manager);\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Human-readable description of the role\n    /// @return role Role\n    function deriveRole(bytes32 adminRole, string calldata description)\n        public\n        pure\n        override\n        returns (bytes32 role)\n    {\n        role = _deriveRole(adminRole, description);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/access-control-registry/RoleDeriver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will derive\n/// AccessControlRegistry roles\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\n/// derive roles, it should inherit this contract instead of re-implementing\n/// the logic\ncontract RoleDeriver {\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function _deriveRootRole(address manager)\n        internal\n        pure\n        returns (bytes32 rootRole)\n    {\n        rootRole = keccak256(abi.encodePacked(manager));\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Human-readable description of the role\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, string memory description)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\n    }\n\n    /// @notice Derives the role using its admin role and description hash\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param descriptionHash Hash of the human-readable description of the\n    /// role\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, bytes32 descriptionHash)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\ninterface IAccessControlRegistry is IAccessControl {\n    event InitializedManager(bytes32 indexed rootRole, address indexed manager);\n\n    event InitializedRole(\n        bytes32 indexed role,\n        bytes32 indexed adminRole,\n        string description,\n        address sender\n    );\n\n    function initializeManager(address manager) external;\n\n    function initializeRoleAndGrantToSender(\n        bytes32 adminRole,\n        string calldata description\n    ) external returns (bytes32 role);\n\n    function deriveRootRole(address manager)\n        external\n        pure\n        returns (bytes32 rootRole);\n\n    function deriveRole(bytes32 adminRole, string calldata description)\n        external\n        pure\n        returns (bytes32 role);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/whitelist/WhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./WhitelistRoles.sol\";\nimport \"../access-control-registry/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"./interfaces/IWhitelistRolesWithManager.sol\";\nimport \"../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// roles where there is a single manager\ncontract WhitelistRolesWithManager is\n    WhitelistRoles,\n    AccessControlRegistryAdminnedWithManager,\n    IWhitelistRolesWithManager\n{\n    // Since there will be a single manager, we can derive the roles beforehand\n\n    /// @notice Whitelist expiration extender role\n    bytes32 public immutable override whitelistExpirationExtenderRole;\n\n    /// @notice Whitelist expiration setter role\n    bytes32 public immutable override whitelistExpirationSetterRole;\n\n    /// @notice Indefinite whitelister role\n    bytes32 public immutable override indefiniteWhitelisterRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {\n        whitelistExpirationExtenderRole = _deriveRole(\n            adminRole,\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\n        );\n        whitelistExpirationSetterRole = _deriveRole(\n            adminRole,\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\n        );\n        indefiniteWhitelisterRole = _deriveRole(\n            adminRole,\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @dev Returns if the account has the whitelist expiration extender role\n    /// or is the manager\n    /// @param account Account address\n    /// @return If the account has the whitelist extender role or is the\n    /// manager\n    function hasWhitelistExpirationExtenderRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                whitelistExpirationExtenderRole,\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the whitelist expriation setter role or\n    /// is the manager\n    /// @param account Account address\n    /// @return If the account has the whitelist setter role or is the\n    /// manager\n    function hasWhitelistExpirationSetterRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                whitelistExpirationSetterRole,\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the indefinite whitelister role or is the\n    /// manager\n    /// @param account Account address\n    /// @return If the account has the indefinite whitelister role or is the\n    /// manager\n    function hasIndefiniteWhitelisterRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                indefiniteWhitelisterRole,\n                account\n            );\n    }\n}\n"
    },
    "contracts/whitelist/WhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IWhitelistRoles.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// generic AccessControlRegistry roles\ncontract WhitelistRoles is IWhitelistRoles {\n    // There are four roles implemented in this contract:\n    // Root\n    // └── (1) Admin (can grant and revoke the roles below)\n    //     ├── (2) Whitelist expiration extender\n    //     ├── (3) Whitelist expiration setter\n    //     └── (4) Indefinite whitelister\n    // Their IDs are derived from the descriptions below. Refer to\n    // AccessControlRegistry for more information.\n    // To clarify, the root role of the manager is the admin of (1), while (1)\n    // is the admin of (2), (3) and (4). So (1) is more of a \"contract admin\",\n    // while the `adminRole` used in AccessControl and AccessControlRegistry\n    // refers to a more general adminship relationship between roles.\n\n    /// @notice Whitelist expiration extender role description\n    string\n        public constant\n        override WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION =\n        \"Whitelist expiration extender\";\n\n    /// @notice Whitelist expiration setter role description\n    string\n        public constant\n        override WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION =\n        \"Whitelist expiration setter\";\n\n    /// @notice Indefinite whitelister role description\n\n    string public constant override INDEFINITE_WHITELISTER_ROLE_DESCRIPTION =\n        \"Indefinite whitelister\";\n\n    bytes32\n        internal constant WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION)\n        );\n\n    bytes32\n        internal constant WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION)\n        );\n\n    bytes32 internal constant INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH =\n        keccak256(abi.encodePacked(INDEFINITE_WHITELISTER_ROLE_DESCRIPTION));\n}\n"
    },
    "contracts/access-control-registry/AccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AccessControlRegistryAdminned.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\n/// @title Contract to be inherited by contracts with manager whose adminship\n/// functionality will be implemented using AccessControlRegistry\n/// @notice The manager address here is expected to belong to an\n/// AccessControlRegistry user that is a multisig/DAO\ncontract AccessControlRegistryAdminnedWithManager is\n    AccessControlRegistryAdminned,\n    IAccessControlRegistryAdminnedWithManager\n{\n    /// @notice Address of the manager that manages the related\n    /// AccessControlRegistry roles\n    /// @dev The mutability of the manager role can be implemented by\n    /// designating an OwnableCallForwarder contract as the manager. The\n    /// ownership of this contract can then be transferred, effectively\n    /// transferring managership.\n    address public immutable override manager;\n\n    /// @notice Admin role\n    /// @dev Since `manager` is immutable, so is `adminRole`\n    bytes32 public immutable override adminRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminned(\n            _accessControlRegistry,\n            _adminRoleDescription\n        )\n    {\n        require(_manager != address(0), \"Manager address zero\");\n        manager = _manager;\n        adminRole = _deriveAdminRole(_manager);\n    }\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRoles.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\ninterface IWhitelistRolesWithManager is\n    IWhitelistRoles,\n    IAccessControlRegistryAdminnedWithManager\n{\n    function whitelistExpirationExtenderRole() external view returns (bytes32);\n\n    function whitelistExpirationSetterRole() external view returns (bytes32);\n\n    function indefiniteWhitelisterRole() external view returns (bytes32);\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWhitelistRoles {\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function INDEFINITE_WHITELISTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/access-control-registry/AccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./AccessControlRegistryUser.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminned.sol\";\n\n/// @title Contract to be inherited by contracts whose adminship functionality\n/// will be implemented using AccessControlRegistry\ncontract AccessControlRegistryAdminned is\n    Multicall,\n    RoleDeriver,\n    AccessControlRegistryUser,\n    IAccessControlRegistryAdminned\n{\n    /// @notice Admin role description\n    string public override adminRoleDescription;\n\n    bytes32 internal immutable adminRoleDescriptionHash;\n\n    /// @dev Contracts deployed with the same admin role descriptions will have\n    /// the same roles, meaning that granting an account a role will authorize\n    /// it in multiple contracts. Unless you want your deployed contract to\n    /// share the role configuration of another contract, use a unique admin\n    /// role description.\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    ) AccessControlRegistryUser(_accessControlRegistry) {\n        require(\n            bytes(_adminRoleDescription).length > 0,\n            \"Admin role description empty\"\n        );\n        adminRoleDescription = _adminRoleDescription;\n        adminRoleDescriptionHash = keccak256(\n            abi.encodePacked(_adminRoleDescription)\n        );\n    }\n\n    /// @notice Derives the admin role for the specific manager address\n    /// @param manager Manager address\n    /// @return adminRole Admin role\n    function _deriveAdminRole(address manager)\n        internal\n        view\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveRole(\n            _deriveRootRole(manager),\n            adminRoleDescriptionHash\n        );\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryAdminned.sol\";\n\ninterface IAccessControlRegistryAdminnedWithManager is\n    IAccessControlRegistryAdminned\n{\n    function manager() external view returns (address);\n\n    function adminRole() external view returns (bytes32);\n}\n"
    },
    "contracts/access-control-registry/AccessControlRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccessControlRegistry.sol\";\nimport \"./interfaces/IAccessControlRegistryUser.sol\";\n\n/// @title Contract to be inherited by contracts that will interact with\n/// AccessControlRegistry\ncontract AccessControlRegistryUser is IAccessControlRegistryUser {\n    /// @notice AccessControlRegistry contract address\n    address public immutable override accessControlRegistry;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    constructor(address _accessControlRegistry) {\n        require(_accessControlRegistry != address(0), \"ACR address zero\");\n        accessControlRegistry = _accessControlRegistry;\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryUser.sol\";\n\ninterface IAccessControlRegistryAdminned is IAccessControlRegistryUser {\n    function adminRoleDescription() external view returns (string memory);\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAccessControlRegistryUser {\n    function accessControlRegistry() external view returns (address);\n}\n"
    },
    "contracts/whitelist/WhitelistWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Whitelist.sol\";\nimport \"./WhitelistRolesWithManager.sol\";\nimport \"./interfaces/IWhitelistWithManager.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that are controlled\n/// by a manager\ncontract WhitelistWithManager is\n    Whitelist,\n    WhitelistRolesWithManager,\n    IWhitelistWithManager\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        WhitelistRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of `user` to\n    /// be able to use the service with `serviceId` if the sender has the\n    /// whitelist expiration extender role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationExtenderRoleOrIsManager(msg.sender),\n            \"Cannot extend expiration\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        _extendWhitelistExpiration(serviceId, user, expirationTimestamp);\n        emit ExtendedWhitelistExpiration(\n            serviceId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `user` to be\n    /// able to use the service with `serviceId` if the sender has the\n    /// whitelist expiration setter role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationSetterRoleOrIsManager(msg.sender),\n            \"Cannot set expiration\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        _setWhitelistExpiration(serviceId, user, expirationTimestamp);\n        emit SetWhitelistExpiration(\n            serviceId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `user` to be able to\n    /// use the service with `serviceId` if the sender has the indefinite\n    /// whitelister role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) external override {\n        require(\n            hasIndefiniteWhitelisterRoleOrIsManager(msg.sender),\n            \"Cannot set indefinite status\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\n            serviceId,\n            user,\n            status\n        );\n        emit SetIndefiniteWhitelistStatus(\n            serviceId,\n            user,\n            msg.sender,\n            status,\n            indefiniteWhitelistCount\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) external override {\n        require(\n            !hasIndefiniteWhitelisterRoleOrIsManager(setter),\n            \"setter can set indefinite status\"\n        );\n        (\n            bool revoked,\n            uint192 indefiniteWhitelistCount\n        ) = _revokeIndefiniteWhitelistStatus(serviceId, user, setter);\n        if (revoked) {\n            emit RevokedIndefiniteWhitelistStatus(\n                serviceId,\n                user,\n                setter,\n                msg.sender,\n                indefiniteWhitelistCount\n            );\n        }\n    }\n}\n"
    },
    "contracts/whitelist/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that need temporary and\n/// permanent whitelists for services identified by hashes\n/// @notice This contract implements two kinds of whitelisting:\n///   (1) Temporary, ends when the expiration timestamp is in the past\n///   (2) Indefinite, ends when the indefinite whitelist count is zero\n/// Multiple senders can indefinitely whitelist/unwhitelist independently. The\n/// user will be considered whitelisted as long as there is at least one active\n/// indefinite whitelisting.\n/// @dev The interface of this contract is not implemented. It should be\n/// inherited and its functions should be exposed with a sort of an\n/// authorization scheme.\ncontract Whitelist {\n    struct WhitelistStatus {\n        uint64 expirationTimestamp;\n        uint192 indefiniteWhitelistCount;\n    }\n\n    mapping(bytes32 => mapping(address => WhitelistStatus))\n        internal serviceIdToUserToWhitelistStatus;\n\n    mapping(bytes32 => mapping(address => mapping(address => bool)))\n        internal serviceIdToUserToSetterToIndefiniteWhitelistStatus;\n\n    /// @notice Extends the expiration of the temporary whitelist of the user\n    /// for the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        require(\n            expirationTimestamp >\n                serviceIdToUserToWhitelistStatus[serviceId][user]\n                    .expirationTimestamp,\n            \"Does not extend expiration\"\n        );\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of the user for\n    /// the service\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the indefinite whitelist status of the user for the\n    /// service\n    /// @dev As long as at least there is at least one account that has set the\n    /// indefinite whitelist status of the user for the service as true, the\n    /// user will be considered whitelisted\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) internal returns (uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            status &&\n            !serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][\n                user\n            ][msg.sender]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = true;\n            indefiniteWhitelistCount++;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        } else if (\n            !status &&\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        }\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted to the user for\n    /// the service by a specific account\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) internal returns (bool revoked, uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n            revoked = true;\n        }\n    }\n\n    /// @notice Returns if the user is whitelised to use the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(bytes32 serviceId, address user)\n        internal\n        view\n        returns (bool isWhitelisted)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                serviceId\n            ][user];\n        return\n            whitelistStatus.indefiniteWhitelistCount > 0 ||\n            whitelistStatus.expirationTimestamp > block.timestamp;\n    }\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRolesWithManager.sol\";\n\ninterface IWhitelistWithManager is IWhitelistRolesWithManager {\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    function extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) external;\n}\n"
    },
    "contracts/monetization/interfaces/IRequesterAuthorizerWhitelisterWithToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\nimport \"./IAirnodeEndpointPriceRegistryUser.sol\";\nimport \"./IRequesterAuthorizerRegistryUser.sol\";\n\ninterface IRequesterAuthorizerWhitelisterWithToken is\n    IAccessControlRegistryAdminnedWithManager,\n    IAirnodeEndpointPriceRegistryUser,\n    IRequesterAuthorizerRegistryUser\n{\n    enum AirnodeParticipationStatus {\n        Inactive,\n        Active,\n        OptedOut\n    }\n\n    event SetTokenPrice(uint256 tokenPrice, address sender);\n\n    event SetPriceCoefficient(uint256 priceCoefficient, address sender);\n\n    event SetAirnodeParticipationStatus(\n        address airnode,\n        AirnodeParticipationStatus airnodeParticipationStatus,\n        address sender\n    );\n\n    event SetProceedsDestination(address proceedsDestination);\n\n    event SetRequesterBlockStatus(\n        address requester,\n        bool status,\n        address sender\n    );\n\n    event SetRequesterBlockStatusForAirnode(\n        address airnode,\n        address requester,\n        bool status,\n        address sender\n    );\n\n    function setTokenPrice(uint256 _tokenPrice) external;\n\n    function setPriceCoefficient(uint256 _priceCoefficient) external;\n\n    function setAirnodeParticipationStatus(\n        address airnode,\n        AirnodeParticipationStatus airnodeParticipationStatus\n    ) external;\n\n    function setProceedsDestination(address _proceedsDestination) external;\n\n    function setRequesterBlockStatus(address requester, bool status) external;\n\n    function setRequesterBlockStatusForAirnode(\n        address airnode,\n        address requester,\n        bool status\n    ) external;\n\n    function getTokenAmount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId\n    ) external view returns (uint256 amount);\n\n    function token() external view returns (address);\n\n    function tokenPrice() external view returns (uint256);\n\n    function priceCoefficient() external view returns (uint256);\n\n    function proceedsDestination() external view returns (address);\n\n    function airnodeToParticipationStatus(address airnode)\n        external\n        view\n        returns (AirnodeParticipationStatus);\n\n    function requesterToBlockStatus(address requester)\n        external\n        view\n        returns (bool);\n\n    function airnodeToRequesterToBlockStatus(address airnode, address requester)\n        external\n        view\n        returns (bool);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MAINTAINER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    function maintainerRole() external view returns (bytes32);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function BLOCKER_ROLE_DESCRIPTION() external view returns (string memory);\n\n    function blockerRole() external view returns (bytes32);\n}\n"
    },
    "contracts/monetization/interfaces/IAirnodeEndpointPriceRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAirnodeEndpointPriceRegistryUser {\n    function airnodeEndpointPriceRegistry() external view returns (address);\n}\n"
    },
    "contracts/monetization/interfaces/IRequesterAuthorizerRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRequesterAuthorizerRegistryUser {\n    function requesterAuthorizerRegistry() external view returns (address);\n}\n"
    },
    "contracts/monetization/RequesterAuthorizerWhitelisterWithToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../access-control-registry/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"./AirnodeEndpointPriceRegistryUser.sol\";\nimport \"./RequesterAuthorizerRegistryUser.sol\";\nimport \"./interfaces/IRequesterAuthorizerWhitelisterWithToken.sol\";\nimport \"../authorizers/interfaces/IRequesterAuthorizer.sol\";\n\n/// @title Contract to be inherited by RequesterAuthorizer contracts that will\n/// whitelist based on token interaction\ncontract RequesterAuthorizerWhitelisterWithToken is\n    AccessControlRegistryAdminnedWithManager,\n    AirnodeEndpointPriceRegistryUser,\n    RequesterAuthorizerRegistryUser,\n    IRequesterAuthorizerWhitelisterWithToken\n{\n    /// @notice Maintainer role description\n    string public constant override MAINTAINER_ROLE_DESCRIPTION = \"Maintainer\";\n\n    /// @notice Blocker role description\n    string public constant override BLOCKER_ROLE_DESCRIPTION = \"Blocker\";\n\n    /// @notice Maintainer role\n    /// @dev Maintainers do day-to-day operation such as maintaining price\n    /// parameters and Airnode participation statuses\n    bytes32 public immutable override maintainerRole;\n\n    /// @notice Blocker role\n    /// @dev Blockers deny service to malicious requesters. Since this\n    /// functionality can also be used to deny service to regular users, it\n    /// should be limited at the blocker contract level (instead of giving this\n    /// role to EOAs).\n    bytes32 public immutable override blockerRole;\n\n    /// @notice Contract address of the token that will be deposited, paid,\n    /// etc.\n    address public immutable token;\n\n    /// @notice Token price in USD (times 10^18)\n    uint256 public override tokenPrice;\n\n    /// @notice Coefficient that can be used to adjust the amount of tokens\n    /// required to interact with the contract\n    /// @dev If `token` has 18 decimals, a `priceCoefficient` of 10^18 means\n    /// the price registry amount will be used directly, while a\n    /// `priceCoefficient` of 10^19 means 10 times the price registry amount\n    /// will be used. On the other hand, if `token` has 6 decimals, a\n    /// `priceCoefficient` of 10^6 means the price registry amount will be used\n    /// directly, etc.\n    uint256 public override priceCoefficient;\n\n    /// @notice Address that the funds will be collected at\n    address public override proceedsDestination;\n\n    /// @notice If the Airnode is participating in the scheme implemented by\n    /// the contract:\n    /// Inactive: The Airnode is not participating, but can be made to\n    /// participate by a mantainer\n    /// Active: The Airnode is participating\n    /// OptedOut: The Airnode actively opted out, and cannot be made to\n    /// participate unless this is reverted by the Airnode\n    mapping(address => AirnodeParticipationStatus)\n        public\n        override airnodeToParticipationStatus;\n\n    /// @notice If a requester is blocked globally\n    mapping(address => bool) public override requesterToBlockStatus;\n\n    /// @notice If a requester is blocked for the specific Airnode\n    mapping(address => mapping(address => bool))\n        public\n        override airnodeToRequesterToBlockStatus;\n\n    /// @dev Reverts if Airnode address is zero\n    /// @param airnode Airnode address\n    modifier onlyNonZeroAirnode(address airnode) {\n        require(airnode != address(0), \"Airnode address zero\");\n        _;\n    }\n\n    /// @dev Reverts if Airnode is not active\n    /// @param airnode Airnode address\n    modifier onlyActiveAirnode(address airnode) {\n        require(\n            airnodeToParticipationStatus[airnode] ==\n                AirnodeParticipationStatus.Active,\n            \"Airnode not active\"\n        );\n        _;\n    }\n\n    /// @dev Reverts if chain ID is zero\n    /// @param chainId Chain ID\n    modifier onlyNonZeroChainId(uint256 chainId) {\n        require(chainId != 0, \"Chain ID zero\");\n        _;\n    }\n\n    /// @dev Reverts if requester address is zero\n    /// @param requester Requester address\n    modifier onlyNonZeroRequester(address requester) {\n        require(requester != address(0), \"Requester address zero\");\n        _;\n    }\n\n    /// @dev Reverts if requester is blocked\n    /// @param airnode Airnode address\n    /// @param requester Requester address\n    modifier onlyNonBlockedRequester(address airnode, address requester) {\n        require(!requesterIsBlocked(airnode, requester), \"Requester blocked\");\n        _;\n    }\n\n    /// @dev Reverts if sender does not have the maintainer role and is not the\n    /// manager\n    modifier onlyMaintainerOrManager() {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    maintainerRole,\n                    msg.sender\n                ),\n            \"Sender cannot maintain\"\n        );\n        _;\n    }\n\n    /// @dev Reverts if sender does not have the blocker role and is not the\n    /// manager\n    modifier onlyBlockerOrManager() {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    blockerRole,\n                    msg.sender\n                ),\n            \"Sender cannot block\"\n        );\n        _;\n    }\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    /// @param _airnodeEndpointPriceRegistry AirnodeEndpointPriceRegistry\n    /// contract address\n    /// @param _requesterAuthorizerRegistry RequesterAuthorizerRegistry\n    /// contract address\n    /// @param _token Token contract address\n    /// @param _tokenPrice Token price in USD (times 10^18)\n    /// @param _priceCoefficient Price coefficient (has the same number of\n    /// decimals as the token)\n    /// @param _proceedsDestination Destination of proceeds\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager,\n        address _airnodeEndpointPriceRegistry,\n        address _requesterAuthorizerRegistry,\n        address _token,\n        uint256 _tokenPrice,\n        uint256 _priceCoefficient,\n        address _proceedsDestination\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n        AirnodeEndpointPriceRegistryUser(_airnodeEndpointPriceRegistry)\n        RequesterAuthorizerRegistryUser(_requesterAuthorizerRegistry)\n    {\n        require(_token != address(0), \"Token address zero\");\n        token = _token;\n        _setTokenPrice(_tokenPrice);\n        _setPriceCoefficient(_priceCoefficient);\n        _setProceedsDestination(_proceedsDestination);\n        maintainerRole = _deriveRole(\n            adminRole,\n            keccak256(abi.encodePacked(MAINTAINER_ROLE_DESCRIPTION))\n        );\n        blockerRole = _deriveRole(\n            adminRole,\n            keccak256(abi.encodePacked(BLOCKER_ROLE_DESCRIPTION))\n        );\n        require(\n            keccak256(\n                abi.encodePacked(\n                    IAirnodeEndpointPriceRegistry(airnodeEndpointPriceRegistry)\n                        .DENOMINATION()\n                )\n            ) == keccak256(abi.encodePacked(\"USD\")),\n            \"Price denomination mismatch\"\n        );\n        require(\n            IAirnodeEndpointPriceRegistry(airnodeEndpointPriceRegistry)\n                .DECIMALS() == 18,\n            \"Price decimals mismatch\"\n        );\n    }\n\n    /// @notice Sets token price\n    /// @param _tokenPrice Token price in USD (times 10^18)\n    function setTokenPrice(uint256 _tokenPrice)\n        external\n        override\n        onlyMaintainerOrManager\n    {\n        _setTokenPrice(_tokenPrice);\n        emit SetTokenPrice(_tokenPrice, msg.sender);\n    }\n\n    /// @notice Sets price coefficient\n    /// @param _priceCoefficient Price coefficient (has the same number of\n    /// decimals as the token)\n    function setPriceCoefficient(uint256 _priceCoefficient)\n        external\n        override\n        onlyMaintainerOrManager\n    {\n        _setPriceCoefficient(_priceCoefficient);\n        emit SetPriceCoefficient(_priceCoefficient, msg.sender);\n    }\n\n    /// @notice Sets Airnode participation status\n    /// @param airnode Airnode address\n    /// @param airnodeParticipationStatus Airnode participation status\n    function setAirnodeParticipationStatus(\n        address airnode,\n        AirnodeParticipationStatus airnodeParticipationStatus\n    ) external override onlyNonZeroAirnode(airnode) {\n        if (msg.sender == airnode) {\n            require(\n                airnodeParticipationStatus != AirnodeParticipationStatus.Active,\n                \"Airnode cannot activate itself\"\n            );\n        } else {\n            require(\n                manager == msg.sender ||\n                    IAccessControlRegistry(accessControlRegistry).hasRole(\n                        maintainerRole,\n                        msg.sender\n                    ),\n                \"Sender cannot maintain\"\n            );\n            require(\n                airnodeParticipationStatus !=\n                    AirnodeParticipationStatus.OptedOut,\n                \"Only Airnode can opt out\"\n            );\n            require(\n                airnodeToParticipationStatus[airnode] !=\n                    AirnodeParticipationStatus.OptedOut,\n                \"Airnode opted out\"\n            );\n        }\n        airnodeToParticipationStatus[airnode] = airnodeParticipationStatus;\n        emit SetAirnodeParticipationStatus(\n            airnode,\n            airnodeParticipationStatus,\n            msg.sender\n        );\n    }\n\n    /// @notice Sets destination of proceeds\n    /// @param _proceedsDestination Destination of proceeds\n    function setProceedsDestination(address _proceedsDestination)\n        external\n        override\n    {\n        require(msg.sender == manager, \"Sender not manager\");\n        _setProceedsDestination(_proceedsDestination);\n        emit SetProceedsDestination(_proceedsDestination);\n    }\n\n    /// @notice Blocks requester globally\n    /// @param requester Requester address\n    /// @param status Requester block status (`true` represents being blocked)\n    function setRequesterBlockStatus(address requester, bool status)\n        external\n        override\n        onlyBlockerOrManager\n        onlyNonZeroRequester(requester)\n    {\n        requesterToBlockStatus[requester] = status;\n        emit SetRequesterBlockStatus(requester, status, msg.sender);\n    }\n\n    /// @notice Blocks requester for the Airnode\n    /// @param airnode Airnode address\n    /// @param requester Requester address\n    /// @param status Requester block status (`true` represents being blocked)\n    function setRequesterBlockStatusForAirnode(\n        address airnode,\n        address requester,\n        bool status\n    )\n        external\n        override\n        onlyBlockerOrManager\n        onlyNonZeroAirnode(airnode)\n        onlyNonZeroRequester(requester)\n    {\n        airnodeToRequesterToBlockStatus[airnode][requester] = status;\n        emit SetRequesterBlockStatusForAirnode(\n            airnode,\n            requester,\n            status,\n            msg.sender\n        );\n    }\n\n    /// @notice Amount of tokens needed to be whitelisted for the\n    /// Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    function getTokenAmount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId\n    ) public view override returns (uint256 amount) {\n        uint256 endpointPrice = IAirnodeEndpointPriceRegistry(\n            airnodeEndpointPriceRegistry\n        ).getPrice(airnode, chainId, endpointId);\n        amount = (endpointPrice * priceCoefficient) / tokenPrice;\n    }\n\n    /// @notice Called internally to check if the requester is blocked\n    /// @dev Requesters can be blocked globally or for the specific Airnode\n    /// @param airnode Airnode address\n    /// @param requester Requester address\n    function requesterIsBlocked(address airnode, address requester)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            requesterToBlockStatus[requester] ||\n            airnodeToRequesterToBlockStatus[airnode][requester];\n    }\n\n    /// @notice Fetches the RequesterAuthorizer address for the chain\n    /// @dev Reverts if the contract address has not been registered beforehand\n    /// @param chainId Chain ID\n    /// @return RequesterAuthorizer address\n    function getRequesterAuthorizerAddress(uint256 chainId)\n        internal\n        view\n        returns (address)\n    {\n        (\n            bool success,\n            address requesterAuthorizer\n        ) = IRequesterAuthorizerRegistry(requesterAuthorizerRegistry)\n                .tryReadChainRequesterAuthorizer(chainId);\n        require(success, \"No Authorizer set for chain\");\n        return requesterAuthorizer;\n    }\n\n    /// @notice Called privately to set the token price\n    /// @param _tokenPrice Token price in USD (times 10^18)\n    function _setTokenPrice(uint256 _tokenPrice) private {\n        require(_tokenPrice != 0, \"Token price zero\");\n        tokenPrice = _tokenPrice;\n    }\n\n    /// @notice Called privately to set the price coefficient\n    /// @param _priceCoefficient Price coefficient (has the same number of\n    /// decimals as the token)\n    function _setPriceCoefficient(uint256 _priceCoefficient) private {\n        require(_priceCoefficient != 0, \"Price coefficient zero\");\n        priceCoefficient = _priceCoefficient;\n    }\n\n    function _setProceedsDestination(address _proceedsDestination) private {\n        require(\n            _proceedsDestination != address(0),\n            \"Proceeds destination zero\"\n        );\n        proceedsDestination = _proceedsDestination;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/monetization/AirnodeEndpointPriceRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAirnodeEndpointPriceRegistry.sol\";\nimport \"./interfaces/IAirnodeEndpointPriceRegistryUser.sol\";\n\n/// @title Contract to be inherited by contracts that will interact with\n/// AirnodeEndpointPriceRegistry\ncontract AirnodeEndpointPriceRegistryUser is IAirnodeEndpointPriceRegistryUser {\n    /// @notice AirnodeEndpointPriceRegistry contract address\n    address public immutable override airnodeEndpointPriceRegistry;\n\n    /// @param _airnodeEndpointPriceRegistry AirnodeEndpointPriceRegistry\n    /// contract address\n    constructor(address _airnodeEndpointPriceRegistry) {\n        require(\n            _airnodeEndpointPriceRegistry != address(0),\n            \"Price registry address zero\"\n        );\n        airnodeEndpointPriceRegistry = _airnodeEndpointPriceRegistry;\n    }\n}\n"
    },
    "contracts/monetization/RequesterAuthorizerRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IRequesterAuthorizerRegistry.sol\";\nimport \"./interfaces/IRequesterAuthorizerRegistryUser.sol\";\n\n/// @title Contract to be inherited by contracts that will interact with\n/// RequesterAuthorizerRegistry\ncontract RequesterAuthorizerRegistryUser is IRequesterAuthorizerRegistryUser {\n    /// @notice RequesterAuthorizerRegistry contract address\n    address public immutable override requesterAuthorizerRegistry;\n\n    /// @param _requesterAuthorizerRegistry RequesterAuthorizerRegistry contract address\n    constructor(address _requesterAuthorizerRegistry) {\n        require(\n            _requesterAuthorizerRegistry != address(0),\n            \"Authorizer registry address zero\"\n        );\n        requesterAuthorizerRegistry = _requesterAuthorizerRegistry;\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/IRequesterAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAuthorizerV0.sol\";\n\ninterface IRequesterAuthorizer is IAuthorizerV0 {\n    event ExtendedWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external;\n\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function isAuthorized(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    ) external view returns (bool);\n}\n"
    },
    "contracts/monetization/interfaces/IAirnodeEndpointPriceRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAirnodeEndpointPriceRegistry {\n    event RegisterDefaultPrice(uint256 price, address sender);\n\n    event RegisterDefaultChainPrice(\n        uint256 chainId,\n        uint256 price,\n        address sender\n    );\n\n    event RegisterAirnodePrice(address airnode, uint256 price, address sender);\n\n    event RegisterAirnodeChainPrice(\n        address airnode,\n        uint256 chainId,\n        uint256 price,\n        address sender\n    );\n\n    event RegisterAirnodeEndpointPrice(\n        address airnode,\n        bytes32 endpointId,\n        uint256 price,\n        address sender\n    );\n\n    event RegisterAirnodeChainEndpointPrice(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        uint256 price,\n        address sender\n    );\n\n    event SetEndpointAndChainPricePriority(\n        address indexed airnode,\n        bool status,\n        address sender\n    );\n\n    function registerDefaultPrice(uint256 price) external;\n\n    function registerDefaultChainPrice(uint256 chainId, uint256 price) external;\n\n    function registerAirnodePrice(address airnode, uint256 price) external;\n\n    function registerAirnodeChainPrice(\n        address airnode,\n        uint256 chainId,\n        uint256 price\n    ) external;\n\n    function registerAirnodeEndpointPrice(\n        address airnode,\n        bytes32 endpointId,\n        uint256 price\n    ) external;\n\n    function registerAirnodeChainEndpointPrice(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        uint256 price\n    ) external;\n\n    function setEndpointAndChainPricePriority(address airnode, bool status)\n        external;\n\n    function tryReadDefaultPrice()\n        external\n        view\n        returns (bool success, uint256 price);\n\n    function tryReadDefaultChainPrice(uint256 chainId)\n        external\n        view\n        returns (bool success, uint256 price);\n\n    function tryReadAirnodePrice(address airnode)\n        external\n        view\n        returns (bool success, uint256 price);\n\n    function tryReadAirnodeChainPrice(address airnode, uint256 chainId)\n        external\n        view\n        returns (bool success, uint256 price);\n\n    function tryReadAirnodeEndpointPrice(address airnode, bytes32 endpointId)\n        external\n        view\n        returns (bool success, uint256 price);\n\n    function tryReadAirnodeChainEndpointPrice(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId\n    ) external view returns (bool success, uint256 price);\n\n    function getPrice(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId\n    ) external view returns (uint256 price);\n\n    function prioritizeEndpointPriceOverChainPrice(address airnode)\n        external\n        view\n        returns (bool);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DENOMINATION() external view returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DECIMALS() external view returns (uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function PRICING_INTERVAL() external view returns (uint256);\n}\n"
    },
    "contracts/monetization/interfaces/IRequesterAuthorizerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../utils/interfaces/IAddressRegistry.sol\";\n\ninterface IRequesterAuthorizerRegistry is IAddressRegistry {\n    event RegisteredChainRequesterAuthorizer(\n        uint256 chainId,\n        address requesterAuthorizer,\n        address sender\n    );\n\n    function registerChainRequesterAuthorizer(\n        uint256 chainId,\n        address requesterAuthorizer\n    ) external;\n\n    function tryReadChainRequesterAuthorizer(uint256 chainId)\n        external\n        view\n        returns (bool success, address requesterAuthorizer);\n}\n"
    },
    "contracts/utils/interfaces/IAddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IRegistryRolesWithManager.sol\";\n\ninterface IAddressRegistry is IRegistryRolesWithManager {\n    function tryReadRegisteredAddress(bytes32 id)\n        external\n        view\n        returns (bool success, address address_);\n}\n"
    },
    "contracts/utils/interfaces/IRegistryRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminned.sol\";\n\ninterface IRegistryRolesWithManager is IAccessControlRegistryAdminned {\n    // solhint-disable-next-line func-name-mixedcase\n    function REGISTRAR_ROLE_DESCRIPTION() external view returns (string memory);\n\n    function registrarRole() external view returns (bytes32);\n}\n"
    },
    "contracts/authorizers/interfaces/IAuthorizerV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAuthorizerV0 {\n    function isAuthorizedV0(\n        bytes32 requestId,\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool);\n}\n"
    },
    "contracts/monetization/RequesterAuthorizerWhitelisterWithTokenPayment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./RequesterAuthorizerWhitelisterWithToken.sol\";\nimport \"./interfaces/IRequesterAuthorizerWhitelisterWithTokenPayment.sol\";\nimport \"../authorizers/interfaces/IRequesterAuthorizer.sol\";\n\n/// @title RequesterAuthorizer whitelist setter contract that allows users to\n/// pay the respective token to be whitelisted\ncontract RequesterAuthorizerWhitelisterWithTokenPayment is\n    RequesterAuthorizerWhitelisterWithToken,\n    IRequesterAuthorizerWhitelisterWithTokenPayment\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice Minimum whitelist extension\n    uint64 public override minimumWhitelistExtension = 1 days;\n\n    /// @notice Maximum whitelist duration\n    uint64 public override maximumWhitelistDuration = 365 days;\n\n    uint256 private constant PRICING_INTERVAL = 30 days;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    /// @param _airnodeEndpointPriceRegistry AirnodeEndpointPriceRegistry\n    /// contract address\n    /// @param _requesterAuthorizerRegistry RequesterAuthorizerRegistry\n    /// contract address\n    /// @param _token Token contract address\n    /// @param _tokenPrice Token price in USD (times 10^18)\n    /// @param _priceCoefficient Price coefficient (has the same number of\n    /// decimals as the token)\n    /// @param _proceedsDestination Destination of proceeds\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager,\n        address _airnodeEndpointPriceRegistry,\n        address _requesterAuthorizerRegistry,\n        address _token,\n        uint256 _tokenPrice,\n        uint256 _priceCoefficient,\n        address _proceedsDestination\n    )\n        RequesterAuthorizerWhitelisterWithToken(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager,\n            _airnodeEndpointPriceRegistry,\n            _requesterAuthorizerRegistry,\n            _token,\n            _tokenPrice,\n            _priceCoefficient,\n            _proceedsDestination\n        )\n    {\n        require(\n            IAirnodeEndpointPriceRegistry(airnodeEndpointPriceRegistry)\n                .PRICING_INTERVAL() == PRICING_INTERVAL,\n            \"Pricing interval mismatch\"\n        );\n    }\n\n    /// @notice Called by the maintainers or the manager to set the minimum\n    /// whitelist extension\n    /// @param _minimumWhitelistExtension Minimum whitelist extension\n    function setMinimumWhitelistExtension(uint64 _minimumWhitelistExtension)\n        external\n        override\n        onlyMaintainerOrManager\n    {\n        require(\n            _minimumWhitelistExtension <= maximumWhitelistDuration &&\n                _minimumWhitelistExtension != 0,\n            \"Invalid minimum duration\"\n        );\n        minimumWhitelistExtension = _minimumWhitelistExtension;\n        emit SetMinimumWhitelistExtension(\n            _minimumWhitelistExtension,\n            msg.sender\n        );\n    }\n\n    /// @notice Called by the maintainers or the manager to set the maximum\n    /// whitelist duration\n    /// @param _maximumWhitelistDuration Maximum whitelist duration\n    function setMaximumWhitelistDuration(uint64 _maximumWhitelistDuration)\n        external\n        override\n        onlyMaintainerOrManager\n    {\n        require(\n            _maximumWhitelistDuration >= minimumWhitelistExtension,\n            \"Invalid maximum duration\"\n        );\n        maximumWhitelistDuration = _maximumWhitelistDuration;\n        emit SetMaximumWhitelistDuration(_maximumWhitelistDuration, msg.sender);\n    }\n\n    /// @notice Pays tokens to extend the whitelist expiration of the requester\n    /// for the Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param whitelistExtension Whitelist expiration\n    function payTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        uint64 whitelistExtension\n    )\n        external\n        override\n        onlyActiveAirnode(airnode)\n        onlyNonZeroChainId(chainId)\n        onlyNonZeroRequester(requester)\n        onlyNonBlockedRequester(airnode, requester)\n    {\n        require(\n            whitelistExtension >= minimumWhitelistExtension,\n            \"Extension below minimum\"\n        );\n        uint256 tokenPaymentAmount = getTokenPaymentAmount(\n            airnode,\n            chainId,\n            endpointId,\n            whitelistExtension\n        );\n        IRequesterAuthorizer requesterAuthorizer = IRequesterAuthorizer(\n            getRequesterAuthorizerAddress(chainId)\n        );\n        (uint64 currentExpirationTimestamp, ) = requesterAuthorizer\n            .airnodeToEndpointIdToRequesterToWhitelistStatus(\n                airnode,\n                endpointId,\n                requester\n            );\n        uint64 newExpirationTimestamp = currentExpirationTimestamp >\n            block.timestamp\n            ? currentExpirationTimestamp + whitelistExtension\n            : uint64(block.timestamp) + whitelistExtension;\n        require(\n            newExpirationTimestamp - block.timestamp <=\n                maximumWhitelistDuration,\n            \"Exceeds maximum duration\"\n        );\n        emit PaidTokens(\n            airnode,\n            chainId,\n            endpointId,\n            requester,\n            whitelistExtension,\n            msg.sender,\n            newExpirationTimestamp\n        );\n        requesterAuthorizer.setWhitelistExpiration(\n            airnode,\n            endpointId,\n            requester,\n            newExpirationTimestamp\n        );\n        IERC20(token).safeTransferFrom(\n            msg.sender,\n            proceedsDestination,\n            tokenPaymentAmount\n        );\n    }\n\n    /// @notice Resets the whitelist expiration of the blocked requester for\n    /// the Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    function resetWhitelistExpirationOfBlockedRequester(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external override {\n        require(\n            requesterIsBlocked(airnode, requester),\n            \"Requester not blocked\"\n        );\n        emit ResetWhitelistExpirationOfBlockedRequester(\n            airnode,\n            chainId,\n            endpointId,\n            requester,\n            msg.sender\n        );\n        IRequesterAuthorizer(getRequesterAuthorizerAddress(chainId))\n            .setWhitelistExpiration(airnode, endpointId, requester, 0);\n    }\n\n    /// @notice Amount of tokens needed to be paid to extend the whitelist\n    /// expiration for the Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param whitelistExtension Whitelist extension\n    /// @return tokenPaymentAmount Token amount needed to be paid\n    function getTokenPaymentAmount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        uint64 whitelistExtension\n    ) public view override returns (uint256 tokenPaymentAmount) {\n        tokenPaymentAmount =\n            (getTokenAmount(airnode, chainId, endpointId) *\n                whitelistExtension) /\n            PRICING_INTERVAL;\n    }\n}\n"
    },
    "contracts/monetization/interfaces/IRequesterAuthorizerWhitelisterWithTokenPayment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IRequesterAuthorizerWhitelisterWithToken.sol\";\n\ninterface IRequesterAuthorizerWhitelisterWithTokenPayment is\n    IRequesterAuthorizerWhitelisterWithToken\n{\n    event PaidTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        uint64 whitelistExtension,\n        address sender,\n        uint64 newExpirationTimestamp\n    );\n\n    event ResetWhitelistExpirationOfBlockedRequester(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address sender\n    );\n\n    event SetMinimumWhitelistExtension(\n        uint64 minimumWhitelistExtension,\n        address sender\n    );\n\n    event SetMaximumWhitelistDuration(\n        uint64 maximumWhitelistDuration,\n        address sender\n    );\n\n    function payTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        uint64 whitelistExtension\n    ) external;\n\n    function resetWhitelistExpirationOfBlockedRequester(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external;\n\n    function setMinimumWhitelistExtension(uint64 _minimumWhitelistExtension)\n        external;\n\n    function setMaximumWhitelistDuration(uint64 _maximumWhitelistDuration)\n        external;\n\n    function getTokenPaymentAmount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        uint64 whitelistExtension\n    ) external view returns (uint256 tokenPaymentAmount);\n\n    function minimumWhitelistExtension() external view returns (uint64);\n\n    function maximumWhitelistDuration() external view returns (uint64);\n}\n"
    },
    "contracts/monetization/RequesterAuthorizerWhitelisterWithTokenDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./RequesterAuthorizerWhitelisterWithToken.sol\";\nimport \"./interfaces/IRequesterAuthorizerWhitelisterWithTokenDeposit.sol\";\nimport \"../authorizers/interfaces/IRequesterAuthorizer.sol\";\n\n/// @title RequesterAuthorizer indefinite whitelister contract that allows\n/// users to deposit the respective token to be whitelisted\ncontract RequesterAuthorizerWhitelisterWithTokenDeposit is\n    RequesterAuthorizerWhitelisterWithToken,\n    IRequesterAuthorizerWhitelisterWithTokenDeposit\n{\n    using SafeERC20 for IERC20;\n\n    struct TokenDeposits {\n        uint256 count;\n        mapping(address => uint256) depositorToAmount;\n        mapping(address => uint256) depositorToEarliestWithdrawalTime;\n    }\n\n    /// @notice Time the token depositors have to wait after signaling\n    /// withdrawal intent to be able to withdraw\n    /// @dev The depositors can withdraw tokens without signaling intent if the\n    /// withdrawal lead time is zero\n    uint256 public override withdrawalLeadTime = 0;\n\n    /// @notice Token deposits made for Airnode, chain, endpoint, requester\n    mapping(address => mapping(uint256 => mapping(bytes32 => mapping(address => TokenDeposits))))\n        private airnodeToChainIdToEndpointIdToRequesterToTokenDeposits;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    /// @param _airnodeEndpointPriceRegistry AirnodeEndpointPriceRegistry\n    /// contract address\n    /// @param _requesterAuthorizerRegistry RequesterAuthorizerRegistry\n    /// contract address\n    /// @param _token Token contract address\n    /// @param _tokenPrice Token price in USD (times 10^18)\n    /// @param _priceCoefficient Price coefficient (has the same number of\n    /// decimals as the token)\n    /// @param _proceedsDestination Destination of proceeds\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager,\n        address _airnodeEndpointPriceRegistry,\n        address _requesterAuthorizerRegistry,\n        address _token,\n        uint256 _tokenPrice,\n        uint256 _priceCoefficient,\n        address _proceedsDestination\n    )\n        RequesterAuthorizerWhitelisterWithToken(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager,\n            _airnodeEndpointPriceRegistry,\n            _requesterAuthorizerRegistry,\n            _token,\n            _tokenPrice,\n            _priceCoefficient,\n            _proceedsDestination\n        )\n    {}\n\n    /// @notice Called by the manager to set the withdrawal lead time\n    /// @param _withdrawalLeadTime Withdrawal lead time\n    function setWithdrawalLeadTime(uint256 _withdrawalLeadTime)\n        external\n        override\n        onlyMaintainerOrManager\n    {\n        require(\n            _withdrawalLeadTime <= 30 days,\n            \"Withdrawal lead time too long\"\n        );\n        withdrawalLeadTime = _withdrawalLeadTime;\n        emit SetWithdrawalLeadTime(_withdrawalLeadTime, msg.sender);\n    }\n\n    /// @notice Deposits tokens for the requester to be whitelisted for the\n    /// Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    function depositTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    )\n        external\n        override\n        onlyActiveAirnode(airnode)\n        onlyNonZeroChainId(chainId)\n        onlyNonZeroRequester(requester)\n        onlyNonBlockedRequester(airnode, requester)\n    {\n        TokenDeposits\n            storage tokenDeposits = airnodeToChainIdToEndpointIdToRequesterToTokenDeposits[\n                airnode\n            ][chainId][endpointId][requester];\n        require(\n            tokenDeposits.depositorToAmount[msg.sender] == 0,\n            \"Sender already deposited tokens\"\n        );\n        uint256 tokenDepositAmount = getTokenAmount(\n            airnode,\n            chainId,\n            endpointId\n        );\n        tokenDeposits.depositorToAmount[msg.sender] = tokenDepositAmount;\n        uint256 tokenDepositsCount = ++tokenDeposits.count;\n        emit DepositedTokens(\n            airnode,\n            chainId,\n            endpointId,\n            requester,\n            msg.sender,\n            tokenDepositsCount,\n            tokenDepositAmount\n        );\n        if (tokenDepositsCount == 1) {\n            IRequesterAuthorizer(getRequesterAuthorizerAddress(chainId))\n                .setIndefiniteWhitelistStatus(\n                    airnode,\n                    endpointId,\n                    requester,\n                    true\n                );\n        }\n        IERC20(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenDepositAmount\n        );\n    }\n\n    /// @notice Signals intent to withdraw tokens previously deposited for the\n    /// requester to be whitelisted for the Airnode–endpoint pair on the chain\n    /// @dev Withdrawal intent can be signaled for tokens deposited for blocked\n    /// requesters.\n    /// Consider calling `withdrawTokens()` directly if `withdrawalLeadTime` is\n    /// zero.\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    function signalWithdrawalIntent(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external override {\n        TokenDeposits\n            storage tokenDeposits = airnodeToChainIdToEndpointIdToRequesterToTokenDeposits[\n                airnode\n            ][chainId][endpointId][requester];\n        require(\n            tokenDeposits.depositorToAmount[msg.sender] != 0,\n            \"Sender has not deposited tokens\"\n        );\n        require(\n            tokenDeposits.depositorToEarliestWithdrawalTime[msg.sender] == 0,\n            \"Intent already signaled\"\n        );\n        tokenDeposits.depositorToEarliestWithdrawalTime[msg.sender] =\n            block.timestamp +\n            withdrawalLeadTime;\n        uint256 tokenDepositsCount = --tokenDeposits.count;\n        emit SignaledWithdrawalIntent(\n            airnode,\n            chainId,\n            endpointId,\n            requester,\n            msg.sender,\n            tokenDepositsCount\n        );\n        if (tokenDepositsCount == 0) {\n            IRequesterAuthorizer(getRequesterAuthorizerAddress(chainId))\n                .setIndefiniteWhitelistStatus(\n                    airnode,\n                    endpointId,\n                    requester,\n                    false\n                );\n        }\n    }\n\n    /// @notice Withdraws tokens previously deposited for the requester to be\n    /// whitelisted for the Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    function withdrawTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external override onlyNonBlockedRequester(airnode, requester) {\n        TokenDeposits\n            storage tokenDeposits = airnodeToChainIdToEndpointIdToRequesterToTokenDeposits[\n                airnode\n            ][chainId][endpointId][requester];\n        uint256 tokenWithdrawAmount = tokenDeposits.depositorToAmount[\n            msg.sender\n        ];\n        require(tokenWithdrawAmount != 0, \"Sender has not deposited tokens\");\n        tokenDeposits.depositorToAmount[msg.sender] = 0;\n        uint256 earliestWithdrawalTime = tokenDeposits\n            .depositorToEarliestWithdrawalTime[msg.sender];\n        if (withdrawalLeadTime != 0) {\n            require(\n                earliestWithdrawalTime != 0,\n                \"Withdrawal intent not signaled\"\n            );\n            require(\n                earliestWithdrawalTime <= block.timestamp,\n                \"Not withdrawal time yet\"\n            );\n        }\n        if (earliestWithdrawalTime != 0) {\n            uint256 tokenDepositsCount = tokenDeposits.count;\n            emit WithdrewTokens(\n                airnode,\n                chainId,\n                endpointId,\n                requester,\n                msg.sender,\n                tokenDepositsCount,\n                tokenWithdrawAmount\n            );\n        } else {\n            uint256 tokenDepositsCount = --tokenDeposits.count;\n            emit WithdrewTokens(\n                airnode,\n                chainId,\n                endpointId,\n                requester,\n                msg.sender,\n                tokenDepositsCount,\n                tokenWithdrawAmount\n            );\n            if (tokenDepositsCount == 0) {\n                IRequesterAuthorizer(getRequesterAuthorizerAddress(chainId))\n                    .setIndefiniteWhitelistStatus(\n                        airnode,\n                        endpointId,\n                        requester,\n                        false\n                    );\n            }\n        }\n        IERC20(token).safeTransfer(msg.sender, tokenWithdrawAmount);\n    }\n\n    /// @notice Withdraws tokens previously deposited for the blocked requester\n    /// to be whitelisted for the Airnode–endpoint pair on the chain by the\n    /// depositor\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param depositor Depositor address\n    function withdrawFundsDepositedForBlockedRequester(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address depositor\n    ) external override {\n        require(\n            requesterIsBlocked(airnode, requester),\n            \"Requester not blocked\"\n        );\n        TokenDeposits\n            storage tokenDeposits = airnodeToChainIdToEndpointIdToRequesterToTokenDeposits[\n                airnode\n            ][chainId][endpointId][requester];\n        uint256 tokenWithdrawAmount = tokenDeposits.depositorToAmount[\n            depositor\n        ];\n        require(tokenWithdrawAmount != 0, \"Depositor has not deposited\");\n        tokenDeposits.depositorToAmount[depositor] = 0;\n        if (tokenDeposits.depositorToEarliestWithdrawalTime[depositor] == 0) {\n            uint256 tokenDepositsCount = --tokenDeposits.count;\n            emit WithdrewTokensDepositedForBlockedRequester(\n                airnode,\n                chainId,\n                endpointId,\n                requester,\n                depositor,\n                tokenDepositsCount,\n                tokenWithdrawAmount\n            );\n            if (tokenDepositsCount == 0) {\n                IRequesterAuthorizer(getRequesterAuthorizerAddress(chainId))\n                    .setIndefiniteWhitelistStatus(\n                        airnode,\n                        endpointId,\n                        requester,\n                        false\n                    );\n            }\n        } else {\n            uint256 tokenDepositsCount = tokenDeposits.count;\n            tokenDeposits.depositorToEarliestWithdrawalTime[depositor] = 0;\n            emit WithdrewTokensDepositedForBlockedRequester(\n                airnode,\n                chainId,\n                endpointId,\n                requester,\n                depositor,\n                tokenDepositsCount,\n                tokenWithdrawAmount\n            );\n        }\n        IERC20(token).safeTransfer(proceedsDestination, tokenWithdrawAmount);\n    }\n\n    /// @notice Number of deposits made for the requester to be whitelisted for\n    /// the Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    function airnodeToChainIdToEndpointIdToRequesterToTokenDepositsCount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external view override returns (uint256) {\n        return\n            airnodeToChainIdToEndpointIdToRequesterToTokenDeposits[airnode][\n                chainId\n            ][endpointId][requester].count;\n    }\n\n    /// @notice Amount of tokens deposited by the depositor for the requester\n    /// to be whitelisted for the Airnode–endpoint pair on the chain\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param depositor Depositor address\n    function airnodeToChainIdToEndpointIdToRequesterToTokenDepositorToAmount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address depositor\n    ) external view override returns (uint256) {\n        return\n            airnodeToChainIdToEndpointIdToRequesterToTokenDeposits[airnode][\n                chainId\n            ][endpointId][requester].depositorToAmount[depositor];\n    }\n\n    /// @notice Earliest time the depositor is allowed to withdraw tokens\n    /// deposited for the requester to be whitelisted for the Airnode–endpoint\n    /// pair on the chain after the withdrawal intent is signaled\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param depositor Depositor address\n    function airnodeToChainIdToEndpointIdToRequesterToTokenDepositorToEarliestWithdrawalTime(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address depositor\n    ) external view override returns (uint256) {\n        return\n            airnodeToChainIdToEndpointIdToRequesterToTokenDeposits[airnode][\n                chainId\n            ][endpointId][requester].depositorToEarliestWithdrawalTime[\n                    depositor\n                ];\n    }\n}\n"
    },
    "contracts/monetization/interfaces/IRequesterAuthorizerWhitelisterWithTokenDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IRequesterAuthorizerWhitelisterWithToken.sol\";\n\ninterface IRequesterAuthorizerWhitelisterWithTokenDeposit is\n    IRequesterAuthorizerWhitelisterWithToken\n{\n    event SetWithdrawalLeadTime(uint256 withdrawalLeadTime, address sender);\n\n    event DepositedTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address sender,\n        uint256 tokenDepositsCount,\n        uint256 tokenDepositAmount\n    );\n\n    event SignaledWithdrawalIntent(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address sender,\n        uint256 tokenDepositsCount\n    );\n\n    event WithdrewTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address sender,\n        uint256 tokenDepositsCount,\n        uint256 tokenWithdrawAmount\n    );\n\n    event WithdrewTokensDepositedForBlockedRequester(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address depositor,\n        uint256 tokenDepositsCount,\n        uint256 tokenWithdrawAmount\n    );\n\n    function setWithdrawalLeadTime(uint256 _withdrawalLeadTime) external;\n\n    function depositTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external;\n\n    function signalWithdrawalIntent(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external;\n\n    function withdrawTokens(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external;\n\n    function withdrawFundsDepositedForBlockedRequester(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address depositor\n    ) external;\n\n    function airnodeToChainIdToEndpointIdToRequesterToTokenDepositsCount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester\n    ) external view returns (uint256);\n\n    function airnodeToChainIdToEndpointIdToRequesterToTokenDepositorToAmount(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address depositor\n    ) external view returns (uint256);\n\n    function airnodeToChainIdToEndpointIdToRequesterToTokenDepositorToEarliestWithdrawalTime(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        address requester,\n        address depositor\n    ) external view returns (uint256);\n\n    function withdrawalLeadTime() external view returns (uint256);\n}\n"
    },
    "contracts/utils/OwnableCallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IOwnableCallForwarder.sol\";\n\n/// @title Contract that forwards the calls that its owner sends\n/// @dev AccessControlRegistry users that want their access control tables\n/// to be transferrable (e.g., a DAO) will use this forwarder instead of\n/// interacting with it directly. There are cases where this transferrability\n/// is not desired, e.g., if the user is an Airnode and is immutably associated\n/// with a single address, in which case the manager will interact with\n/// AccessControlRegistry directly.\n/// The ownership of this contract is deliberately renouncable. If this does\n/// suit the use case, override and disable this functionality.\ncontract OwnableCallForwarder is Ownable, IOwnableCallForwarder {\n    /// @notice Forwards the calldata and the value to the target address if\n    /// the sender is the owner and returns the data\n    /// @param forwardTarget Target address that the calldata will be forwarded\n    /// to\n    /// @param forwardedCalldata Calldata to be forwarded to the target address\n    /// @return returnedData Data returned by the forwarded call\n    function forwardCall(\n        address forwardTarget,\n        bytes calldata forwardedCalldata\n    ) external payable override onlyOwner returns (bytes memory returnedData) {\n        returnedData = Address.functionCallWithValue(\n            forwardTarget,\n            forwardedCalldata,\n            msg.value\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/utils/interfaces/IOwnableCallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnableCallForwarder {\n    function forwardCall(\n        address forwardTarget,\n        bytes calldata forwardedCalldata\n    ) external payable returns (bytes memory returnedData);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/monetization/mock/MockERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 private immutable _decimals;\n\n    constructor(uint8 __decimals) ERC20(\"Mock ERC20\", \"MOCK\") {\n        _decimals = __decimals;\n        _mint(msg.sender, 100 ether);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/protocol/WithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./interfaces/IWithdrawalUtils.sol\";\n\n/// @title Contract that can be used by sponsors to request withdrawals from\n/// sponsor wallets and Airnodes/relayers to fulfill these\n/// @notice The respective Airnode/relayer may not support withdrawals for the\n/// specified protocol, or at all. Similarly, an Airnode/relayer may deposit\n/// funds directly to the sponsor address without being prompted, e.g., because\n/// they are ceasing operations. In general, no guarantee is provided for the\n/// funds deposited to sponsor wallets at the protocol level. Therefore, the\n/// sponsors should limit their deposits to the minimum amount required for\n/// their operations, and assume they will not receive these funds back.\n/// @dev Withdrawals are implemented in the form of pull payments. The sponsor\n/// requests a withdrawal from a sponsor wallet, and the Airnode/relayer uses\n/// the specified sponsor wallet to deposit the entire balance at this\n/// contract. Then, the sponsor claims/pulls the payment from this contract.\n/// Different protocols (RRP, PSP, etc.) use different sponsor wallets for a\n/// particular Airnode/relayer–sponsor pair, which is why sponsor wallet\n/// derivation includes a protocol ID. Refer to the node documentation for what\n/// these protocol IDs are.\ncontract WithdrawalUtils is IWithdrawalUtils {\n    using ECDSA for bytes32;\n\n    /// @notice Sponsor balance that is withdrawn but not claimed\n    mapping(address => uint256) public override sponsorToBalance;\n\n    /// @notice Number of withdrawal requests the sponsor made\n    /// @dev This can be used to calculate the ID of the next withdrawal\n    /// request the sponsor will make\n    mapping(address => uint256) public override sponsorToWithdrawalRequestCount;\n\n    mapping(bytes32 => bytes32) private withdrawalRequestIdToParameters;\n\n    /// @notice Called by a sponsor to request a withdrawal\n    /// @param airnodeOrRelayer Airnode/relayer address\n    /// @param protocolId Protocol ID\n    function requestWithdrawal(address airnodeOrRelayer, uint256 protocolId)\n        external\n        override\n    {\n        require(airnodeOrRelayer != address(0), \"Airnode/relayer address zero\");\n        require(protocolId != 0, \"Protocol ID zero\");\n        bytes32 withdrawalRequestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                ++sponsorToWithdrawalRequestCount[msg.sender]\n            )\n        );\n        withdrawalRequestIdToParameters[withdrawalRequestId] = keccak256(\n            abi.encodePacked(airnodeOrRelayer, protocolId, msg.sender)\n        );\n        emit RequestedWithdrawal(\n            airnodeOrRelayer,\n            msg.sender,\n            withdrawalRequestId,\n            protocolId\n        );\n    }\n\n    /// @notice Called by the Airnode/relayer using the sponsor wallet to\n    /// fulfill the withdrawal request made by the sponsor\n    /// @param withdrawalRequestId Withdrawal request ID\n    /// @param airnodeOrRelayer Airnode/relayer address\n    /// @param protocolId Protocol ID\n    /// @param sponsor Sponsor address\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnodeOrRelayer,\n        uint256 protocolId,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata signature\n    ) external payable override {\n        require(\n            withdrawalRequestIdToParameters[withdrawalRequestId] ==\n                keccak256(\n                    abi.encodePacked(airnodeOrRelayer, protocolId, sponsor)\n                ),\n            \"Invalid withdrawal fulfillment\"\n        );\n        require(\n            timestamp + 1 hours > block.timestamp &&\n                timestamp < block.timestamp + 15 minutes,\n            \"Timestamp not valid\"\n        );\n        require(\n            (\n                keccak256(\n                    abi.encodePacked(withdrawalRequestId, timestamp, msg.sender)\n                ).toEthSignedMessageHash()\n            ).recover(signature) == airnodeOrRelayer,\n            \"Signature mismatch\"\n        );\n        delete withdrawalRequestIdToParameters[withdrawalRequestId];\n        sponsorToBalance[sponsor] += msg.value;\n        emit FulfilledWithdrawal(\n            airnodeOrRelayer,\n            sponsor,\n            withdrawalRequestId,\n            protocolId,\n            msg.sender,\n            msg.value\n        );\n    }\n\n    /// @notice Called by the sponsor to claim the withdrawn funds\n    /// @dev The sponsor must be able to receive funds. For example, if the\n    /// sponsor is a contract without a default `payable` function, this will\n    /// revert.\n    function claimBalance() external override {\n        uint256 sponsorBalance = sponsorToBalance[msg.sender];\n        require(sponsorBalance != 0, \"Sender balance zero\");\n        sponsorToBalance[msg.sender] = 0;\n        emit ClaimedBalance(msg.sender, sponsorBalance);\n        (bool success, ) = msg.sender.call{value: sponsorBalance}(\"\"); // solhint-disable-line avoid-low-level-calls\n        require(success, \"Transfer failed\");\n    }\n\n    /// @notice Returns if the withdrawal request with the ID is made but not\n    /// fulfilled yet\n    /// @param withdrawalRequestId Withdrawal request ID\n    /// @return isAwaitingFulfillment If the withdrawal request is awaiting\n    /// fulfillment\n    function withdrawalRequestIsAwaitingFulfillment(bytes32 withdrawalRequestId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return\n            withdrawalRequestIdToParameters[withdrawalRequestId] != bytes32(0);\n    }\n}\n"
    },
    "contracts/protocol/interfaces/IWithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWithdrawalUtils {\n    event RequestedWithdrawal(\n        address indexed airnodeOrRelayer,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        uint256 protocolId\n    );\n\n    event FulfilledWithdrawal(\n        address indexed airnodeOrRelayer,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        uint256 protocolId,\n        address sponsorWallet,\n        uint256 amount\n    );\n\n    event ClaimedBalance(address indexed sponsor, uint256 amount);\n\n    function requestWithdrawal(address airnodeOrRelayer, uint256 protocolId)\n        external;\n\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnodeOrRelayer,\n        uint256 protocolId,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata signature\n    ) external payable;\n\n    function claimBalance() external;\n\n    function withdrawalRequestIsAwaitingFulfillment(bytes32 withdrawalRequestId)\n        external\n        view\n        returns (bool);\n\n    function sponsorToBalance(address sponsor) external view returns (uint256);\n\n    function sponsorToWithdrawalRequestCount(address sponsor)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/protocol/interfaces/IAirnodeProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IStorageUtils.sol\";\nimport \"./ISponsorshipUtils.sol\";\nimport \"./IWithdrawalUtils.sol\";\n\ninterface IAirnodeProtocol is\n    IStorageUtils,\n    ISponsorshipUtils,\n    IWithdrawalUtils\n{\n    event MadeRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        address requester,\n        uint256 requesterRequestCount,\n        bytes32 templateId,\n        bytes parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    );\n\n    event FulfilledRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 timestamp,\n        bytes data\n    );\n\n    event FailedRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 timestamp,\n        string errorMessage\n    );\n\n    event MadeRequestRelayed(\n        address indexed relayer,\n        bytes32 indexed requestId,\n        address indexed airnode,\n        address requester,\n        uint256 requesterRequestCount,\n        bytes32 templateId,\n        bytes parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    );\n\n    event FulfilledRequestRelayed(\n        address indexed relayer,\n        bytes32 indexed requestId,\n        address indexed airnode,\n        uint256 timestamp,\n        bytes data\n    );\n\n    event FailedRequestRelayed(\n        address indexed relayer,\n        bytes32 indexed requestId,\n        address indexed airnode,\n        uint256 timestamp,\n        string errorMessage\n    );\n\n    function makeRequest(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 requestId);\n\n    function fulfillRequest(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function failRequest(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        string calldata errorMessage,\n        bytes calldata signature\n    ) external;\n\n    function makeRequestRelayed(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address relayer,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 requestId);\n\n    function fulfillRequestRelayed(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        address relayer,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function failRequestRelayed(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        address relayer,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        string calldata errorMessage,\n        bytes calldata signature\n    ) external;\n\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        returns (bool);\n\n    function requesterToRequestCount(address requester)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/protocol/interfaces/IStorageUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IStorageUtils {\n    event StoredTemplate(\n        bytes32 indexed templateId,\n        bytes32 endpointId,\n        bytes parameters\n    );\n\n    event StoredSubscription(\n        bytes32 indexed subscriptionId,\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes parameters,\n        bytes conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    );\n\n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        returns (bytes32 templateId);\n\n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 subscriptionId);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MAXIMUM_PARAMETER_LENGTH() external view returns (uint256);\n\n    function templates(bytes32 templateId)\n        external\n        view\n        returns (bytes32 endpointId, bytes memory parameters);\n\n    function subscriptions(bytes32 subscriptionId)\n        external\n        view\n        returns (\n            uint256 chainId,\n            address airnode,\n            bytes32 templateId,\n            bytes memory parameters,\n            bytes memory conditions,\n            address relayer,\n            address sponsor,\n            address requester,\n            bytes4 fulfillFunctionId\n        );\n}\n"
    },
    "contracts/protocol/interfaces/ISponsorshipUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISponsorshipUtils {\n    event SetRrpSponsorshipStatus(\n        address indexed sponsor,\n        address indexed requester,\n        bool status\n    );\n\n    event SetPspSponsorshipStatus(\n        address indexed sponsor,\n        bytes32 indexed subscriptionId,\n        bool status\n    );\n\n    function setRrpSponsorshipStatus(address requester, bool status) external;\n\n    function setPspSponsorshipStatus(bytes32 subscriptionId, bool status)\n        external;\n\n    function sponsorToRequesterToRrpSponsorshipStatus(\n        address sponsor,\n        address requester\n    ) external view returns (bool status);\n\n    function sponsorToSubscriptionIdToPspSponsorshipStatus(\n        address sponsor,\n        bytes32 subscriptionId\n    ) external view returns (bool status);\n}\n"
    },
    "contracts/protocol/AirnodeProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./StorageUtils.sol\";\nimport \"./SponsorshipUtils.sol\";\nimport \"./WithdrawalUtils.sol\";\nimport \"../utils/ExtendedMulticall.sol\";\nimport \"./interfaces/IAirnodeProtocol.sol\";\n\n/// @title Airnode request–response protocol (RRP) and its relayed version\n/// @notice Similar to HTTP, RRP allows the requester to specify a one-off\n/// request that the Airnode is expected to respond to as soon as possible.\n/// The relayed version allows the requester to specify an Airnode that will\n/// sign the fulfillment data and a relayer that will report the signed\n/// fulfillment.\n/// @dev This contract inherits Multicall for Airnodes to be able to make batch\n/// static calls to read sponsorship states, and template and subscription\n/// details.\n/// StorageUtils, SponsorshipUtils and WithdrawalUtils also implement some\n/// auxiliary functionality for PSP.\ncontract AirnodeProtocol is\n    StorageUtils,\n    SponsorshipUtils,\n    WithdrawalUtils,\n    ExtendedMulticall,\n    IAirnodeProtocol\n{\n    using ECDSA for bytes32;\n\n    /// @notice Number of requests the requester made\n    /// @dev This can be used to calculate the ID of the next request that the\n    /// requester will make\n    mapping(address => uint256) public override requesterToRequestCount;\n\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\n\n    /// @notice Called by the requester to make a request\n    /// @param templateId Template ID\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    /// @param sponsor Sponsor address\n    /// @param fulfillFunctionId Selector of the function to be called for\n    /// fulfillment\n    /// @return requestId Request ID\n    function makeRequest(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 requestId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(templateId != bytes32(0), \"Template ID zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        uint256 requesterRequestCount = ++requesterToRequestCount[msg.sender];\n        requestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                requesterRequestCount,\n                airnode,\n                templateId,\n                parameters,\n                sponsor,\n                fulfillFunctionId\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(airnode, msg.sender, fulfillFunctionId)\n        );\n        emit MadeRequest(\n            airnode,\n            requestId,\n            msg.sender,\n            requesterRequestCount,\n            templateId,\n            parameters,\n            sponsor,\n            fulfillFunctionId\n        );\n    }\n\n    /// @notice Called by the Airnode using the sponsor wallet to fulfill the\n    /// request\n    /// @dev Airnodes attest to controlling their respective sponsor wallets by\n    /// signing a message with the address of the sponsor wallet. A timestamp\n    /// is added to this signature for it to act as an expiring token if the\n    /// requester contract checks for freshness.\n    /// This will not revert depending on the external call. However, it will\n    /// return `false` if the external call reverts or if there is no function\n    /// with a matching signature at `fulfillAddress`. On the other hand, it\n    /// will return `true` if the external call returns successfully or if\n    /// there is no contract deployed at `fulfillAddress`.\n    /// If `callSuccess` is `false`, `callData` can be decoded to retrieve the\n    /// revert string.\n    /// This function emits its event after an untrusted low-level call,\n    /// meaning that the log indices of these events may be off.\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param requester Requester address\n    /// @param fulfillFunctionId Selector of the function to be called for\n    /// fulfillment\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data, encoded in contract ABI\n    /// @param signature Request ID, a timestamp and the sponsor wallet address\n    /// signed by the Airnode wallet\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfillRequest(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override returns (bool callSuccess, bytes memory callData) {\n        require(\n            keccak256(\n                abi.encodePacked(airnode, requester, fulfillFunctionId)\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        require(\n            (\n                keccak256(abi.encodePacked(requestId, timestamp, msg.sender))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Signature mismatch\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        (callSuccess, callData) = requester.call( // solhint-disable-line avoid-low-level-calls\n            abi.encodeWithSelector(\n                fulfillFunctionId,\n                requestId,\n                timestamp,\n                data\n            )\n        );\n        if (callSuccess) {\n            emit FulfilledRequest(airnode, requestId, timestamp, data);\n        } else {\n            // We do not bubble up the revert string from `callData`\n            emit FailedRequest(\n                airnode,\n                requestId,\n                timestamp,\n                \"Fulfillment failed unexpectedly\"\n            );\n        }\n    }\n\n    /// @notice Called by the Airnode using the sponsor wallet if the request\n    /// cannot be fulfilled\n    /// @dev The Airnode should fall back to this if a request cannot be\n    /// fulfilled because of an error, including the static call to `fulfill()`\n    /// returning `false` for `callSuccess`.\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param requester Requester address\n    /// @param fulfillFunctionId Selector of the function to be called for\n    /// fulfillment\n    /// @param timestamp Timestamp used in the signature\n    /// @param errorMessage A message that explains why the request has failed\n    /// @param signature Request ID, a timestamp and the sponsor wallet address\n    /// signed by the Airnode address\n    function failRequest(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        string calldata errorMessage,\n        bytes calldata signature\n    ) external override {\n        require(\n            keccak256(\n                abi.encodePacked(airnode, requester, fulfillFunctionId)\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        require(\n            (\n                keccak256(abi.encodePacked(requestId, timestamp, msg.sender))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Signature mismatch\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        emit FailedRequest(airnode, requestId, timestamp, errorMessage);\n    }\n\n    /// @notice Called by the requester to make a request to be fulfilled by a\n    /// relayer\n    /// @dev The relayer address indexed in the relayed protocol logs because\n    /// it will be the relayer that will be listening to these logs\n    /// @param templateId Template ID\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @param fulfillFunctionId Selector of the function to be called for\n    /// fulfillment\n    /// @return requestId Request ID\n    function makeRequestRelayed(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address relayer,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 requestId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(templateId != bytes32(0), \"Template ID zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        uint256 requesterRequestCount = ++requesterToRequestCount[msg.sender];\n        requestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                requesterRequestCount,\n                airnode,\n                templateId,\n                parameters,\n                relayer,\n                sponsor,\n                fulfillFunctionId\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(airnode, msg.sender, relayer, fulfillFunctionId)\n        );\n        emit MadeRequestRelayed(\n            relayer,\n            requestId,\n            airnode,\n            msg.sender,\n            requesterRequestCount,\n            templateId,\n            parameters,\n            sponsor,\n            fulfillFunctionId\n        );\n    }\n\n    /// @notice Called by the relayer using the sponsor wallet to fulfill the\n    /// request with the Airnode-signed response\n    /// @dev The Airnode must verify the integrity of the request details,\n    /// template details, sponsor address–sponsor wallet address consistency\n    /// before signing the response\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param requester Requester address\n    /// @param relayer Relayer address\n    /// @param fulfillFunctionId Selector of the function to be called for\n    /// fulfillment\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data\n    /// @param signature Request ID, a timestamp, the sponsor wallet address\n    /// and the fulfillment data signed by the Airnode address\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfillRequestRelayed(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        address relayer,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override returns (bool callSuccess, bytes memory callData) {\n        require(\n            keccak256(\n                abi.encodePacked(airnode, requester, relayer, fulfillFunctionId)\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        require(\n            (\n                keccak256(\n                    abi.encodePacked(requestId, timestamp, msg.sender, data)\n                ).toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Signature mismatch\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        (callSuccess, callData) = requester.call( // solhint-disable-line avoid-low-level-calls\n            abi.encodeWithSelector(\n                fulfillFunctionId,\n                requestId,\n                timestamp,\n                data\n            )\n        );\n        if (callSuccess) {\n            emit FulfilledRequestRelayed(\n                relayer,\n                requestId,\n                airnode,\n                timestamp,\n                data\n            );\n        } else {\n            // We do not bubble up the revert string from `callData`\n            emit FailedRequestRelayed(\n                relayer,\n                requestId,\n                airnode,\n                timestamp,\n                \"Fulfillment failed unexpectedly\"\n            );\n        }\n    }\n\n    /// @notice Called by the relayer using the sponsor wallet if the request\n    /// cannot be fulfilled\n    /// @dev Since failure may also include problems at the Airnode end (such\n    /// as it being unavailable), we are content with a signature from the\n    /// relayer to validate failures. This is acceptable because explicit\n    /// failures are mainly for easy debugging of issues, and the requester\n    /// should always consider denial of service from a relayer or an Airnode\n    /// to be a possibility.\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param requester Requester address\n    /// @param relayer Relayer address\n    /// @param timestamp Timestamp used in the signature\n    /// @param errorMessage A message that explains why the request has failed\n    /// @param signature Request ID, a timestamp and the sponsor wallet address\n    /// signed by the relayer address\n    function failRequestRelayed(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        address relayer,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        string calldata errorMessage,\n        bytes calldata signature\n    ) external override {\n        require(\n            keccak256(\n                abi.encodePacked(airnode, requester, relayer, fulfillFunctionId)\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        require(\n            (\n                keccak256(abi.encodePacked(requestId, timestamp, msg.sender))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == relayer,\n            \"Signature mismatch\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        emit FailedRequestRelayed(\n            relayer,\n            requestId,\n            airnode,\n            timestamp,\n            errorMessage\n        );\n    }\n\n    /// @notice Returns if the request with the ID is made but not\n    /// fulfilled/failed yet\n    /// @dev If a requester has made a request, received a request ID but did\n    /// not hear back, it can call this method to check if the Airnode/relayer\n    /// called back `failRequest()`/`failRequestRelayed()` instead.\n    /// @param requestId Request ID\n    /// @return If the request is awaiting fulfillment\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return requestIdToFulfillmentParameters[requestId] != bytes32(0);\n    }\n}\n"
    },
    "contracts/protocol/StorageUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./interfaces/IStorageUtils.sol\";\n\n/// @title Contract that can be used to store template and subscriptions\n/// details on-chain\n/// @notice The Airnode protocol does not depend on the templates or\n/// subscriptions to be stored on-chain, which means using this functionality\n/// is entirely optional. However, if you are not storing your templates or\n/// subscriptions on-chain, you should make sure that the respective Airnode\n/// already knows about them (e.g., their details are hardcoded in the\n/// Airnode configuration file).\n/// @dev Templates and subscriptions need to persist, which is why we do not\n/// depend on storing them in logs and the respective Airnode being able to\n/// retrieve them from there. Compared to that, storage is a much safer bet.\n/// However, this may end up being prohibitively expensive on some chains, in\n/// which case the user should consider off-chain channels to pass the details.\ncontract StorageUtils is IStorageUtils {\n    struct Template {\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    struct Subscription {\n        uint256 chainId;\n        address airnode;\n        bytes32 templateId;\n        bytes parameters;\n        bytes conditions;\n        address relayer;\n        address sponsor;\n        address requester;\n        bytes4 fulfillFunctionId;\n    }\n\n    /// @notice Maximum parameter length for byte strings that Airnodes will\n    /// need to read from storage or logs\n    /// @dev A very generous limit is applied, under the assumption that\n    /// anything larger than this is a grief attempt. If the user needs to use\n    /// longer parameters, they will need to use off-chain channels to pass\n    /// the respective template/subscription details to the Airnode operator\n    /// for them to be specified in the configuration file.\n    uint256 public constant override MAXIMUM_PARAMETER_LENGTH = 4096;\n\n    /// @notice Template details with the ID\n    mapping(bytes32 => Template) public override templates;\n\n    /// @notice Subscription details with the ID\n    mapping(bytes32 => Subscription) public override subscriptions;\n\n    /// @notice Stores template details\n    /// @dev Templates fully or partially define requests. By referencing a\n    /// template, requesters can omit specifying the \"boilerplate\" sections of\n    /// requests.\n    /// A zero endpoint ID means the Airnode does not need to use one of its\n    /// endpoints, and can move directly on to fulfillment. This is\n    /// particularly useful for defining traditional keeper jobs that do not\n    /// require off-chain data.\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param parameters Template parameters, encoded in Airnode ABI\n    /// @return templateId Template ID\n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        templateId = keccak256(abi.encodePacked(endpointId, parameters));\n        templates[templateId] = Template({\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit StoredTemplate(templateId, endpointId, parameters);\n    }\n\n    /// @notice Stores subscription details\n    /// @dev `airnode` should make the query specified by `templateId` and\n    /// `parameters`. If the returned data satisfies `conditions`, it should\n    /// call `requester`'s `fulfillFunctionId` on `chainId` with the returned\n    /// data, using the wallet dedicated to `sponsor`.\n    /// If `relayer` is not `airnode`, the relayer is responsible with checking\n    /// `condition` and using the wallet dedicated to `sponsor` to deliver the\n    /// data.\n    /// In most cases, `conditions` will specify a static call to a function on\n    /// `chainId` with the data. The extent of its flexibility depends on the\n    /// node implementation and is outside the scope of the on-chain protocol.\n    /// Similarly, `conditions` can specify with what frequency it should be\n    /// verified, and the details of this is outside the scope.\n    /// `templateId` being zero is similar to the endpoint ID being zero for\n    /// templates, means the endpoint query can be skipped. In this case,\n    /// `parameters` will be treated as the data that is returned by the\n    /// endpoint while verifying `conditions`.\n    /// @param chainId Chain ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID (allowed to be `bytes32(0)`)\n    /// @param parameters Parameters provided by the subscription in addition\n    /// to the parameters in the template, encoded in Airnode ABI\n    /// @param conditions Conditions under which the subscription is requested\n    /// to be fulfilled, encoded in Airnode ABI\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @param fulfillFunctionId Selector of the function to be called for\n    /// fulfillment\n    /// @return subscriptionId Subscription ID\n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external override returns (bytes32 subscriptionId) {\n        require(chainId != 0, \"Chain ID zero\");\n        require(airnode != address(0), \"Airnode address zero\");\n        require(\n            parameters.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Parameters too long\"\n        );\n        require(\n            conditions.length <= MAXIMUM_PARAMETER_LENGTH,\n            \"Conditions too long\"\n        );\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(fulfillFunctionId != bytes4(0), \"Fulfill function ID zero\");\n        subscriptionId = keccak256(\n            abi.encode(\n                chainId,\n                airnode,\n                templateId,\n                parameters,\n                conditions,\n                relayer,\n                sponsor,\n                requester,\n                fulfillFunctionId\n            )\n        );\n        subscriptions[subscriptionId] = Subscription({\n            chainId: chainId,\n            airnode: airnode,\n            templateId: templateId,\n            parameters: parameters,\n            conditions: conditions,\n            relayer: relayer,\n            sponsor: sponsor,\n            requester: requester,\n            fulfillFunctionId: fulfillFunctionId\n        });\n        emit StoredSubscription(\n            subscriptionId,\n            chainId,\n            airnode,\n            templateId,\n            parameters,\n            conditions,\n            relayer,\n            sponsor,\n            requester,\n            fulfillFunctionId\n        );\n    }\n}\n"
    },
    "contracts/protocol/SponsorshipUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./interfaces/ISponsorshipUtils.sol\";\n\n/// @title Contract that sponsors can use to announce their willingness to\n/// sponsor a particular RRP requester or PSP subscription\n/// @notice The sponsorship status is not checked during requests or\n/// fulfillments, which means the respective Airnode is trusted to make this\n/// check through a static call to this contract. The Airnode may skip this\n/// check if it has received an off-chain assurance.\n/// @dev An Airnode (or relayer) has a \"sponsor wallet\" dedicated for each\n/// account through an HD wallet. When a requester makes a request specifying a\n/// sponsor, the Airnode verifies the sponsorship my making a static call to\n/// this contract, and uses the respective sponsor wallet to fulfill the\n/// request. This allows the sponsor to cover the gas costs of the\n/// fulfillments, as they know that funds they have deposited in the respective\n/// sponsor wallet will only be used for use-cases they have sponsored.\ncontract SponsorshipUtils is ISponsorshipUtils {\n    /// @notice Sponsorship status for a sponsor–RRP requester pair\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToRequesterToRrpSponsorshipStatus;\n\n    /// @notice Sponsorship status for a sponsor–PSP subscription pair\n    mapping(address => mapping(bytes32 => bool))\n        public\n        override sponsorToSubscriptionIdToPspSponsorshipStatus;\n\n    /// @notice Called by the sponsor to set the sponsorship status of an RRP\n    /// requester\n    /// @dev This applies for both regular and relayed RRP requests.\n    /// In all contracts, we use the \"set\" verb to refer to setting a value\n    /// without considering its previous value, and emitting an event whether\n    /// a state change has occurred or not.\n    /// @param requester RRP requester address\n    /// @param status Sponsorship status\n    function setRrpSponsorshipStatus(address requester, bool status)\n        external\n        override\n    {\n        require(requester != address(0), \"Requester address zero\");\n        sponsorToRequesterToRrpSponsorshipStatus[msg.sender][\n            requester\n        ] = status;\n        emit SetRrpSponsorshipStatus(msg.sender, requester, status);\n    }\n\n    /// @notice Called by the sponsor to set the sponsorship status of a PSP\n    /// subscription\n    /// @param subscriptionId Subscription ID\n    /// @param status Sponsorship status\n    function setPspSponsorshipStatus(bytes32 subscriptionId, bool status)\n        external\n        override\n    {\n        require(subscriptionId != bytes32(0), \"Subscription ID zero\");\n        sponsorToSubscriptionIdToPspSponsorshipStatus[msg.sender][\n            subscriptionId\n        ] = status;\n        emit SetPspSponsorshipStatus(msg.sender, subscriptionId, status);\n    }\n}\n"
    },
    "contracts/utils/ExtendedMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\n/// @notice Contract that extends the functionality of Multicall to cover the\n/// retrieval of some globally available variables\ncontract ExtendedMulticall is Multicall {\n    /// @notice Returns the chain ID\n    /// @return Chain ID\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n\n    /// @notice Returns the account balance\n    /// @param account Account address\n    /// @return Account balance\n    function getBalance(address account) external view returns (uint256) {\n        return account.balance;\n    }\n\n    /// @notice Returns the current block number\n    /// @return Current block number\n    function getBlockNumber() external view returns (uint256) {\n        return block.number;\n    }\n\n    /// @notice Returns the current block timestamp\n    /// @return Current block timestamp\n    function getBlockTimestamp() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @notice Returns the current block basefee\n    /// @return Current block basefee\n    function getBlockBasefee() external view returns (uint256) {\n        return block.basefee;\n    }\n}\n"
    },
    "contracts/whitelist/WhitelistRolesWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./WhitelistRoles.sol\";\nimport \"../access-control-registry/AccessControlRegistryAdminned.sol\";\nimport \"./interfaces/IWhitelistRolesWithAirnode.sol\";\nimport \"../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// roles where each individual Airnode address is its own manager\ncontract WhitelistRolesWithAirnode is\n    WhitelistRoles,\n    AccessControlRegistryAdminned,\n    IWhitelistRolesWithAirnode\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    )\n        AccessControlRegistryAdminned(\n            _accessControlRegistry,\n            _adminRoleDescription\n        )\n    {}\n\n    /// @notice Derives the admin role for the Airnode\n    /// @param airnode Airnode address\n    /// @return adminRole Admin role\n    function deriveAdminRole(address airnode)\n        external\n        view\n        override\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveAdminRole(airnode);\n    }\n\n    /// @notice Derives the whitelist expiration extender role for the Airnode\n    /// @param airnode Airnode address\n    /// @return whitelistExpirationExtenderRole Whitelist expiration extender\n    /// role\n    function deriveWhitelistExpirationExtenderRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 whitelistExpirationExtenderRole)\n    {\n        whitelistExpirationExtenderRole = _deriveRole(\n            _deriveAdminRole(airnode),\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @notice Derives the whitelist expiration setter role for the Airnode\n    /// @param airnode Airnode address\n    /// @return whitelistExpirationSetterRole Whitelist expiration setter role\n    function deriveWhitelistExpirationSetterRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 whitelistExpirationSetterRole)\n    {\n        whitelistExpirationSetterRole = _deriveRole(\n            _deriveAdminRole(airnode),\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @notice Derives the indefinite whitelister role for the Airnode\n    /// @param airnode Airnode address\n    /// @return indefiniteWhitelisterRole Indefinite whitelister role\n    function deriveIndefiniteWhitelisterRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 indefiniteWhitelisterRole)\n    {\n        indefiniteWhitelisterRole = _deriveRole(\n            _deriveAdminRole(airnode),\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @dev Returns if the account has the whitelist expiration extender role\n    /// or is the Airnode address\n    /// @param airnode Airnode address\n    /// @param account Account address\n    /// @return If the account has the whitelist extender role or is the\n    /// Airnode address\n    function hasWhitelistExpirationExtenderRoleOrIsAirnode(\n        address airnode,\n        address account\n    ) internal view returns (bool) {\n        return\n            airnode == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                deriveWhitelistExpirationExtenderRole(airnode),\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the whitelist expriation setter role or\n    /// is the Airnode address\n    /// @param airnode Airnode address\n    /// @param account Account address\n    /// @return If the account has the whitelist setter role or is the Airnode\n    /// address\n    function hasWhitelistExpirationSetterRoleOrIsAirnode(\n        address airnode,\n        address account\n    ) internal view returns (bool) {\n        return\n            airnode == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                deriveWhitelistExpirationSetterRole(airnode),\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the indefinite whitelister role or is the\n    /// Airnode address\n    /// @param airnode Airnode address\n    /// @param account Account address\n    /// @return If the account has the indefinite whitelister role or is the\n    /// Airnode addrss\n    function hasIndefiniteWhitelisterRoleOrIsAirnode(\n        address airnode,\n        address account\n    ) internal view returns (bool) {\n        return\n            airnode == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                deriveIndefiniteWhitelisterRole(airnode),\n                account\n            );\n    }\n}\n"
    },
    "contracts/whitelist/interfaces/IWhitelistRolesWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRoles.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminned.sol\";\n\ninterface IWhitelistRolesWithAirnode is\n    IWhitelistRoles,\n    IAccessControlRegistryAdminned\n{\n    function deriveAdminRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveWhitelistExpirationExtenderRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveWhitelistExpirationSetterRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveIndefiniteWhitelisterRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n}\n"
    },
    "contracts/utils/AddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./RegistryRolesWithManager.sol\";\nimport \"./interfaces/IAddressRegistry.sol\";\n\n/// @title Contract to be inherited by contracts that need a registry wit\n/// manager that maps IDs to addresses\ncontract AddressRegistry is RegistryRolesWithManager, IAddressRegistry {\n    mapping(bytes32 => address) private idToAddress;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        RegistryRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Returns if there is a registered address with the ID and the\n    /// registered address and what it is\n    /// @param id Registry ID\n    /// @return success If there is a registered address with the ID\n    /// @return address_ Registered address\n    function tryReadRegisteredAddress(bytes32 id)\n        public\n        view\n        override\n        returns (bool success, address address_)\n    {\n        address_ = idToAddress[id];\n        success = address_ != address(0);\n    }\n\n    /// @notice Called by registrars or the manager to register the address\n    /// with the ID\n    /// @param id Registry ID\n    /// @param address_ Address to be registered\n    function _registerAddress(bytes32 id, address address_)\n        internal\n        onlyRegistrarOrManager\n    {\n        require(address_ != address(0), \"Cannot register zero address\");\n        idToAddress[id] = address_;\n    }\n}\n"
    },
    "contracts/utils/RegistryRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../access-control-registry/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"./interfaces/IRegistryRolesWithManager.sol\";\n\n/// @title Contract to be inherited by registry contracts that will use generic\n/// AccessControlRegistry roles\ncontract RegistryRolesWithManager is\n    AccessControlRegistryAdminnedWithManager,\n    IRegistryRolesWithManager\n{\n    /// @notice Registrar role description\n    string public constant override REGISTRAR_ROLE_DESCRIPTION = \"Registrar\";\n\n    /// @notice Registrar role\n    bytes32 public immutable registrarRole;\n\n    /// @dev Reverts if the sender is not the manager and does not have the\n    /// registrar role\n    modifier onlyRegistrarOrManager() {\n        require(\n            msg.sender == manager ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    registrarRole,\n                    msg.sender\n                ),\n            \"Sender cannot register\"\n        );\n        _;\n    }\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {\n        registrarRole = _deriveRole(adminRole, REGISTRAR_ROLE_DESCRIPTION);\n    }\n}\n"
    },
    "contracts/allocators/AllocatorWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../access-control-registry/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"../access-control-registry/RoleDeriver.sol\";\nimport \"../access-control-registry/interfaces/IAccessControlRegistry.sol\";\nimport \"./Allocator.sol\";\nimport \"./interfaces/IAllocatorWithManager.sol\";\n\n/// @title Contract that the manager can use to temporarily allocate\n/// subscription slots for Airnodes\ncontract AllocatorWithManager is\n    RoleDeriver,\n    AccessControlRegistryAdminnedWithManager,\n    Allocator,\n    IAllocatorWithManager\n{\n    /// @notice Slot setter role\n    bytes32 public immutable override slotSetterRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {\n        slotSetterRole = _deriveRole(\n            adminRole,\n            SLOT_SETTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @notice Sets a slot with the given parameters\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot to be set\n    /// @param subscriptionId Subscription ID\n    /// @param expirationTimestamp Timestamp at which the slot allocation will\n    /// expire\n    function setSlot(\n        address airnode,\n        uint256 slotIndex,\n        bytes32 subscriptionId,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasSlotSetterRoleOrIsManager(msg.sender),\n            \"Sender cannot set slot\"\n        );\n        _setSlot(airnode, slotIndex, subscriptionId, expirationTimestamp);\n    }\n\n    /// @notice Returns if the setter of the slot can still set slots\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot that was set\n    /// @return If the setter of the slot can still set slots\n    function setterOfSlotIsCanStillSet(address airnode, uint256 slotIndex)\n        public\n        view\n        override(Allocator, IAllocator)\n        returns (bool)\n    {\n        return\n            hasSlotSetterRoleOrIsManager(\n                airnodeToSlotIndexToSlot[airnode][slotIndex].setter\n            );\n    }\n\n    /// @notice Returns if the account has the slot setter role or is the\n    /// manager\n    /// @param account Account address\n    function hasSlotSetterRoleOrIsManager(address account)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                slotSetterRole,\n                account\n            );\n    }\n}\n"
    },
    "contracts/allocators/Allocator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAllocator.sol\";\n\n/// @title Abstract contract to be inherited by Allocator contracts that\n/// temporarily allocate subscription slots for Airnodes/relayers\n/// @dev An Airnode/relayer calls a number of Allocators to retrieve a number\n/// of slots to serve the respective subscriptions. What these Allocators and\n/// slot numbers are expected to be communicated off-chain. The Airnode/relayer\n/// should not process expired slots or subscriptions with invalid IDs.\nabstract contract Allocator is IAllocator {\n    struct Slot {\n        bytes32 subscriptionId;\n        address setter;\n        uint64 expirationTimestamp;\n    }\n\n    /// @notice Slot setter role description\n    string public constant override SLOT_SETTER_ROLE_DESCRIPTION =\n        \"Slot setter\";\n\n    /// @notice Subscription slot of an Airnode addressed by the index\n    mapping(address => mapping(uint256 => Slot))\n        public\n        override airnodeToSlotIndexToSlot;\n\n    bytes32 internal constant SLOT_SETTER_ROLE_DESCRIPTION_HASH =\n        keccak256(abi.encodePacked(SLOT_SETTER_ROLE_DESCRIPTION));\n\n    /// @notice Called internally to set the slot with the given parameters\n    /// @dev The set slot can be reset by its setter, or when it has expired,\n    /// or when its setter is no longer authorized to set slots\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot to be set\n    /// @param subscriptionId Subscription ID\n    /// @param expirationTimestamp Timestamp at which the slot allocation will\n    /// expire\n    function _setSlot(\n        address airnode,\n        uint256 slotIndex,\n        bytes32 subscriptionId,\n        uint64 expirationTimestamp\n    ) internal {\n        require(\n            expirationTimestamp >= block.timestamp,\n            \"Expiration is in past\"\n        );\n        _resetSlot(airnode, slotIndex);\n        airnodeToSlotIndexToSlot[airnode][slotIndex] = Slot({\n            subscriptionId: subscriptionId,\n            setter: msg.sender,\n            expirationTimestamp: expirationTimestamp\n        });\n        emit SetSlot(airnode, slotIndex, subscriptionId, expirationTimestamp);\n    }\n\n    /// @notice Resets the slot\n    /// @dev This will revert if the slot has been set before, and the sender\n    /// is not the setter of the slot, and the slot has not expired and the\n    /// setter of the slot is still authorized to set slots.\n    /// The sender does not have to be authorized to set slots to use this.\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot to be set\n    function resetSlot(address airnode, uint256 slotIndex) external override {\n        if (\n            airnodeToSlotIndexToSlot[airnode][slotIndex].subscriptionId !=\n            bytes32(0)\n        ) {\n            _resetSlot(airnode, slotIndex);\n            emit ResetSlot(airnode, slotIndex);\n        }\n    }\n\n    /// @notice Returns if the setter of the slot can still set slots\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot that was set\n    /// @return If the setter of the slot can still set slots\n    function setterOfSlotIsCanStillSet(address airnode, uint256 slotIndex)\n        public\n        view\n        virtual\n        override\n        returns (bool);\n\n    /// @notice Called privately to reset a slot\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot to be set\n    function _resetSlot(address airnode, uint256 slotIndex) private {\n        Slot storage slot = airnodeToSlotIndexToSlot[airnode][slotIndex];\n        require(\n            slot.setter == msg.sender ||\n                slot.expirationTimestamp < block.timestamp ||\n                !setterOfSlotIsCanStillSet(airnode, slotIndex),\n            \"Cannot reset slot\"\n        );\n        delete airnodeToSlotIndexToSlot[airnode][slotIndex];\n    }\n}\n"
    },
    "contracts/allocators/interfaces/IAllocatorWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\nimport \"./IAllocator.sol\";\n\ninterface IAllocatorWithManager is\n    IAccessControlRegistryAdminnedWithManager,\n    IAllocator\n{\n    function hasSlotSetterRoleOrIsManager(address account)\n        external\n        view\n        returns (bool);\n\n    function slotSetterRole() external view returns (bytes32);\n}\n"
    },
    "contracts/allocators/interfaces/IAllocator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAllocator {\n    event SetSlot(\n        address indexed airnode,\n        uint256 slotIndex,\n        bytes32 subscriptionId,\n        uint64 expirationTimestamp\n    );\n\n    event ResetSlot(address indexed airnode, uint256 slotIndex);\n\n    function setSlot(\n        address airnode,\n        uint256 slotIndex,\n        bytes32 subscriptionId,\n        uint64 expirationTimestamp\n    ) external;\n\n    function resetSlot(address airnode, uint256 slotIndex) external;\n\n    function setterOfSlotIsCanStillSet(address airnode, uint256 slotIndex)\n        external\n        view\n        returns (bool);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function SLOT_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    function airnodeToSlotIndexToSlot(address airnode, uint256 slotIndex)\n        external\n        view\n        returns (\n            bytes32 subscriptionId,\n            address setter,\n            uint64 expirationTimestamp\n        );\n}\n"
    },
    "contracts/allocators/interfaces/IAllocatorWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminned.sol\";\nimport \"./IAllocator.sol\";\n\ninterface IAllocatorWithAirnode is IAccessControlRegistryAdminned, IAllocator {\n    function hasSlotSetterRoleOrIsAirnode(address airnode, address account)\n        external\n        view\n        returns (bool);\n\n    function deriveAdminRole(address airnode)\n        external\n        view\n        returns (bytes32 adminRole);\n\n    function deriveSlotSetterRole(address airnode)\n        external\n        view\n        returns (bytes32 slotSetterRole);\n}\n"
    },
    "contracts/allocators/AllocatorWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../access-control-registry/AccessControlRegistryAdminned.sol\";\nimport \"./Allocator.sol\";\nimport \"./interfaces/IAllocatorWithAirnode.sol\";\n\n/// @title Contract that Airnode operators can use to temporarily allocate\n/// subscription slots for Airnodes\ncontract AllocatorWithAirnode is\n    RoleDeriver,\n    AccessControlRegistryAdminned,\n    Allocator,\n    IAllocatorWithAirnode\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    )\n        AccessControlRegistryAdminned(\n            _accessControlRegistry,\n            _adminRoleDescription\n        )\n    {}\n\n    /// @notice Sets a slot with the given parameters\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot to be set\n    /// @param subscriptionId Subscription ID\n    /// @param expirationTimestamp Timestamp at which the slot allocation will\n    /// expire\n    function setSlot(\n        address airnode,\n        uint256 slotIndex,\n        bytes32 subscriptionId,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasSlotSetterRoleOrIsAirnode(airnode, msg.sender),\n            \"Sender cannot set slot\"\n        );\n        _setSlot(airnode, slotIndex, subscriptionId, expirationTimestamp);\n    }\n\n    /// @notice Returns if the setter of the slot can still set slots\n    /// @param airnode Airnode address\n    /// @param slotIndex Index of the subscription slot that was set\n    /// @return If the setter of the slot can still set slots\n    function setterOfSlotIsCanStillSet(address airnode, uint256 slotIndex)\n        public\n        view\n        override(Allocator, IAllocator)\n        returns (bool)\n    {\n        return\n            hasSlotSetterRoleOrIsAirnode(\n                airnode,\n                airnodeToSlotIndexToSlot[airnode][slotIndex].setter\n            );\n    }\n\n    /// @notice Returns if the account has the slot setter role or has the\n    /// respective Airnode address\n    /// @param airnode Airnode address\n    /// @param account Account address\n    function hasSlotSetterRoleOrIsAirnode(address airnode, address account)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            airnode == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                deriveSlotSetterRole(airnode),\n                account\n            );\n    }\n\n    /// @notice Derives the admin role for the specific Airnode address\n    /// @param airnode Airnode address\n    /// @return adminRole Admin role\n    function deriveAdminRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveRole(\n            _deriveRootRole(airnode),\n            adminRoleDescriptionHash\n        );\n    }\n\n    /// @notice Derives the slot setter role for the specific Airnode address\n    /// @param airnode Airnode address\n    /// @return slotSetterRole Slot setter role\n    function deriveSlotSetterRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 slotSetterRole)\n    {\n        slotSetterRole = _deriveRole(\n            deriveAdminRole(airnode),\n            SLOT_SETTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n}\n"
    },
    "contracts/utils/Uint256Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./RegistryRolesWithManager.sol\";\nimport \"./interfaces/IUint256Registry.sol\";\n\n/// @title Contract to be inherited by contracts that need a registry with\n/// manager that maps IDs to unsigned integers\n/// @dev Does not allow zero to be registered as a number\ncontract Uint256Registry is RegistryRolesWithManager, IUint256Registry {\n    mapping(bytes32 => uint256) private idToUint256;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        RegistryRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Returns if there is a registered unsigned integer with the ID\n    /// and the registered unsigned integer and what it is\n    /// @param id Registry ID\n    /// @return success If there is a registered unsigned integer with the ID\n    /// @return uint256_ Registered unsigned integer\n    function tryReadRegisteredUint256(bytes32 id)\n        public\n        view\n        override\n        returns (bool success, uint256 uint256_)\n    {\n        uint256_ = idToUint256[id];\n        success = uint256_ != 0;\n    }\n\n    /// @notice Called by registrars or the manager to register the unsigned\n    /// integer with the ID\n    /// @param id Registry ID\n    /// @param uint256_ Unsigned integer to be registered\n    function _registerUint256(bytes32 id, uint256 uint256_)\n        internal\n        onlyRegistrarOrManager\n    {\n        require(uint256_ != 0, \"Cannot register zero\");\n        idToUint256[id] = uint256_;\n    }\n}\n"
    },
    "contracts/utils/interfaces/IUint256Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IRegistryRolesWithManager.sol\";\n\ninterface IUint256Registry is IRegistryRolesWithManager {\n    function tryReadRegisteredUint256(bytes32 id)\n        external\n        view\n        returns (bool success, uint256 uint256_);\n}\n"
    },
    "contracts/monetization/AirnodeEndpointPriceRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../utils/Uint256Registry.sol\";\nimport \"./interfaces/IAirnodeEndpointPriceRegistry.sol\";\n\n/// @title Registry for prices of accessing Airnode endpoints across chains\n/// @notice AirnodeEndpointPriceRegistry is a central contract that can be queried for\n/// the USD price of an Airnode–chain–endpoint pair\ncontract AirnodeEndpointPriceRegistry is\n    Uint256Registry,\n    IAirnodeEndpointPriceRegistry\n{\n    /// @notice A flag to determine which price to default to\n    /// @dev See `getPrice()` for details\n    mapping(address => bool)\n        public\n        override prioritizeEndpointPriceOverChainPrice;\n\n    /// @notice Denomination used to specify the prices\n    string public constant override DENOMINATION = \"USD\";\n\n    /// @notice Decimals used to specify the prices\n    uint256 public constant override DECIMALS = 18;\n\n    /// @notice Pricing interval used to specify the prices\n    uint256 public constant override PRICING_INTERVAL = 30 days;\n\n    bytes32 private constant DEFAULT_PRICE_ID =\n        keccak256(abi.encodePacked(\"Default price\"));\n\n    bytes32 private constant SALT =\n        keccak256(abi.encodePacked(\"Salt to avoid hash collision\"));\n\n    /// @dev Reverts if the Airnode address is zero\n    /// @param airnode Airnode address\n    modifier onlyNonZeroAirnode(address airnode) {\n        require(airnode != address(0), \"Airnode address zero\");\n        _;\n    }\n\n    /// @dev Reverts if the chain ID is zero\n    /// @param chainId Chain ID\n    modifier onlyNonZeroChainId(uint256 chainId) {\n        require(chainId != 0, \"Chain ID zero\");\n        _;\n    }\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        Uint256Registry(_accessControlRegistry, _adminRoleDescription, _manager)\n    {}\n\n    /// @notice Called by registrars or the manager to register the\n    /// default price\n    /// @param price 30 day price in USD (times 10^18)\n    function registerDefaultPrice(uint256 price) external override {\n        _registerUint256(DEFAULT_PRICE_ID, price);\n        emit RegisterDefaultPrice(price, msg.sender);\n    }\n\n    /// @notice Called by registrars or the manager to register the\n    /// default chain price\n    /// @param chainId Chain ID\n    /// @param price 30 day price in USD (times 10^18)\n    function registerDefaultChainPrice(uint256 chainId, uint256 price)\n        external\n        override\n        onlyNonZeroChainId(chainId)\n    {\n        _registerUint256(\n            keccak256(abi.encodePacked(DEFAULT_PRICE_ID, chainId)),\n            price\n        );\n        emit RegisterDefaultChainPrice(chainId, price, msg.sender);\n    }\n\n    /// @notice Called by registrars or the manager to register the\n    /// Airnode price\n    /// @param airnode Airnode address\n    /// @param price 30 day price in USD (times 10^18)\n    function registerAirnodePrice(address airnode, uint256 price)\n        external\n        override\n        onlyNonZeroAirnode(airnode)\n    {\n        _registerUint256(keccak256(abi.encodePacked(airnode)), price);\n        emit RegisterAirnodePrice(airnode, price, msg.sender);\n    }\n\n    /// @notice Called by registrars or the manager to register the\n    /// Airnode, chain price\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param price 30 day price in USD (times 10^18)\n    function registerAirnodeChainPrice(\n        address airnode,\n        uint256 chainId,\n        uint256 price\n    )\n        external\n        override\n        onlyNonZeroAirnode(airnode)\n        onlyNonZeroChainId(chainId)\n    {\n        _registerUint256(keccak256(abi.encodePacked(airnode, chainId)), price);\n        emit RegisterAirnodeChainPrice(airnode, chainId, price, msg.sender);\n    }\n\n    /// @notice Called by registrars or the manager to register the\n    /// Airnode, endpoint price\n    /// @dev The registry ID hash is salted in case the Airnode is not using\n    /// hashes for `endpointId` as they are supposed to and numbers instead,\n    /// which may be the same as chain IDs and result in collision\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param price 30 day price in USD (times 10^18)\n    function registerAirnodeEndpointPrice(\n        address airnode,\n        bytes32 endpointId,\n        uint256 price\n    ) external override onlyNonZeroAirnode(airnode) {\n        _registerUint256(\n            keccak256(abi.encodePacked(SALT, airnode, endpointId)),\n            price\n        );\n        emit RegisterAirnodeEndpointPrice(\n            airnode,\n            endpointId,\n            price,\n            msg.sender\n        );\n    }\n\n    /// @notice Called by registrars or the manager to register the\n    /// Airnode, chain, endpoint price\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param price 30 day price in USD (times 10^18)\n    function registerAirnodeChainEndpointPrice(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId,\n        uint256 price\n    )\n        external\n        override\n        onlyNonZeroAirnode(airnode)\n        onlyNonZeroChainId(chainId)\n    {\n        _registerUint256(\n            keccak256(abi.encodePacked(airnode, chainId, endpointId)),\n            price\n        );\n        emit RegisterAirnodeChainEndpointPrice(\n            airnode,\n            chainId,\n            endpointId,\n            price,\n            msg.sender\n        );\n    }\n\n    /// @notice Sets if the endpoint or the chain price will be prioritized\n    /// for the Airnode\n    /// @param airnode Airnode address\n    /// @param status Flag status, `true` prioritizes the endpoint price,\n    /// `false` prioritizes the chain price (default)\n    function setEndpointAndChainPricePriority(address airnode, bool status)\n        external\n        override\n        onlyRegistrarOrManager\n        onlyNonZeroAirnode(airnode)\n    {\n        prioritizeEndpointPriceOverChainPrice[airnode] = status;\n        emit SetEndpointAndChainPricePriority(airnode, status, msg.sender);\n    }\n\n    /// @notice Returns if there is a registered default price and what it is\n    /// @return success If the price was registered\n    /// @return price 30 day price in USD (times 10^18)\n    function tryReadDefaultPrice()\n        public\n        view\n        override\n        returns (bool success, uint256 price)\n    {\n        (success, price) = tryReadRegisteredUint256(DEFAULT_PRICE_ID);\n    }\n\n    /// @notice Returns if there is a registered default chain price and what\n    /// it is\n    /// @param chainId Chain ID\n    /// @return success If the price was registered\n    /// @return price 30 day price in USD (times 10^18)\n    function tryReadDefaultChainPrice(uint256 chainId)\n        public\n        view\n        override\n        returns (bool success, uint256 price)\n    {\n        (success, price) = tryReadRegisteredUint256(\n            keccak256(abi.encodePacked(DEFAULT_PRICE_ID, chainId))\n        );\n    }\n\n    /// @notice Returns if there is a registered Airnode price and what it is\n    /// @param airnode Airnode address\n    /// @return success If the price was registered\n    /// @return price 30 day price in USD (times 10^18)\n    function tryReadAirnodePrice(address airnode)\n        public\n        view\n        override\n        returns (bool success, uint256 price)\n    {\n        (success, price) = tryReadRegisteredUint256(\n            keccak256(abi.encodePacked(airnode))\n        );\n    }\n\n    /// @notice Returns if there is a registered Airnode, chain price and what\n    /// it is\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @return success If the price was registered\n    /// @return price 30 day price in USD (times 10^18)\n    function tryReadAirnodeChainPrice(address airnode, uint256 chainId)\n        public\n        view\n        override\n        returns (bool success, uint256 price)\n    {\n        (success, price) = tryReadRegisteredUint256(\n            keccak256(abi.encodePacked(airnode, chainId))\n        );\n    }\n\n    /// @notice Returns if there is a registered Airnode, endpoint price and\n    /// what it is\n    /// @dev The registry ID hash is salted in case the Airnode is not using\n    /// hashes for `endpointId` as they are supposed to and numbers instead,\n    /// which may be the same as chain IDs and result in collision.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @return success If the price was registered\n    /// @return price 30 day price in USD (times 10^18)\n    function tryReadAirnodeEndpointPrice(address airnode, bytes32 endpointId)\n        public\n        view\n        override\n        returns (bool success, uint256 price)\n    {\n        (success, price) = tryReadRegisteredUint256(\n            keccak256(abi.encodePacked(SALT, airnode, endpointId))\n        );\n    }\n\n    /// @notice Returns if there is a registered Airnode, chain, endpoint price\n    /// and what it is\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @return success If the price was registered\n    /// @return price 30 day price in USD (times 10^18)\n    function tryReadAirnodeChainEndpointPrice(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId\n    ) public view override returns (bool success, uint256 price) {\n        (success, price) = tryReadRegisteredUint256(\n            keccak256(abi.encodePacked(airnode, chainId, endpointId))\n        );\n    }\n\n    /// @notice Returns the price that should be used for the given Airnode,\n    /// chain and endpoint\n    /// @dev The logic prioritizes more specific prices over less specific\n    /// prices. There is ambiguity in if Airnode + chain or Airnode + endpoint\n    /// should be prioritized, which we made to configurable (defaults to\n    /// prioritizing Airnode + chain).\n    /// Reverts if no price is set.\n    /// @param airnode Airnode address\n    /// @param chainId Chain ID\n    /// @param endpointId Endpoint ID\n    /// @return price 30 day price in USD (times 10^18)\n    function getPrice(\n        address airnode,\n        uint256 chainId,\n        bytes32 endpointId\n    ) external view override returns (uint256 price) {\n        bool success;\n        (success, price) = tryReadAirnodeChainEndpointPrice(\n            airnode,\n            chainId,\n            endpointId\n        );\n        if (success) {\n            return price;\n        }\n        if (prioritizeEndpointPriceOverChainPrice[airnode]) {\n            (success, price) = tryReadAirnodeEndpointPrice(airnode, endpointId);\n            if (success) {\n                return price;\n            }\n            (success, price) = tryReadAirnodeChainPrice(airnode, chainId);\n            if (success) {\n                return price;\n            }\n        } else {\n            (success, price) = tryReadAirnodeChainPrice(airnode, chainId);\n            if (success) {\n                return price;\n            }\n            (success, price) = tryReadAirnodeEndpointPrice(airnode, endpointId);\n            if (success) {\n                return price;\n            }\n        }\n        (success, price) = tryReadAirnodePrice(airnode);\n        if (success) {\n            return price;\n        }\n        (success, price) = tryReadDefaultChainPrice(chainId);\n        if (success) {\n            return price;\n        }\n        (success, price) = tryReadDefaultPrice();\n        require(success, \"No default price set\");\n    }\n}\n"
    },
    "contracts/monetization/RequesterAuthorizerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../utils/AddressRegistry.sol\";\nimport \"./interfaces/IRequesterAuthorizerRegistry.sol\";\n\n/// @title Registry for addresses of RequesterAuthorizer contracts dedicated to\n/// chains\ncontract RequesterAuthorizerRegistry is\n    AddressRegistry,\n    IRequesterAuthorizerRegistry\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AddressRegistry(_accessControlRegistry, _adminRoleDescription, _manager)\n    {}\n\n    /// @notice Called by registrars or the manager to register the\n    /// RequesterAuthorizer with the chain ID\n    /// @dev The RequesterAuthorizer for the chain can be registered only once\n    /// @param chainId Chain ID\n    /// @param requesterAuthorizer RequesterAuthorizer contract address\n    function registerChainRequesterAuthorizer(\n        uint256 chainId,\n        address requesterAuthorizer\n    ) external override {\n        require(chainId != 0, \"Chain ID zero\");\n        (bool success, ) = tryReadChainRequesterAuthorizer(chainId);\n        require(!success, \"Chain Authorizer already set\");\n        _registerAddress(\n            keccak256(abi.encodePacked(chainId)),\n            requesterAuthorizer\n        );\n        emit RegisteredChainRequesterAuthorizer(\n            chainId,\n            requesterAuthorizer,\n            msg.sender\n        );\n    }\n\n    /// @notice Returns if there is a registered RequesterAuthorizer address\n    /// for the chain ID and what it is\n    /// @param chainId Chain ID\n    /// @return success If the RequesterAuthorizer was registered\n    /// @return requesterAuthorizer Registered address\n    function tryReadChainRequesterAuthorizer(uint256 chainId)\n        public\n        view\n        override\n        returns (bool success, address requesterAuthorizer)\n    {\n        (success, requesterAuthorizer) = tryReadRegisteredAddress(\n            keccak256(abi.encodePacked(chainId))\n        );\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/IRequesterAuthorizerWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../whitelist/interfaces/IWhitelistRolesWithAirnode.sol\";\nimport \"./IRequesterAuthorizer.sol\";\n\ninterface IRequesterAuthorizerWithAirnode is\n    IWhitelistRolesWithAirnode,\n    IRequesterAuthorizer\n{}\n"
    },
    "contracts/authorizers/RequesterAuthorizerWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../whitelist/WhitelistRolesWithAirnode.sol\";\nimport \"./RequesterAuthorizer.sol\";\nimport \"./interfaces/IRequesterAuthorizerWithAirnode.sol\";\n\n/// @title Authorizer contract that Airnode operators can use to temporarily or\n/// indefinitely whitelist requesters for Airnode–endpoint pairs\ncontract RequesterAuthorizerWithAirnode is\n    WhitelistRolesWithAirnode,\n    RequesterAuthorizer,\n    IRequesterAuthorizerWithAirnode\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    )\n        WhitelistRolesWithAirnode(_accessControlRegistry, _adminRoleDescription)\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair if the sender has the\n    /// whitelist expiration extender role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationExtenderRoleOrIsAirnode(airnode, msg.sender),\n            \"Cannot extend expiration\"\n        );\n        _extendWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair if the sender has the whitelist\n    /// expiration setter role\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationSetterRoleOrIsAirnode(airnode, msg.sender),\n            \"Cannot set expiration\"\n        );\n        _setWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair if the sender has the indefinite\n    /// whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external override {\n        require(\n            hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, msg.sender),\n            \"Cannot set indefinite status\"\n        );\n        _setIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            status\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external override {\n        require(\n            !hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, setter),\n            \"setter can set indefinite status\"\n        );\n        _revokeIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            setter\n        );\n    }\n}\n"
    },
    "contracts/authorizers/RequesterAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../whitelist/Whitelist.sol\";\nimport \"./interfaces/IRequesterAuthorizer.sol\";\n\n/// @title Abstract contract to be inherited by Authorizer contracts that\n/// temporarily or permanently whitelist requesters for Airnode–endpoint pairs\nabstract contract RequesterAuthorizer is Whitelist, IRequesterAuthorizer {\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair and emits an event\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpirationAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        _extendWhitelistExpiration(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            expirationTimestamp\n        );\n        emit ExtendedWhitelistExpiration(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair and emits an event\n    /// @dev Unlike `_extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpirationAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        _setWhitelistExpiration(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            expirationTimestamp\n        );\n        emit SetWhitelistExpiration(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair and emits an event\n    /// @dev Emits the event even if it does not change the state.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatusAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            status\n        );\n        emit SetIndefiniteWhitelistStatus(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            status,\n            indefiniteWhitelistCount\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted to `requester`\n    /// for the `airnode`–`endpointId` pair by a specific account and emits an\n    /// event\n    /// @dev Only emits the event if it changes the state\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatusAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) internal {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(requester != address(0), \"Requester address zero\");\n        require(setter != address(0), \"Setter address zero\");\n        (\n            bool revoked,\n            uint192 indefiniteWhitelistCount\n        ) = _revokeIndefiniteWhitelistStatus(\n                deriveServiceId(airnode, endpointId),\n                requester,\n                setter\n            );\n        if (revoked) {\n            emit RevokedIndefiniteWhitelistStatus(\n                airnode,\n                endpointId,\n                requester,\n                setter,\n                msg.sender,\n                indefiniteWhitelistCount\n            );\n        }\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(deriveServiceId(airnode, endpointId), requester);\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because V0 authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorizedV0(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        address airnode,\n        bytes32 endpointId,\n        address sponsor, // solhint-disable-line no-unused-vars\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(deriveServiceId(airnode, endpointId), requester);\n    }\n\n    /// @notice Returns the whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @return expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    /// @return indefiniteWhitelistCount Number of times `requester` was\n    /// whitelisted indefinitely for the `airnode`–`endpointId` pair\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    )\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                deriveServiceId(airnode, endpointId)\n            ][requester];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\n    }\n\n    /// @notice Returns if an account has indefinitely whitelisted `requester`\n    /// for the `airnode`–`endpointId` pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Address of the account that has potentially whitelisted\n    /// `requester` for the `airnode`–`endpointId` pair indefinitely\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\n    /// whitelisted `requester` for the `airnode`–`endpointId` pair\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\n            deriveServiceId(airnode, endpointId)\n        ][requester][setter];\n    }\n\n    /// @notice Called privately to derive a service ID out of the Airnode\n    /// address and the endpoint ID\n    /// @dev This is done to re-use the more general Whitelist contract for\n    /// the specific case of Airnode–endpoint pairs\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @return serviceId Service ID\n    function deriveServiceId(address airnode, bytes32 endpointId)\n        private\n        pure\n        returns (bytes32 serviceId)\n    {\n        serviceId = keccak256(abi.encodePacked(airnode, endpointId));\n    }\n}\n"
    },
    "contracts/authorizers/RequesterAuthorizerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../whitelist/WhitelistRolesWithManager.sol\";\nimport \"./RequesterAuthorizer.sol\";\nimport \"./interfaces/IRequesterAuthorizerWithManager.sol\";\n\n/// @title Authorizer contract that a manager can use to temporarily or\n/// indefinitely whitelist requesters for Airnode–endpoint pairs\ncontract RequesterAuthorizerWithManager is\n    WhitelistRolesWithManager,\n    RequesterAuthorizer,\n    IRequesterAuthorizerWithManager\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        WhitelistRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair if the sender has the\n    /// whitelist expiration extender role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationExtenderRoleOrIsManager(msg.sender),\n            \"Cannot extend expiration\"\n        );\n        _extendWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair if the sender has the whitelist\n    /// expiration setter role\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationSetterRoleOrIsManager(msg.sender),\n            \"Cannot set expiration\"\n        );\n        _setWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair if the sender has the indefinite\n    /// whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external override {\n        require(\n            hasIndefiniteWhitelisterRoleOrIsManager(msg.sender),\n            \"Cannot set indefinite status\"\n        );\n        _setIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            status\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external override {\n        require(\n            !hasIndefiniteWhitelisterRoleOrIsManager(setter),\n            \"setter can set indefinite status\"\n        );\n        _revokeIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            setter\n        );\n    }\n}\n"
    },
    "contracts/authorizers/interfaces/IRequesterAuthorizerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../whitelist/interfaces/IWhitelistRolesWithManager.sol\";\nimport \"./IRequesterAuthorizer.sol\";\n\ninterface IRequesterAuthorizerWithManager is\n    IWhitelistRolesWithManager,\n    IRequesterAuthorizer\n{}\n"
    },
    "contracts/dapis/DapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../utils/ExtendedMulticall.sol\";\nimport \"../whitelist/WhitelistWithManager.sol\";\nimport \"../protocol/AirnodeRequester.sol\";\nimport \"./Median.sol\";\nimport \"./interfaces/IDapiServer.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that serves Beacons, Beacon sets and dAPIs based on the\n/// Airnode protocol\n/// @notice A Beacon is a live data feed addressed by an ID, which is derived\n/// from an Airnode address and a template ID. This is suitable where the more\n/// recent data point is always more favorable, e.g., in the context of an\n/// asset price data feed. Beacons can also be seen as one-Airnode data feeds\n/// that can be used individually or combined to build Beacon sets. dAPIs are\n/// an abstraction layer over Beacons and Beacon sets.\n/// @dev DapiServer is a PSP requester contract. Unlike RRP, which is\n/// implemented as a central contract, PSP implementation is built into the\n/// requester for optimization. Accordingly, the checks that are not required\n/// are omitted. Some examples:\n/// - While executing a PSP Beacon update, the condition is not verified\n/// because Beacon updates where the condition returns `false` (i.e., the\n/// on-chain value is already close to the actual value) are not harmful, and\n/// are even desirable.\n/// - PSP Beacon set update subscription IDs are not verified, as the\n/// Airnode/relayer cannot be made to \"misreport a Beacon set update\" by\n/// spoofing a subscription ID.\n/// - While executing a PSP Beacon set update, even the signature is not\n/// checked because this is a purely keeper job that does not require off-chain\n/// data. Similar to Beacon updates, any Beacon set update is welcome.\ncontract DapiServer is\n    ExtendedMulticall,\n    WhitelistWithManager,\n    AirnodeRequester,\n    Median,\n    IDapiServer\n{\n    using ECDSA for bytes32;\n\n    // Airnodes serve their fulfillment data along with timestamps. This\n    // contract casts the reported data to `int224` and the timestamp to\n    // `uint32`, which works until year 2106.\n    struct DataFeed {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice dAPI name setter role description\n    string public constant override DAPI_NAME_SETTER_ROLE_DESCRIPTION =\n        \"dAPI name setter\";\n\n    /// @notice Number that represents 100%\n    /// @dev 10^8 (and not a larger number) is chosen to avoid overflows in\n    /// `calculateUpdateInPercentage()`. Since the reported data needs to fit\n    /// into 224 bits, its multiplication by 10^8 is guaranteed not to\n    /// overflow.\n    uint256 public constant override HUNDRED_PERCENT = 1e8;\n\n    /// @notice dAPI name setter role\n    bytes32 public immutable override dapiNameSetterRole;\n\n    /// @notice If an account is an unlimited reader\n    mapping(address => bool) public unlimitedReaderStatus;\n\n    /// @notice If a sponsor has permitted an account to request RRP-based\n    /// updates at this contract\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToRrpBeaconUpdateRequesterToPermissionStatus;\n\n    /// @notice ID of the Beacon that the subscription is registered to update\n    mapping(bytes32 => bytes32) public override subscriptionIdToBeaconId;\n\n    mapping(bytes32 => DataFeed) private dataFeeds;\n\n    mapping(bytes32 => bytes32) private requestIdToBeaconId;\n\n    mapping(bytes32 => bytes32) private subscriptionIdToHash;\n\n    mapping(bytes32 => bytes32) private dapiNameHashToDataFeedId;\n\n    /// @dev Reverts if the sender is not permitted to request an RRP-based\n    /// update with the sponsor and is not the sponsor\n    /// @param sponsor Sponsor address\n    modifier onlyPermittedUpdateRequester(address sponsor) {\n        require(\n            sponsor == msg.sender ||\n                sponsorToRrpBeaconUpdateRequesterToPermissionStatus[sponsor][\n                    msg.sender\n                ],\n            \"Sender not permitted\"\n        );\n        _;\n    }\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    /// @param _airnodeProtocol AirnodeProtocol contract address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager,\n        address _airnodeProtocol\n    )\n        WhitelistWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n        AirnodeRequester(_airnodeProtocol)\n    {\n        dapiNameSetterRole = _deriveRole(\n            _deriveAdminRole(manager),\n            keccak256(abi.encodePacked(DAPI_NAME_SETTER_ROLE_DESCRIPTION))\n        );\n    }\n\n    ///                     ~~~RRP Beacon updates~~~\n\n    /// @notice Called by the sponsor to set the update request permission\n    /// status of an account\n    /// @param rrpBeaconUpdateRequester RRP-based Beacon update requester\n    /// address\n    /// @param status Permission status\n    function setRrpBeaconUpdatePermissionStatus(\n        address rrpBeaconUpdateRequester,\n        bool status\n    ) external override {\n        require(\n            rrpBeaconUpdateRequester != address(0),\n            \"Update requester zero\"\n        );\n        sponsorToRrpBeaconUpdateRequesterToPermissionStatus[msg.sender][\n            rrpBeaconUpdateRequester\n        ] = status;\n        emit SetRrpBeaconUpdatePermissionStatus(\n            msg.sender,\n            rrpBeaconUpdateRequester,\n            status\n        );\n    }\n\n    /// @notice Creates an RRP requests for the Beacon to be updated\n    /// @dev In addition to the sponsor sponsoring this contract (by calling\n    /// `setRrpSponsorshipStatus()`), the sponsor must also give update request\n    /// permission to the sender (by calling\n    /// `setRrpBeaconUpdatePermissionStatus()`) before this method is called.\n    /// The template must specify a single point of data of type `int256` to be\n    /// returned and for it to be small enough to be castable to `int224`\n    /// because this is what `fulfillRrpBeaconUpdate()` expects.\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @return requestId Request ID\n    function requestRrpBeaconUpdate(\n        address airnode,\n        bytes32 templateId,\n        address sponsor\n    )\n        external\n        override\n        onlyPermittedUpdateRequester(sponsor)\n        returns (bytes32 requestId)\n    {\n        bytes32 beaconId = deriveBeaconId(airnode, templateId);\n        requestId = IAirnodeProtocol(airnodeProtocol).makeRequest(\n            airnode,\n            templateId,\n            \"\",\n            sponsor,\n            this.fulfillRrpBeaconUpdate.selector\n        );\n        requestIdToBeaconId[requestId] = beaconId;\n        emit RequestedRrpBeaconUpdate(\n            beaconId,\n            sponsor,\n            msg.sender,\n            requestId,\n            airnode,\n            templateId\n        );\n    }\n\n    /// @notice Creates an RRP requests for the Beacon to be updated by the relayer\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @return requestId Request ID\n    function requestRrpBeaconUpdateRelayed(\n        address airnode,\n        bytes32 templateId,\n        address relayer,\n        address sponsor\n    )\n        external\n        override\n        onlyPermittedUpdateRequester(sponsor)\n        returns (bytes32 requestId)\n    {\n        bytes32 beaconId = deriveBeaconId(airnode, templateId);\n        requestId = IAirnodeProtocol(airnodeProtocol).makeRequestRelayed(\n            airnode,\n            templateId,\n            \"\",\n            relayer,\n            sponsor,\n            this.fulfillRrpBeaconUpdate.selector\n        );\n        requestIdToBeaconId[requestId] = beaconId;\n        emit RequestedRrpBeaconUpdateRelayed(\n            beaconId,\n            sponsor,\n            msg.sender,\n            requestId,\n            airnode,\n            relayer,\n            templateId\n        );\n    }\n\n    /// @notice Called by the Airnode/relayer using the sponsor wallet through\n    /// AirnodeProtocol to fulfill the request\n    /// @param requestId Request ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    function fulfillRrpBeaconUpdate(\n        bytes32 requestId,\n        uint256 timestamp,\n        bytes calldata data\n    ) external override onlyAirnodeProtocol onlyValidTimestamp(timestamp) {\n        bytes32 beaconId = requestIdToBeaconId[requestId];\n        delete requestIdToBeaconId[requestId];\n        int256 decodedData = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithRrp(beaconId, requestId, decodedData, timestamp);\n    }\n\n    ///                     ~~~PSP Beacon updates~~~\n\n    /// @notice Registers the Beacon update subscription\n    /// @dev Similar to how one needs to call `requestRrpBeaconUpdate()` for\n    /// this contract to recognize the incoming RRP fulfillment, this needs to\n    /// be called before the subscription fulfillments.\n    /// In addition to the subscription being registered, the sponsor must use\n    /// `setPspSponsorshipStatus()` to give permission for its sponsor wallet\n    /// to be used for the specific subscription.\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param conditions Conditions under which the subscription is requested\n    /// to be fulfilled\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @return subscriptionId Subscription ID\n    function registerBeaconUpdateSubscription(\n        address airnode,\n        bytes32 templateId,\n        bytes memory conditions,\n        address relayer,\n        address sponsor\n    ) external override returns (bytes32 subscriptionId) {\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        subscriptionId = keccak256(\n            abi.encode(\n                block.chainid,\n                airnode,\n                templateId,\n                \"\",\n                conditions,\n                relayer,\n                sponsor,\n                address(this),\n                this.fulfillPspBeaconUpdate.selector\n            )\n        );\n        subscriptionIdToHash[subscriptionId] = keccak256(\n            abi.encodePacked(airnode, relayer, sponsor)\n        );\n        subscriptionIdToBeaconId[subscriptionId] = deriveBeaconId(\n            airnode,\n            templateId\n        );\n        emit RegisteredBeaconUpdateSubscription(\n            subscriptionId,\n            airnode,\n            templateId,\n            \"\",\n            conditions,\n            relayer,\n            sponsor,\n            address(this),\n            this.fulfillPspBeaconUpdate.selector\n        );\n    }\n\n    /// @notice Returns if the respective Beacon needs to be updated based on\n    /// the fulfillment data and the condition parameters\n    /// @dev Reverts if not called by a void signer with zero address because\n    /// this method can be used to indirectly read a Beacon.\n    /// `conditionParameters` are specified within the `conditions` field of a\n    /// Subscription.\n    /// @param subscriptionId Subscription ID\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @param conditionParameters Subscription condition parameters (a\n    /// `uint256` encoded in contract ABI)\n    /// @return If the Beacon update subscription should be fulfilled\n    function conditionPspBeaconUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external view override returns (bool) {\n        require(msg.sender == address(0), \"Sender not zero address\");\n        bytes32 beaconId = subscriptionIdToBeaconId[subscriptionId];\n        require(beaconId != bytes32(0), \"Subscription not registered\");\n        DataFeed storage beacon = dataFeeds[beaconId];\n        return\n            calculateUpdateInPercentage(\n                beacon.value,\n                decodeFulfillmentData(data)\n            ) >=\n            decodeConditionParameters(conditionParameters) ||\n            beacon.timestamp == 0;\n    }\n\n    /// @notice Called by the Airnode/relayer using the sponsor wallet to\n    /// fulfill the Beacon update subscription\n    /// @dev There is no need to verify that `conditionPspBeaconUpdate()`\n    /// returns `true` because any Beacon update is a good Beacon update\n    /// @param subscriptionId Subscription ID\n    /// @param airnode Airnode address\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (a single `int256` encoded in contract\n    /// ABI)\n    /// @param signature Subscription ID, timestamp, sponsor wallet address\n    /// (and fulfillment data if the relayer is not the Airnode) signed by the\n    /// Airnode wallet\n    function fulfillPspBeaconUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override onlyValidTimestamp(timestamp) {\n        require(\n            subscriptionIdToHash[subscriptionId] ==\n                keccak256(abi.encodePacked(airnode, relayer, sponsor)),\n            \"Subscription not registered\"\n        );\n        if (airnode == relayer) {\n            require(\n                (\n                    keccak256(\n                        abi.encodePacked(subscriptionId, timestamp, msg.sender)\n                    ).toEthSignedMessageHash()\n                ).recover(signature) == airnode,\n                \"Signature mismatch\"\n            );\n        } else {\n            require(\n                (\n                    keccak256(\n                        abi.encodePacked(\n                            subscriptionId,\n                            timestamp,\n                            msg.sender,\n                            data\n                        )\n                    ).toEthSignedMessageHash()\n                ).recover(signature) == airnode,\n                \"Signature mismatch\"\n            );\n        }\n        bytes32 beaconId = subscriptionIdToBeaconId[subscriptionId];\n        // Beacon ID is guaranteed to not be zero because the subscription is\n        // registered\n        int256 decodedData = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithPsp(\n            beaconId,\n            subscriptionId,\n            int224(decodedData),\n            uint32(timestamp)\n        );\n    }\n\n    ///                     ~~~Signed data Beacon updates~~~\n\n    /// @notice Updates a Beacon using data signed by the respective Airnode,\n    /// without requiring a request or subscription\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Response data (an `int256` encoded in contract ABI)\n    /// @param signature Template ID, a timestamp and the response data signed\n    /// by the Airnode address\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 templateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override onlyValidTimestamp(timestamp) {\n        require(\n            (\n                keccak256(abi.encodePacked(templateId, timestamp, data))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Signature mismatch\"\n        );\n        bytes32 beaconId = deriveBeaconId(airnode, templateId);\n        int256 decodedData = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithSignedData(beaconId, decodedData, timestamp);\n    }\n\n    ///                     ~~~PSP Beacon set updates~~~\n\n    /// @notice Updates the Beacon set using the current values of its Beacons\n    /// @dev This function still works if some of the IDs in `beaconIds` belong\n    /// to Beacon sets rather than Beacons. However, this is not the intended\n    /// use.\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithBeacons(bytes32[] memory beaconIds)\n        public\n        override\n        returns (bytes32 beaconSetId)\n    {\n        uint256 beaconCount = beaconIds.length;\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        int256[] memory values = new int256[](beaconCount);\n        uint256 accumulatedTimestamp = 0;\n        for (uint256 ind = 0; ind < beaconCount; ind++) {\n            DataFeed storage dataFeed = dataFeeds[beaconIds[ind]];\n            values[ind] = dataFeed.value;\n            accumulatedTimestamp += dataFeed.timestamp;\n        }\n        uint32 updatedTimestamp = uint32(accumulatedTimestamp / beaconCount);\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        require(\n            updatedTimestamp >= dataFeeds[beaconSetId].timestamp,\n            \"Updated value outdated\"\n        );\n        int224 updatedValue = int224(median(values));\n        dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithBeacons(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Updates the Beacon set using the current values of the Beacons\n    /// and returns if this update was justified according to the deviation\n    /// threshold\n    /// @dev This method does not allow the caller to indirectly read a Beacon\n    /// set, which is why it does not require the sender to be a void signer\n    /// with zero address. This allows the implementation of incentive\n    /// mechanisms that rewards keepers that trigger valid dAPI updates.\n    /// @param beaconIds Beacon IDs\n    /// @param deviationThresholdInPercentage Deviation threshold in percentage\n    /// where 100% is represented as `HUNDRED_PERCENT`\n    function updateBeaconSetWithBeaconsAndReturnCondition(\n        bytes32[] memory beaconIds,\n        uint256 deviationThresholdInPercentage\n    ) public override returns (bool) {\n        bytes32 beaconSetId = deriveBeaconSetId(beaconIds);\n        DataFeed memory initialBeaconSet = dataFeeds[beaconSetId];\n        updateBeaconSetWithBeacons(beaconIds);\n        DataFeed storage updatedBeaconSet = dataFeeds[beaconSetId];\n        return\n            calculateUpdateInPercentage(\n                initialBeaconSet.value,\n                updatedBeaconSet.value\n            ) >=\n            deviationThresholdInPercentage ||\n            (initialBeaconSet.timestamp == 0 && updatedBeaconSet.timestamp > 0);\n    }\n\n    /// @notice Returns if the respective Beacon set needs to be updated based\n    /// on the condition parameters\n    /// @dev The template ID used in the respective Subscription is expected to\n    /// be zero, which means the `parameters` field of the Subscription will be\n    /// forwarded to this function as `data`. This field should be the Beacon\n    /// ID array encoded in contract ABI.\n    /// @param subscriptionId Subscription ID\n    /// @param data Fulfillment data (array of Beacon IDs, i.e., `bytes32[]`\n    /// encoded in contract ABI)\n    /// @param conditionParameters Subscription condition parameters (a\n    /// `uint256` encoded in contract ABI)\n    /// @return If the Beacon set update subscription should be fulfilled\n    function conditionPspBeaconSetUpdate(\n        bytes32 subscriptionId, // solhint-disable-line no-unused-vars\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external override returns (bool) {\n        require(msg.sender == address(0), \"Sender not zero address\");\n        bytes32[] memory beaconIds = abi.decode(data, (bytes32[]));\n        require(\n            keccak256(abi.encode(beaconIds)) == keccak256(data),\n            \"Data length not correct\"\n        );\n        return\n            updateBeaconSetWithBeaconsAndReturnCondition(\n                beaconIds,\n                decodeConditionParameters(conditionParameters)\n            );\n    }\n\n    /// @notice Called by the Airnode/relayer using the sponsor wallet to\n    /// fulfill the Beacon set update subscription\n    /// @dev Similar to `conditionPspBeaconSetUpdate()`, if `templateId` of the\n    /// Subscription is zero, its `parameters` field will be forwarded to\n    /// `data` here, which is expect to be contract ABI-encoded array of Beacon\n    /// IDs.\n    /// It does not make sense for this subscription to be relayed, as there is\n    /// no external data being delivered. Nevertheless, this is allowed for the\n    /// lack of a reason to prevent it.\n    /// Even though the consistency of the arguments are not being checked, if\n    /// a standard implementation of Airnode is being used, these can be\n    /// expected to be correct. Either way, the assumption is that it does not\n    /// matter for the purposes of a Beacon set update subscription.\n    /// @param subscriptionId Subscription ID\n    /// @param airnode Airnode address\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @param signature Subscription ID, timestamp, sponsor wallet address\n    /// (and fulfillment data if the relayer is not the Airnode) signed by the\n    /// Airnode wallet\n    function fulfillPspBeaconSetUpdate(\n        bytes32 subscriptionId, // solhint-disable-line no-unused-vars\n        address airnode, // solhint-disable-line no-unused-vars\n        address relayer, // solhint-disable-line no-unused-vars\n        address sponsor, // solhint-disable-line no-unused-vars\n        uint256 timestamp, // solhint-disable-line no-unused-vars\n        bytes calldata data,\n        bytes calldata signature // solhint-disable-line no-unused-vars\n    ) external override {\n        require(\n            keccak256(data) ==\n                updateBeaconSetWithBeacons(abi.decode(data, (bytes32[]))),\n            \"Data length not correct\"\n        );\n    }\n\n    ///                     ~~~Signed data Beacon set updates~~~\n\n    /// @notice Updates a Beacon set using data signed by the respective\n    /// Airnodes without requiring a request or subscription. The Beacons for\n    /// which the signature is omitted will be read from the storage.\n    /// @param airnodes Airnode addresses\n    /// @param templateIds Template IDs\n    /// @param timestamps Timestamps used in the signatures\n    /// @param data Response data (an `int256` encoded in contract ABI per\n    /// Beacon)\n    /// @param signatures Template ID, a timestamp and the response data signed\n    /// by the respective Airnode address per Beacon\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithSignedData(\n        address[] memory airnodes,\n        bytes32[] memory templateIds,\n        uint256[] memory timestamps,\n        bytes[] memory data,\n        bytes[] memory signatures\n    ) external override returns (bytes32 beaconSetId) {\n        uint256 beaconCount = airnodes.length;\n        require(\n            beaconCount == templateIds.length &&\n                beaconCount == timestamps.length &&\n                beaconCount == data.length &&\n                beaconCount == signatures.length,\n            \"Parameter length mismatch\"\n        );\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        bytes32[] memory beaconIds = new bytes32[](beaconCount);\n        int256[] memory values = new int256[](beaconCount);\n        uint256 accumulatedTimestamp = 0;\n        for (uint256 ind = 0; ind < beaconCount; ind++) {\n            if (signatures[ind].length != 0) {\n                address airnode = airnodes[ind];\n                uint256 timestamp = timestamps[ind];\n                require(timestampIsValid(timestamp), \"Timestamp not valid\");\n                require(\n                    (\n                        keccak256(\n                            abi.encodePacked(\n                                templateIds[ind],\n                                timestamp,\n                                data[ind]\n                            )\n                        ).toEthSignedMessageHash()\n                    ).recover(signatures[ind]) == airnode,\n                    \"Signature mismatch\"\n                );\n                values[ind] = decodeFulfillmentData(data[ind]);\n                // Timestamp validity is already checked, which means it will\n                // be small enough to be typecast into `uint32`\n                accumulatedTimestamp += timestamp;\n                beaconIds[ind] = deriveBeaconId(airnode, templateIds[ind]);\n            } else {\n                bytes32 beaconId = deriveBeaconId(\n                    airnodes[ind],\n                    templateIds[ind]\n                );\n                DataFeed storage dataFeed = dataFeeds[beaconId];\n                values[ind] = dataFeed.value;\n                accumulatedTimestamp += dataFeed.timestamp;\n                beaconIds[ind] = beaconId;\n            }\n        }\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        uint32 updatedTimestamp = uint32(accumulatedTimestamp / beaconCount);\n        require(\n            updatedTimestamp >= dataFeeds[beaconSetId].timestamp,\n            \"Updated value outdated\"\n        );\n        int224 updatedValue = int224(median(values));\n        dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithSignedData(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Called by the manager to add the unlimited reader indefinitely\n    /// @dev Since the unlimited reader status cannot be revoked, only\n    /// contracts that are adequately restricted should be given this status\n    /// @param unlimitedReader Unlimited reader address\n    function addUnlimitedReader(address unlimitedReader) external override {\n        require(msg.sender == manager, \"Sender not manager\");\n        unlimitedReaderStatus[unlimitedReader] = true;\n        emit AddedUnlimitedReader(unlimitedReader);\n    }\n\n    /// @notice Sets the data feed ID the dAPI name points to\n    /// @dev While a data feed ID refers to a specific Beacon or Beacon set,\n    /// dAPI names provide a more abstract interface for convenience. This\n    /// means a dAPI name that was pointing to a Beacon can be pointed to a\n    /// Beacon set, then another Beacon set, etc.\n    /// @param dapiName Human-readable dAPI name\n    /// @param dataFeedId Data feed ID the dAPI name will point to\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId)\n        external\n        override\n    {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        require(\n            msg.sender == manager ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    dapiNameSetterRole,\n                    msg.sender\n                ),\n            \"Sender cannot set dAPI name\"\n        );\n        dapiNameHashToDataFeedId[\n            keccak256(abi.encodePacked(dapiName))\n        ] = dataFeedId;\n        emit SetDapiName(dapiName, dataFeedId, msg.sender);\n    }\n\n    /// @notice Returns the data feed ID the dAPI name is set to\n    /// @param dapiName dAPI name\n    /// @return Data feed ID\n    function dapiNameToDataFeedId(bytes32 dapiName)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return dapiNameHashToDataFeedId[keccak256(abi.encodePacked(dapiName))];\n    }\n\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithId(bytes32 dataFeedId)\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        require(\n            readerCanReadDataFeed(dataFeedId, msg.sender),\n            \"Sender cannot read\"\n        );\n        DataFeed storage dataFeed = dataFeeds[dataFeedId];\n        return (dataFeed.value, dataFeed.timestamp);\n    }\n\n    /// @notice Reads the data feed value with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    function readDataFeedValueWithId(bytes32 dataFeedId)\n        external\n        view\n        override\n        returns (int224 value)\n    {\n        require(\n            readerCanReadDataFeed(dataFeedId, msg.sender),\n            \"Sender cannot read\"\n        );\n        DataFeed storage dataFeed = dataFeeds[dataFeedId];\n        require(dataFeed.timestamp != 0, \"Data feed does not exist\");\n        return dataFeed.value;\n    }\n\n    /// @notice Reads the data feed with dAPI name\n    /// @dev The read data feed may belong to a Beacon or dAPI. The reader\n    /// must be whitelisted for the hash of the dAPI name.\n    /// @param dapiName dAPI name\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithDapiName(bytes32 dapiName)\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        bytes32 dapiNameHash = keccak256(abi.encodePacked(dapiName));\n        require(\n            readerCanReadDataFeed(dapiNameHash, msg.sender),\n            \"Sender cannot read\"\n        );\n        bytes32 dataFeedId = dapiNameHashToDataFeedId[dapiNameHash];\n        require(dataFeedId != bytes32(0), \"dAPI name not set\");\n        DataFeed storage dataFeed = dataFeeds[dataFeedId];\n        return (dataFeed.value, dataFeed.timestamp);\n    }\n\n    /// @notice Reads the data feed value with dAPI name\n    /// @param dapiName dAPI name\n    /// @return value Data feed value\n    function readDataFeedValueWithDapiName(bytes32 dapiName)\n        external\n        view\n        override\n        returns (int224 value)\n    {\n        bytes32 dapiNameHash = keccak256(abi.encodePacked(dapiName));\n        require(\n            readerCanReadDataFeed(dapiNameHash, msg.sender),\n            \"Sender cannot read\"\n        );\n        DataFeed storage dataFeed = dataFeeds[\n            dapiNameHashToDataFeedId[dapiNameHash]\n        ];\n        require(dataFeed.timestamp != 0, \"Data feed does not exist\");\n        return dataFeed.value;\n    }\n\n    /// @notice Returns if a reader can read the data feed\n    /// @param dataFeedId Data feed ID (or dAPI name hash)\n    /// @param reader Reader address\n    /// @return If the reader can read the data feed\n    function readerCanReadDataFeed(bytes32 dataFeedId, address reader)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            reader == address(0) ||\n            userIsWhitelisted(dataFeedId, reader) ||\n            unlimitedReaderStatus[reader];\n    }\n\n    /// @notice Returns the detailed whitelist status of the reader for the\n    /// data feed\n    /// @param dataFeedId Data feed ID (or dAPI name hash)\n    /// @param reader Reader address\n    /// @return expirationTimestamp Timestamp at which the whitelisting of the\n    /// reader will expire\n    /// @return indefiniteWhitelistCount Number of times `reader` was\n    /// whitelisted indefinitely for `dataFeedId`\n    function dataFeedIdToReaderToWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader\n    )\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                dataFeedId\n            ][reader];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\n    }\n\n    /// @notice Returns if an account has indefinitely whitelisted the reader\n    /// for the data feed\n    /// @param dataFeedId Data feed ID (or dAPI name hash)\n    /// @param reader Reader address\n    /// @param setter Address of the account that has potentially whitelisted\n    /// the reader for the data feed indefinitely\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\n    /// whitelisted reader for the data feed\n    function dataFeedIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\n            dataFeedId\n        ][reader][setter];\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(address airnode, bytes32 templateId)\n        public\n        pure\n        override\n        returns (bytes32 beaconId)\n    {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(templateId != bytes32(0), \"Template ID zero\");\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n\n    /// @notice Derives the Beacon set ID from the Beacon IDs\n    /// @dev Notice that `abi.encode()` is used over `abi.encodePacked()`\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function deriveBeaconSetId(bytes32[] memory beaconIds)\n        public\n        pure\n        override\n        returns (bytes32 beaconSetId)\n    {\n        beaconSetId = keccak256(abi.encode(beaconIds));\n    }\n\n    /// @notice Called privately to process the Beacon update\n    /// @param beaconId Beacon ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return updatedBeaconValue Updated Beacon value\n    function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    ) private returns (int256 updatedBeaconValue) {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > dataFeeds[beaconId].timestamp,\n            \"Fulfillment older than Beacon\"\n        );\n        // Timestamp validity is already checked by `onlyValidTimestamp`, which\n        // means it will be small enough to be typecast into `uint32`\n        dataFeeds[beaconId] = DataFeed({\n            value: int224(updatedBeaconValue),\n            timestamp: uint32(timestamp)\n        });\n    }\n\n    /// @notice Called privately to decode the fulfillment data\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return decodedData Decoded fulfillment data\n    function decodeFulfillmentData(bytes memory data)\n        private\n        pure\n        returns (int224)\n    {\n        require(data.length == 32, \"Data length not correct\");\n        int256 decodedData = abi.decode(data, (int256));\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        return int224(decodedData);\n    }\n\n    /// @notice Called privately to decode the condition parameters\n    /// @param conditionParameters Condition parameters (a `uint256` encoded in\n    /// contract ABI)\n    /// @return deviationThresholdInPercentage Deviation threshold in\n    /// percentage where 100% is represented as `HUNDRED_PERCENT`\n    function decodeConditionParameters(bytes calldata conditionParameters)\n        private\n        pure\n        returns (uint256 deviationThresholdInPercentage)\n    {\n        require(conditionParameters.length == 32, \"Incorrect parameter length\");\n        deviationThresholdInPercentage = abi.decode(\n            conditionParameters,\n            (uint256)\n        );\n    }\n\n    /// @notice Called privately to calculate the update magnitude in\n    /// percentages where 100% is represented as `HUNDRED_PERCENT`\n    /// @dev The percentage changes will be more pronounced when the first\n    /// value is almost zero, which may trigger updates more frequently than\n    /// wanted. To avoid this, Beacons should be defined in a way that the\n    /// expected values are not small numbers floating around zero, i.e.,\n    /// offset and scale.\n    /// @param initialValue Initial value\n    /// @param updatedValue Updated value\n    /// @return updateInPercentage Update in percentage\n    function calculateUpdateInPercentage(\n        int224 initialValue,\n        int224 updatedValue\n    ) private pure returns (uint256 updateInPercentage) {\n        int256 delta = int256(updatedValue) - int256(initialValue);\n        uint256 absoluteDelta = delta > 0 ? uint256(delta) : uint256(-delta);\n        uint256 absoluteInitialValue = initialValue > 0\n            ? uint256(int256(initialValue))\n            : uint256(-int256(initialValue));\n        // Avoid division by 0\n        if (absoluteInitialValue == 0) {\n            absoluteInitialValue = 1;\n        }\n        updateInPercentage =\n            (absoluteDelta * HUNDRED_PERCENT) /\n            absoluteInitialValue;\n    }\n}\n"
    },
    "contracts/protocol/AirnodeRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAirnodeProtocol.sol\";\nimport \"./interfaces/IAirnodeRequester.sol\";\n\n/// @title Contract to be inherited by contracts that will make Airnode\n/// requests and receive fulfillments\ncontract AirnodeRequester is IAirnodeRequester {\n    /// @notice AirnodeProtocol contract address\n    address public immutable override airnodeProtocol;\n\n    /// @dev Reverts if the sender is not the AirnodeProtocol contract. Use\n    /// this modifier with methods that are meant to receive RRP fulfillments.\n    modifier onlyAirnodeProtocol() {\n        require(\n            msg.sender == address(airnodeProtocol),\n            \"Sender not Airnode protocol\"\n        );\n        _;\n    }\n\n    /// @dev Reverts if the timestamp is not valid. Use this modifier with\n    /// methods that are meant to receive RRP and PSP fulfillments.\n    /// @param timestamp Timestamp used in the signature\n    modifier onlyValidTimestamp(uint256 timestamp) {\n        require(timestampIsValid(timestamp), \"Timestamp not valid\");\n        _;\n    }\n\n    /// @param _airnodeProtocol AirnodeProtocol contract address\n    constructor(address _airnodeProtocol) {\n        require(_airnodeProtocol != address(0), \"AirnodeProtocol address zero\");\n        airnodeProtocol = _airnodeProtocol;\n    }\n\n    /// @notice Returns if the timestamp used in the signature is valid\n    /// @dev Returns `false` if the timestamp is not at most 1 hour old to\n    /// prevent replays. Returns `false` if the timestamp is not from the past,\n    /// with some leeway to accomodate for some benign time drift. These values\n    /// are appropriate in most cases, but you can adjust them if you are aware\n    /// of the implications.\n    /// @param timestamp Timestamp used in the signature\n    function timestampIsValid(uint256 timestamp) internal view returns (bool) {\n        return\n            timestamp + 1 hours > block.timestamp &&\n            timestamp < block.timestamp + 15 minutes;\n    }\n}\n"
    },
    "contracts/dapis/Median.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Sort.sol\";\nimport \"./QuickSelect.sol\";\n\n/// @title Contract to be inherited by contracts that will calculate the median\n/// of an array\n/// @notice The operation will be in-place, i.e., the array provided as the\n/// argument will be modified.\ncontract Median is Sort, Quickselect {\n    /// @notice Returns the median of the array\n    /// @dev Uses an unrolled sorting implementation for shorter arrays and\n    /// quickselect for longer arrays for gas cost efficiency\n    /// @param array Array whose median is to be calculated\n    /// @return Median of the array\n    function median(int256[] memory array) internal pure returns (int256) {\n        uint256 arrayLength = array.length;\n        if (arrayLength <= MAX_SORT_LENGTH) {\n            sort(array);\n            if (arrayLength % 2 == 1) {\n                return array[arrayLength / 2];\n            } else {\n                return\n                    (array[arrayLength / 2 - 1] + array[arrayLength / 2]) / 2;\n            }\n        } else {\n            if (arrayLength % 2 == 1) {\n                return array[quickselectK(array, arrayLength / 2)];\n            } else {\n                (uint256 mid1, uint256 mid2) = quickselectKPlusOne(\n                    array,\n                    arrayLength / 2 - 1\n                );\n                return (array[mid1] + array[mid2]) / 2;\n            }\n        }\n    }\n}\n"
    },
    "contracts/dapis/interfaces/IDapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../protocol/interfaces/IAirnodeRequester.sol\";\n\ninterface IDapiServer is IAirnodeRequester {\n    event SetRrpBeaconUpdatePermissionStatus(\n        address indexed sponsor,\n        address indexed rrpBeaconUpdateRequester,\n        bool status\n    );\n\n    event RequestedRrpBeaconUpdate(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address airnode,\n        bytes32 templateId\n    );\n\n    event RequestedRrpBeaconUpdateRelayed(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address airnode,\n        address relayer,\n        bytes32 templateId\n    );\n\n    event UpdatedBeaconWithRrp(\n        bytes32 indexed beaconId,\n        bytes32 requestId,\n        int256 value,\n        uint256 timestamp\n    );\n\n    event RegisteredBeaconUpdateSubscription(\n        bytes32 indexed subscriptionId,\n        address airnode,\n        bytes32 templateId,\n        bytes parameters,\n        bytes conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    );\n\n    event UpdatedBeaconWithPsp(\n        bytes32 indexed beaconId,\n        bytes32 subscriptionId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedBeaconWithSignedData(\n        bytes32 indexed beaconId,\n        int256 value,\n        uint256 timestamp\n    );\n\n    event UpdatedBeaconSetWithBeacons(\n        bytes32 indexed beaconSetId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedBeaconSetWithSignedData(\n        bytes32 indexed dapiId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event AddedUnlimitedReader(address indexed unlimitedReader);\n\n    event SetDapiName(\n        bytes32 indexed dapiName,\n        bytes32 dataFeedId,\n        address indexed sender\n    );\n\n    function setRrpBeaconUpdatePermissionStatus(\n        address rrpBeaconUpdateRequester,\n        bool status\n    ) external;\n\n    function requestRrpBeaconUpdate(\n        address airnode,\n        bytes32 templateId,\n        address sponsor\n    ) external returns (bytes32 requestId);\n\n    function requestRrpBeaconUpdateRelayed(\n        address airnode,\n        bytes32 templateId,\n        address relayer,\n        address sponsor\n    ) external returns (bytes32 requestId);\n\n    function fulfillRrpBeaconUpdate(\n        bytes32 requestId,\n        uint256 timestamp,\n        bytes calldata data\n    ) external;\n\n    function registerBeaconUpdateSubscription(\n        address airnode,\n        bytes32 templateId,\n        bytes memory conditions,\n        address relayer,\n        address sponsor\n    ) external returns (bytes32 subscriptionId);\n\n    function conditionPspBeaconUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external view returns (bool);\n\n    function fulfillPspBeaconUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconSetWithBeacons(bytes32[] memory beaconIds)\n        external\n        returns (bytes32 beaconSetId);\n\n    function updateBeaconSetWithBeaconsAndReturnCondition(\n        bytes32[] memory beaconIds,\n        uint256 updateThresholdInPercentage\n    ) external returns (bool);\n\n    function conditionPspBeaconSetUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external returns (bool);\n\n    function fulfillPspBeaconSetUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconSetWithSignedData(\n        address[] memory airnodes,\n        bytes32[] memory templateIds,\n        uint256[] memory timestamps,\n        bytes[] memory data,\n        bytes[] memory signatures\n    ) external returns (bytes32 beaconSetId);\n\n    function addUnlimitedReader(address unlimitedReader) external;\n\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId) external;\n\n    function dapiNameToDataFeedId(bytes32 dapiName)\n        external\n        view\n        returns (bytes32);\n\n    function readDataFeedWithId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readDataFeedValueWithId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value);\n\n    function readDataFeedWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readDataFeedValueWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value);\n\n    function readerCanReadDataFeed(bytes32 dataFeedId, address reader)\n        external\n        view\n        returns (bool);\n\n    function dataFeedIdToReaderToWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function dataFeedIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function deriveBeaconId(address airnode, bytes32 templateId)\n        external\n        pure\n        returns (bytes32 beaconId);\n\n    function deriveBeaconSetId(bytes32[] memory beaconIds)\n        external\n        pure\n        returns (bytes32 beaconSetId);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DAPI_NAME_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function HUNDRED_PERCENT() external view returns (uint256);\n\n    function dapiNameSetterRole() external view returns (bytes32);\n\n    function sponsorToRrpBeaconUpdateRequesterToPermissionStatus(\n        address sponsor,\n        address updateRequester\n    ) external view returns (bool);\n\n    function subscriptionIdToBeaconId(bytes32 subscriptionId)\n        external\n        view\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/interfaces/IAirnodeRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAirnodeRequester {\n    function airnodeProtocol() external view returns (address);\n}\n"
    },
    "contracts/dapis/Sort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will sort an array using\n/// an unrolled implementation\n/// @notice The operation will be in-place, i.e., the array provided as the\n/// argument will be modified.\ncontract Sort {\n    uint256 internal constant MAX_SORT_LENGTH = 9;\n\n    /// @notice Sorts the array\n    /// @param array Array to be sorted\n    function sort(int256[] memory array) internal pure {\n        uint256 arrayLength = array.length;\n        require(arrayLength <= MAX_SORT_LENGTH, \"Array too long to sort\");\n        // Do a binary search\n        if (arrayLength < 6) {\n            // Possible lengths: 1, 2, 3, 4, 5\n            if (arrayLength < 4) {\n                // Possible lengths: 1, 2, 3\n                if (arrayLength == 3) {\n                    // Length: 3\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 0, 1);\n                } else if (arrayLength == 2) {\n                    // Length: 2\n                    swapIfFirstIsLarger(array, 0, 1);\n                }\n                // Do nothing for Length: 1\n            } else {\n                // Possible lengths: 4, 5\n                if (arrayLength == 5) {\n                    // Length: 5\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 1, 2);\n                } else {\n                    // Length: 4\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 1, 2);\n                }\n            }\n        } else {\n            // Possible lengths: 6, 7, 8, 9\n            if (arrayLength < 8) {\n                // Possible lengths: 6, 7\n                if (arrayLength == 7) {\n                    // Length: 7\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 4, 6);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 2, 6);\n                    swapIfFirstIsLarger(array, 1, 5);\n                    swapIfFirstIsLarger(array, 0, 4);\n                    swapIfFirstIsLarger(array, 2, 5);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                } else {\n                    // Length: 6\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 2, 3);\n                }\n            } else {\n                // Possible lengths: 8, 9\n                if (arrayLength == 9) {\n                    // Length: 9\n                    swapIfFirstIsLarger(array, 1, 8);\n                    swapIfFirstIsLarger(array, 2, 7);\n                    swapIfFirstIsLarger(array, 3, 6);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 1, 4);\n                    swapIfFirstIsLarger(array, 5, 8);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 2, 6);\n                    swapIfFirstIsLarger(array, 7, 8);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 5, 7);\n                    swapIfFirstIsLarger(array, 4, 6);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 7, 8);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                } else {\n                    // Length: 8\n                    swapIfFirstIsLarger(array, 0, 7);\n                    swapIfFirstIsLarger(array, 1, 6);\n                    swapIfFirstIsLarger(array, 2, 5);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 4, 7);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 3, 4);\n                }\n            }\n        }\n    }\n\n    /// @notice Swaps two elements of an array if the first element is greater\n    /// than the second\n    /// @param array Array whose elements are to be swapped\n    /// @param ind1 Index of the first element\n    /// @param ind2 Index of the second element\n    function swapIfFirstIsLarger(\n        int256[] memory array,\n        uint256 ind1,\n        uint256 ind2\n    ) private pure {\n        if (array[ind1] > array[ind2]) {\n            (array[ind1], array[ind2]) = (array[ind2], array[ind1]);\n        }\n    }\n}\n"
    },
    "contracts/dapis/QuickSelect.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will calculate the index\n/// of the k-th and optionally (k+1)-th largest elements in the array\n/// @notice Uses quickselect, which operates in-place, i.e., the array provided\n/// as the argument will be modified.\ncontract Quickselect {\n    /// @notice Returns the index of the k-th largest element in the array\n    /// @param array Array in which k-th largest element will be searched\n    /// @param k K\n    /// @return indK Index of the k-th largest element\n    function quickselectK(int256[] memory array, uint256 k)\n        internal\n        pure\n        returns (uint256 indK)\n    {\n        (indK, ) = quickselect(array, 0, array.length - 1, k, false);\n    }\n\n    /// @notice Returns the index of the k-th and (k+1)-th largest elements in\n    /// the array\n    /// @param array Array in which k-th and (k+1)-th largest elements will be\n    /// searched\n    /// @param k K\n    /// @return indK Index of the k-th largest element\n    /// @return indKPlusOne Index of the (k+1)-th largest element\n    function quickselectKPlusOne(int256[] memory array, uint256 k)\n        internal\n        pure\n        returns (uint256 indK, uint256 indKPlusOne)\n    {\n        uint256 arrayLength = array.length;\n        require(arrayLength > 1, \"Array too short to select k+1\");\n        return quickselect(array, 0, arrayLength - 1, k, true);\n    }\n\n    /// @notice Returns the index of the k-th largest element in the specified\n    /// section of the (potentially unsorted) array\n    /// @param array Array in which K will be searched for\n    /// @param lo Starting index of the section of the array that K will be\n    /// searched in\n    /// @param hi Last index of the section of the array that K will be\n    /// searched in\n    /// @param k K\n    /// @param selectKPlusOne If the index of the (k+1)-th largest element is\n    /// to be returned\n    /// @return indK Index of the k-th largest element\n    /// @return indKPlusOne Index of the (k+1)-th largest element (only set if\n    /// `selectKPlusOne` is `true`)\n    function quickselect(\n        int256[] memory array,\n        uint256 lo,\n        uint256 hi,\n        uint256 k,\n        bool selectKPlusOne\n    ) private pure returns (uint256 indK, uint256 indKPlusOne) {\n        if (lo == hi) {\n            return (k, 0);\n        }\n        uint256 indPivot = partition(array, lo, hi);\n        if (k < indPivot) {\n            (indK, ) = quickselect(array, lo, indPivot - 1, k, false);\n        } else if (k > indPivot) {\n            (indK, ) = quickselect(array, indPivot + 1, hi, k, false);\n        } else {\n            indK = indPivot;\n        }\n        // Since Quickselect ends in the array being partitioned around the\n        // k-th largest element, we can continue searching towards right for\n        // the (k+1)-th largest element, which is useful in calculating the\n        // median of an array with even length\n        if (selectKPlusOne) {\n            indKPlusOne = indK + 1;\n            for (uint256 i = indKPlusOne + 1; i < array.length; i++) {\n                if (array[i] < array[indKPlusOne]) {\n                    indKPlusOne = i;\n                }\n            }\n        }\n    }\n\n    /// @notice Partitions the array into two around a pivot\n    /// @param array Array that will be partitioned\n    /// @param lo Starting index of the section of the array that will be\n    /// partitioned\n    /// @param hi Last index of the section of the array that will be\n    /// partitioned\n    /// @return pivotInd Pivot index\n    function partition(\n        int256[] memory array,\n        uint256 lo,\n        uint256 hi\n    ) private pure returns (uint256 pivotInd) {\n        if (lo == hi) {\n            return lo;\n        }\n        int256 pivot = array[lo];\n        uint256 i = lo;\n        pivotInd = hi + 1;\n        while (true) {\n            do {\n                i++;\n            } while (i < array.length && array[i] < pivot);\n            do {\n                pivotInd--;\n            } while (array[pivotInd] > pivot);\n            if (i >= pivotInd) {\n                (array[lo], array[pivotInd]) = (array[pivotInd], array[lo]);\n                return pivotInd;\n            }\n            (array[i], array[pivotInd]) = (array[pivotInd], array[i]);\n        }\n    }\n}\n"
    },
    "contracts/protocol/mock/MockSponsor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../AirnodeRequester.sol\";\n\ncontract MockSponsor is AirnodeRequester {\n    constructor(address _airnodeProtocol) AirnodeRequester(_airnodeProtocol) {}\n\n    function requestWithdrawal(address airnodeOrRelayer, uint256 protocolId)\n        external\n    {\n        IAirnodeProtocol(airnodeProtocol).requestWithdrawal(\n            airnodeOrRelayer,\n            protocolId\n        );\n    }\n\n    function claimBalance() external {\n        IAirnodeProtocol(airnodeProtocol).claimBalance();\n    }\n}\n"
    },
    "contracts/protocol/mock/MockAirnodeRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../AirnodeRequester.sol\";\n\ncontract MockAirnodeRequester is AirnodeRequester {\n    mapping(bytes32 => bytes) public requestIdToData;\n\n    constructor(address _airnodeProtocol) AirnodeRequester(_airnodeProtocol) {}\n\n    function makeRequest(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 requestId) {\n        requestId = IAirnodeProtocol(airnodeProtocol).makeRequest(\n            airnode,\n            templateId,\n            parameters,\n            sponsor,\n            fulfillFunctionId\n        );\n    }\n\n    function makeRequestRelayed(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address relayer,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 requestId) {\n        requestId = IAirnodeProtocol(airnodeProtocol).makeRequestRelayed(\n            airnode,\n            templateId,\n            parameters,\n            relayer,\n            sponsor,\n            fulfillFunctionId\n        );\n    }\n\n    function fulfillRequest(\n        bytes32 requestId,\n        uint256 timestamp,\n        bytes calldata data\n    ) external onlyAirnodeProtocol onlyValidTimestamp(timestamp) {\n        requestIdToData[requestId] = data;\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment failure\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillRequestAlwaysReverts(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        uint256 timestamp,\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeProtocol onlyValidTimestamp(timestamp) {\n        revert(\"Always reverts\");\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment failure\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillRequestAlwaysRevertsWithNoString(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        uint256 timestamp,\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeProtocol onlyValidTimestamp(timestamp) {\n        revert(); // solhint-disable-line reason-string\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment running out of gas\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillRequestAlwaysRunsOutOfGas(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        uint256 timestamp,\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeProtocol onlyValidTimestamp(timestamp) {\n        while (true) {}\n    }\n}\n"
    },
    "contracts/dapis/interfaces/IDapiReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IDapiServer.sol\";\n\ninterface IDapiReader {\n    function dapiServer() external view returns (address);\n}\n"
    },
    "contracts/dapis/DapiReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IDapiReader.sol\";\n\n/// @title Contract to be inherited by contracts that will read from a\n/// DapiServer contract\ncontract DapiReader is IDapiReader {\n    /// @notice DapiServer contract address\n    address public override dapiServer;\n\n    /// @param _dapiServer DapiServer contract address\n    constructor(address _dapiServer) {\n        setDapiServer(_dapiServer);\n    }\n\n    /// @notice Called internally to update the DapiServer contract address\n    /// @dev Inheriting contracts are highly recommended to expose this\n    /// functionality to be able to migrate between DapiServer contracts.\n    /// Otherwise, when the DapiServer goes out of service for any reason,\n    /// the dependent contract will go defunct.\n    /// Since this is a critical action, it needs to be protected behind\n    /// mechanisms such as decentralized governance, timelocks, etc.\n    /// @param _dapiServer DapiServer contract address\n    function setDapiServer(address _dapiServer) internal {\n        require(_dapiServer != address(0), \"dAPI server address zero\");\n        dapiServer = _dapiServer;\n    }\n}\n"
    },
    "contracts/dapis/mock/MockDapiReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../DapiReader.sol\";\n\ncontract MockDapiReader is DapiReader {\n    constructor(address _dapiServer) DapiReader(_dapiServer) {}\n\n    function exposedSetDapiServer(address _dapiServer) external {\n        setDapiServer(_dapiServer);\n    }\n\n    function exposedReadWithDataFeedId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value, uint32 timestamp)\n    {\n        return IDapiServer(dapiServer).readDataFeedWithId(dataFeedId);\n    }\n\n    function exposedReadWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value, uint32 timestamp)\n    {\n        return IDapiServer(dapiServer).readDataFeedWithDapiName(dapiName);\n    }\n}\n"
    },
    "contracts/dapis/mock/MockSort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../Median.sol\";\n\ncontract MockSort is Sort {\n    function exposedSort(int256[] memory array)\n        external\n        pure\n        returns (int256[] memory)\n    {\n        sort(array);\n        return array;\n    }\n}\n"
    },
    "contracts/dapis/mock/MockMedian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../Median.sol\";\n\ncontract MockMedian is Median {\n    function exposedMedian(int256[] memory array)\n        external\n        pure\n        returns (int256)\n    {\n        return median(array);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}